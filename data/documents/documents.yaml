documents:
- document: 'Presentations and Talks These talks are aimed at beginner to intermediate
    Scala programmers that are interested in learning more about pure functional programming
    in Scala. I like to present a topic in depth whilst keeping it accessible. Feel
    free to contact me with questions and feedback on any of these talks, or on my
    availability to speak at your event. Scale by the Bay 2020 - Applicative: The
    Origin Story We''ve all seen many Monad tutorials, and maybe a few on Functors,
    but Applicative is lesser known, which is a shame because it has some super powers.
    In this talk I''ll tell the origin story of applicative, and show that once fully
    understood, it is a very powerful tool in your functional programming toolkit.
    The talk begins with a quick introduction to pure functional programming with
    effects, for beginners in the audience. Next we''ll look at the original paper
    in which applicative programming with effects is described. The code will be translated
    from the original Haskell to Scala, and we can see we can solve problems first
    with Monads, then more flexibly and elegantly with Applicative. Finally, we''ll
    look at how Applicative plays its part in the much lauded traverse function. Blog
    post: What''s Ap? Slides: Applicative: The Origin Story Toronto Scala Meetup 2020
    - Applicative: The Origin Story What''s the different between Monadic and Applicative
    composition? Where did Applicative come from? Find out in this in-depth session
    which takes you from the basics of pure functional programming to an advanced
    example using applicative functors, monoids, traverse, const and parallel IO.
    Blog post: What''s Ap? Slides: Applicative: The Origin Story Scala Love 2020 -
    What''s Ap? In this talk find out about three mapping functions map, flatMap and
    the lesser known ap. For each one we will learn what we can from its type signature,
    see what it does for some common data types and ultimately consider what it means
    from a more theoretical standpoint. We wrap up with an example of optimized image
    processing using the ap function. Blog post: What''s Ap? Slides: What''s Ap'
  key: talks.html
- document: Privacy and Security You can view this blog over https for your privacy
    and security. This blog uses Google analytics so that I can track which posts
    users are interested in and what search tools and referral links they used to
    get here. You can read more here Google Analytics Support
  key: privacy.html
- document: 'Pic from ajc1 on Flikr Step 1. Install gnutls iCloud requires you to
    send emails over secure channel, and emacs supports sending email with starttls
    or gnutls. gnutls is available through brew To install it is easy: brew install
    gnutls touch ~/.authinfo chmod 600 ~/.authinfo machine smtp.mail.me.com port 587
    login YOURNAME@icloud.com password YOURPASSWORD mdfind -name gnutls-cli It''s
    handy to be able to send emails from emacs, and this guide will show how to set
    up SMTP via an iCloud email account.Wait a few minutes while your Mac gets hot
    downloading and compiling!emacs can look in a file ~/.authinfo to find your login
    credentials, so create that file and fill in the blanks.The contents of the file
    should read:Add the following to your .emacs file:(setqsend-mail-function ''smtpmail-send-itmessage-send-mail-function
    ''smtpmail-send-ituser-mail-address "YOURNAME@icloud.com"user-full-name "YOUR
    FULLNAME"smtpmail-starttls-credentials ''(("smtp.mail.me.com" 587 nil nil))smtpmail-auth-credentials
    (expand-file-name "~/.authinfo")smtpmail-default-smtp-server "smtp.mail.me.com"smtpmail-smtp-server
    "smtp.mail.me.com"smtpmail-smtp-service 587smtpmail-debug-info tstarttls-extra-arguments
    nilstarttls-gnutls-program (executable-find "gnutls-cli")smtpmail-warn-about-unknown-extensions
    tstarttls-use-gnutls t)Note that your gnutls program may be in a different spot.
    Find it with:To compose an email C-x mEnter an email and hit C-c c to send it.If
    it works, great! If not switch to the *Messages* buffer for hints on what may
    have gone wrong.(message-mail recipient subject)(message-send-and-exit)))))'
  key: 2013/02/06/configuring-emacs-to-send-icloud-mail.html
- document: select `table_schema`, `table_name`, `create_time` FROM information_schema.tables
    where engine = 'InnoDB' order by create_time desc ; I was doing some DB work today
    and wanted to be able to sort all DB tables based on the date they were created.
    Turns out you can do some neat stuff by looking in the information_schema.tables.
    For example this shows all the InnoDB tables.
  key: 2014/03/12/checkout-out-your-db-tables.html
- document: watch -n 3 df -h So this is pretty cool.The watch command (available linux
    and on Mac via brew) will run a program every n seconds and display the results
    in a terminal.For example, the following common will show the display above with
    human readable disk free space on your system. But since the command can be anything
    you want this is a pretty powerful tool.
  key: 2014/04/01/watch.html
- document: $ [sudo] gem install terminal-notifier brew install terminal-notifier
    terminal-notifier -message "hello" Troubleshooting Check if terminal notify is
    installed correctly by running at terminal If that succeeds and you don't get
    a message check if you have enabled do not disturb mode Otherwise if that succeeds
    and yet emacs isn't sending messages you likely don't have the executable on the
    path. M-x customize-variable exec-path Sending notifications from emacs is something
    I find useful. In an earlier blog post I talked about how to use Growl to do so.
    http://justinsboringpage.blogspot.com/2009/09/making-emacs-growl.html Well now
    you don't need Growl any longer. There's a neat github project called terminal
    notifier https://github.com/alloy/terminal-notifier which let's you send notifications
    from the terminal.You can install it simply, via Homebrew or Rubygems as follows:ORThen
    you can send notifications using a command like this:Finally in order to send
    the notification from emacs we need to write a little Emacs lisp.Check out this
    gist for the code I use:This lets you send a notification in the future using
    M-x timed-notificationYou are prompted for a time, and the format of that time
    can be given in a human readable way such as "2 seconds" or "5 minutes" (If you're
    curious for the allowed options look at the info page in emacs for the function
    timer-duration )Then you are prompted for the message "Go to the store", and the
    message will be sent.The code is very simple, it simply uses run-at-time to run
    the terminal command in the future. A useful command is find-executable, which
    given a name will find that executable in your path and run it. This makes configuring
    tools like this less effort.Hey if it doesn't work first time what can you do?
  key: 2014/05/26/sending-notifications-from-emacs.html
- document: ' I found myself typing find . -name "*.java" | xargs -iHn "something"
    so often I decided to make it into a bash script and put it in a new ~/Dropbox/bin
    folder so that I never have to do it again. Worse I never use the print0 option
    which let''s you search files that have spaces in the filename, as it''s too hard
    to remember. So, here''s the script. '
  key: 2014/06/29/easy-find.html
- document: 'There are a couple of interesting things to say about folding lazy lists.
    Firstly let''s look at stack safety. As we saw earlier the amount of memory used
    by a lazy list can be higher than with a regular list since with fusion between
    operations we can end up with a stack of function objects before it is evaluated.
    For that reason and just in general we may want to operate on large lists, it''s
    important to consider which operations are stack safe and which are not. For a
    stack safe function I present foldLeft . @tailrec final def foldLeft [ B ](z :
    B )(f : ( B , A ) => B ) : B = if isEmpty then z else tail.foldLeft(f(z, head))(f)
    This is a so-called aggregate function that takes a collection, in this case,
    iterates over it and produces some aggregate value. The supplied function from
    the user is applied to each element along with some accumulating value. In the
    case of this implementation, the foldLeft recursive call is in tail position which
    means we can assume it uses tail call optimization. We add the annotation to tell
    the compiler we think so, and it will both complain if it is not eligible. def
    incN (n : Int , inc : Int ) : LazyList [ Int ] = LazyList .cons(n, incN(n + inc,
    inc)) println( incN( 1 , 1 ).take( 10000000 ).foldLeft( BigInt ( 0 )) { case (
    acc , a ) => acc + a } ) This function adds up 10m integers and as such takes
    up a lot of stack space and crashes. Except it doesn''t! Why? Because of the tail
    call optimization. Now it will, in fact, take a good few seconds on modern hardware,
    which is a long time, and it may in fact crash with out of memory or be pathologically
    slow. Why? Because we are creating a lot of garbage here, in the order of gigabytes,
    and that takes a lot of work to clear up. Make sure you have a decent amount of
    heap and use the G1 garbage collector via these settings (this is for running
    sbt, you can set the same JAVA OPTS for IDE''s and so on). SBT_OPTS = "-XX:+UseG1GC
    -Xmx4G" sbt So foldLeft is stack safe, how about foldRight? def foldRight [ B
    ](z : => B )(f : ( A , => B ) => B ) : B = if isEmpty then z else f(head, tail.foldRight(z)(f))
    Note that the problem here is that the recursive call is not a tail call position,
    in this case, the user function f is. That means we can''t use the tailrec annotation
    and it will not be tail call optimized. Can we infer from this situation that
    foldRight is useless? No actually. It has a property that foldLeft does not, that
    of being able to terminate early . Just like with fusion of operations, the early
    termination of foldRight can be used to save us work, and make code more efficient.
    How does that work? The "trick" here is that the second argument of the user function,
    the accumulator, is a call by-name value. It''s lazy! That means we don''t have
    to evaluate it. This example code uses foldRight to find "tuna" in a list of fish.
    def hasTuna (ll : LazyList [ String ]) : Boolean = ll.foldRight( false ){ (next,
    z) => println(next) if next == "tuna" then true else z } hasTuna( LazyList ( "salmon"
    , "shark" , "tuna" , "moray" , "goldfish" , "eel" )) // prints: // salmon // shark
    // tuna This is simply not possible with foldLeft, nor is it possible if you don''t
    use a call by-name argument for the accumulator in foldRight. If you''re not sure
    why it is not possible for foldLeft, try putting some println statements into
    things that you foldLeft and foldRight and see the order in which things are done.
    By the way, if you try this with the standard library you''ll find it does not
    work the same way. The signature of foldRight is as follows: def foldRight [ B
    ](z : B )(op : ( A , B ) => B ) : B Without even trying it we know that it must
    expand the whole collection, although feel free to try it if you need to prove
    it to yourself. There has been some discussion on this, for example. https://stackoverflow.com/questions/7830471/foldright-on-infinite-lazy-structure
    http://voidmainargs.blogspot.com/2011/08/folding-stream-with-scala.html As noted
    in the second example the following code will work with a lazy aware foldRight
    only.'
  key: 2022/11/05/magic-of-lazy-lists.html
- document: brew install postgresql svn checkout http://rpostgresql.googlecode.com/svn/trunk/
    rpostgresql-read-only cd rpostgresql-read-only R CMD INSTALL --preclean RPostgreSQL
    I went through a painful period of digesting wrong answers to this question on
    Google. In fact most of the answers are just of the type "this is somebody else's
    problem so we can't help"Anyway this is the eventual sequence of steps I found
    to install this that works:then in R just type library('RPostgreSQL') and you're
    good to go
  key: 2015/04/17/installing-rpostgresql-for-r-on-max-os.html
- document: '\frac{1+sin(x)}{y} This is a test of following the guide here http://www.codecogs.com/latex/integration/htmlequations.php
    A sample equation using latex:'
  key: 2015/04/22/including-equations-in-blogger-post.html
- document: ' Picture by ro_buk on Flickr From a bash shell you can run a command
    in the background by adding an "&" to the end of the command, but how do you do
    the same thing in Windows?Using the START command lets you run a task in the background
    (maximised or minimised), or in the foreground.For example the following would
    run memcached in the background minimized.C:\>start /min D:\platform\memcached.exeMicrosoft''s
    documentation is below, but it seems the options have changed. /m does not work
    but /min does.'
  key: 2012/03/22/starting-program-to-run-in-background.html
- document: ' On linux machines I search files using find, egrep and xargs as follows:find
    . -name "*.cpp" | xargs -i egrep -iHn "some search string" {}this outputs any
    matches with the filename and number and also disables case dependency.On my Mac
    it doesn''t work. I tried reverting to egrep -r (to search recursively) instead,
    but that doesn''t work. It just fails silently too. I tried installing findutils
    with brew to see if that helped, as often gnu tools are more up to date in brew
    than in the Apple version, but that didn''t help.So after some fiddling I found
    that the syntax below works:find . -name "*.cpp" | xargs egrep -iHn "some search
    string"Only subtly different!Actually, hold up, this does not work for filenames
    that have spaces in them. :(Try this instead:find . -type f -print0 | xargs -0
    egrep -iHn "some search string"J.'
  key: 2012/04/29/find-grep-on-mac-os-x.html
- document: ' find . -name -printf "%p %AD %AH:%AM " This is basic stuff but I wanted
    to post it so I can find it when I search for it...How to find a file and print
    the name, path and date and time it was last accessed...Change filename to be
    the file you want, with optional wildcards. (Use -iname for case insensitive search).'
  key: 2008/05/27/using-find-and-printf.html
- document: ' (defun copy-char-above() "copy the character above point into the buffer"
    (interactive) (let (c) (save-excursion (previous-line) (setq c (char-after)))
    (insert (char-to-string c)))) (global-set-key [f6] ''copy-char-above) The BBC
    microcomputer had a button called COPY, which when you pressed it would copy the
    character on the line above the cursor. This was quite handy, and I recently was
    waiting for a large amount of code to link, and thought I''d have a go at implementing
    it.There''s not a lot to it in fact. This function just remembers the cursor position
    (using save-excursion) and then goes to the previous line, gets the character
    after the point, and finally after the save-excursion block I just insert the
    character.Here I just assign the function to a key...'
  key: 2008/05/01/copying-characters-from-line-above-in.html
- document: ' echo Batch file path is %~dp0 dir %~dp0 Here''s a nice blog post on
    this...But just for my own reference the cryptic looking character sequence resolves
    to the path to the batchfile you are running.So if you put the following in a
    batch file, no matter what directory you are in when you run it, it will print
    the directory the batch file is in, and do a directory listing.'
  key: 2008/05/13/batch-file-tip-dp0.html
- document: ' (defun is-century-year(year) (if (= (mod year 100) 0) t nil)) (defun
    is-leap-year(year) "leap year is century years divisible by 400, not other century
    years, otherwise anything evenly divisble by 4" (if (is-century-year year) (if
    (= 0 (mod year 400)) t nil) (if (= 0 (mod year 4)) t nil))) Here''s a bit of elisp
    code to find out...'
  key: 2008/02/29/is-it-leap-year.html
- document: ' svnsync init https://lispbuilder.googlecode.com/svn https://lispbuilder.svn.sourceforge.net/svnroot/lispbuilderProject
    svnsync --username YOURNAME --password YOURPASSWORD sync https://lispbuilder.googlecode.com/svn
    https://lispbuilder.svn.sourceforge.net/svnroot/lispbuilder Subversion has a tool
    called SVNSYNC to make it easy to sync from one repository to another. This is
    great when moving to a different web based server. In this example I''m copying
    a project I work on from Sourceforge to Google Code. Once done, the google code
    repository will be an exact mirror, including the complete change history.You
    also need to set the revision number of the repository to zero. Google code, predictably,
    makes this easy, by having a button on the source page to do it for you.You need
    to have your username and password for google code to do this. For the repository
    you''re copying you don''t. First you use the initial command to set things up
    for the copy, then use the sync command to do the actual copy. It does this one
    revision at a time and takes a while...'
  key: 2008/11/21/how-to-copy-svn-repository-from.html
- document: Grabbing info from web pages This is how you use wget to grab a web page
    to stdout ... wget -O - http://newsrss.bbc.co.uk/rss/newsonline_world_edition/front_page/rss.xml
    Where -O species the output file, and the - specifies use stdout instead of a
    filename.
  key: 2008/11/08/grabbing-info-from-web-pages.html
- document: ' (defun space-and-tabs-to-tab() (interactive) (while (re-search-forward
    "[\t ]+" nil t) (replace-match "\t" nil nil))) This function is for emacs; it
    searchs for any sequence composed of spaces and tabs and replaces it with a single
    tab'
  key: 2008/01/29/emacs-simple-search-and-replace.html
- document: Avoiding Ten Common Game AI Mistakes 1) Moonwalking into walls or objects
    Often this is a symptom of the interface between the AI and the game world being
    too complex, and therefore hard to debug. Sometimes it can simply mean that you
    have no path finding in the game at all, but we will ignore that for now. Look
    for differences in the way that the animation moves and the way it queries the
    collision system. For example, the AI may do a ray cast to see if there is an
    object in front of it, but the character control system may move a larger object
    such as a cylinder, which then collides with the world unexpectedly. Other problems
    may be that the general movement code does not handle the collision when it is
    detected resulting in continuous attempts to move when the physics and collision
    system will not allow it. Sometimes the movement code fails, switches to an idle
    state, which then immediately attempts to move again, see item 4 below. 2) Turning
    "the long way around" to face a target For some reason this bug often survives
    until late in a project; sometimes it even ships! It seems like a simple thing
    to calculate... should I turn left or right to face a target. Typically people
    start out getting the X and Z distance to the target and figuring out that as
    an angle using atan2. Then they take the X and Z components of the facing vector
    to get that angle via the same route. Finally you just take the difference between
    those angles. What usually happens is that if you're not careful when manipulating
    these angles there are mistakes made when converting between radians of degrees,
    or when figuring out whether to turn left or right, or when wrapping angles around
    at 360 degrees. Let's look at a solution that avoids having to convert and do
    arithmetic with angles, which is where most of the bugs I see come from. Firstly
    take a dot product of the vector to your target and the characters facing direction
    (just the X and Z components). This gives you the cosine of the angle between
    the two vectors. Take an acos of that to get the angle in radians. What's nice
    about that compared to the atan2 route is that it immediately gives you the angle
    you want, the angle between the facing direction and the target position. You
    don't have to do anything more to make sure it's the shortest way around. Then
    we want to know whether to turn left or right. Again looking only at the X and
    Z vectors, we can simply figure out whether the target is to our left or right.
    First we need to get the 2d cross product of our facing direction. If the facing
    vector is (x,y,z), a vector at right angles to this in 2d is just (-z, x). If
    you then take the dot product of this and the vector to the target, the sign of
    that is whether you should turn left or right! Simple. 3) All the enemies on screen
    doing the same idle animation in perfect synchronization This is a very common
    when a bunch of enemies get spawned at the same time, with the same behaviour
    and their animations end up perfectly synchronised. Also it happens when the AI's
    are all hit by some weapon at the same time. It looks lame, and there's a couple
    of ways to help this along with making a major impact on your engine. You can
    play animations at irregular speeds. Play the idle animations at variances of
    just a few percent, and they won't look wrong, and they will be out of sync with
    each other. Use sets of random animations as often as you can, especially looping
    ones. At a higher level you can also make sets of states behave differently. If
    you have a state machine which has random elements for choosing the next state,
    then use that to vary the AI's. 4) Enemy behaving unpredictably However you set
    up your AI system it will always end up complicated. At it's worst AI code is
    a mass of "if X then do Y" type statements, and unless you manage it correctly
    you won't be able to understand what is going on. Firstly you need to abstract
    the state actions and state decisions as much as you can. Seperate concepts such
    as "doing an action" from "perceiving the world" and "deciding to do something".
    As much as you can allow the AI to be set up in the game data, not in the game
    code. Doing so also makes concurrency easier, since if you encapsulate all of
    your queries about the world, you can execute them in parallel with other game
    systems, then in a later stage of execution you get the deferred results of those
    queries and act on them. But the ultimate solution to unpredictability is debugging
    tools. You want to be able to store the last few states the AI was in, what transitions
    got him into that state, and what states it is considering transitioning to. If
    you can show this stuff on screen, at will, while the game is running, then you're
    golden. Spend lots of time on this kind of stuff, because I guarantee there will
    be a time near the end project when someone will come and stand behind you and
    ask you why something on the screen is doing X instead of Y. If you have no idea,
    then you're not doing job as an AI programmer. 5) Enemy is vibrating, flipping
    rapidly between two animations This happens often in state machines. If you get
    a state A which transitions to state B, and then on the next update, state B transitions
    back to A again. Assuming, as often people do, the AI states also trigger animations,
    then you have the horrible flickering between the two first frames of each. Ulimately
    the AI designers can avoid state cycles by not making them, but there are bound
    to be some that slip through. At which point it, it would be nice to have some
    mechanism to avoid them. You could flag an error or warning when a state immediately
    returns to the previous state, or you could have a time within which you cannot
    return to the previous state. One nice way to handle this is to make the data
    about how long you should stay in a state explicit. For example, if an enemy is
    rolling along the floor then it makes sense that you cannot interrupt that action
    once it starts, so we have the concept of an interrupt time, before which you
    cannot break to a different state. Tying states to animations achieves this too,
    but I don't recommend a one-to-one match of animations to state for reasons that
    I will cover later. Having interrupt times that are at least 1/2 a second is a
    simple way to avoid state thrashing, but you still have to solve the problem at
    the design level. 6) Irratic running on the spot and sudden direction changes.
    Have you ever seen AI's running to a point in the world, then when they get there
    they overshoot? Or maybe they just keep stopping and running again. Or maybe they
    spin on the spot. The problem here is nearly always to do with managing movement
    and distances to points. There are many ways to get this wrong. For example, if
    you use a bone or root node on a model as the absolute position of the character,
    then his distance from a point may vary over time as he animates. Meaning that
    you keep moving too far from the target point, triggering a new movement state.
    Another issue is how close do you have to be to the point to stop trying to move
    there? If it is 1cm then how accurate is your character movement system? can you
    move someone with an accuracy of 1cm? If not then you need to enlarge your arrival
    distance until it is large enough that you can guarantee accurate arrival. If
    you couple movement to animation you need to spend a lot of time thinking about
    where the character is, and a good way is to use a root node that is carefully
    animated to be well behaved. Then I recommend that you store the displacement
    of animations, so that you know exactly how far they will move the root node when
    played. For ultra slick AI's that walk or run to a point then do a smooth stop
    animation and end up exactly on the target, you just need to play your walk animation
    until you get to the point when the transition to stop animation would get you
    exactly to the target. The you need to play that animation at the right point.
    You also need to consider where the foot steps are. You can then determine whether
    to transition to a left or right footed stop. Finally, it's nice if you can manipulate
    your animations so that you can vary the distance covered by your walk cycle,
    just enough so that the transition to stop can be executed at a perfect boundary.
    If animation is just something you play in the background and doesn't affect your
    movement, then things are easier. It comes down to fixing the issues above as
    best you can, but you don't have to fix them, you will just get sliding and popping
    now and then. But you won't get the kind of animation driven movement problems
    that cause you to overshoot. One final issue is turning. Make sure your characters
    have a turn speed, that varies with running speed. You can turn on the spot when
    you're stationary, for example. When running your turning circle is limited. 7)
    Enemy doing nothing at all This is pretty much a design level issue, but it's
    common enough to mention. Sometimes AI's are just dead. They have no idea what
    to do next and this looks pretty stupid. Usually this occurs when AI have no valid
    transition from an idle state. So have your designers think about things the AI
    should do if everything they typically think he should be able to do cannot be
    done. One possiblity is that the path finder is failing. Perhaps the AI spawned
    in an unreachable area by mistake, or was pushed there, or fell there. If your
    AI's can get into a situation where they cannot move, then perhaps have them animate
    now and then so they look puzzled, or are looking around wondering what to do.
    Look though transitions from idle and make sure that there is something interested
    there that can be transitioned to if everything else fails. This also comes down
    to good AI system debugging tools. If you can immediately bring up a display showing
    which transitions the dead entity is considering, you will be able to figure out
    what to do. 8) Movement deadlocks (doors, bridges) Choke points happen in AI.
    Narrow corridors, doors, bridges, tunnels. Sometimes we are even clever enough
    to come up with a system for handling them. AI's that want to enter the choke
    point take a queue number, and they go through one by one for example. Whether
    you do something like that, or do nothing at all, there needs to be some way to
    avoid deadlock. One way to do that is by giving your AI's different priorities
    for movement, so that they can move AI's out of the way. Often a player is able
    to move AI's about, sometimes simply because he moves first. If you have a physics
    based engine for character movement this is easy, just set the mass to be greater
    on characters that you want to have the highest priority. Otherwise you'll probably
    have some kind of collision resolution system, and you need to feed in the priority
    from the AI into that. 9) Using A* for everything I run a web site which teaches
    A*, and yet when I come to write a pathfinding or other search program I don't
    always use A*, and when I do I never do A* on a fine mesh or grid. Why? Because
    it uses a lot of memory and processing power that is totally unneccesary. Firstly
    if you're searching only small data sets, like an AI state graph, or a dozen or
    so path nodes in a room, you can use Dijkstra's algorithm, which is particularly
    effective when all the AI's in the room will path find to the same node, since
    the algorithm will fill out data for the whole network rather than just the start
    and end nodes. Sometimes even a breadthfirst search is enough. In general you
    want the path finding data to be as high level as possible whilst still allowing
    movement to all possible gameplay areas. One approach is hierarchical path finding,
    which really needs to work at engine level. If you divide your game world up into
    regions, buildings, floors and rooms, for example, an AI can path find at all
    those levels before finally pathfinding on a grid or mesh level inside the current
    room it is in. 10) Being too clever Good AI is often based on quite simple systems.
    It almost always is built up using good tools and good design, rather than clever
    algorithms. Things to watch out for are learning algorithms, unless they are directly
    related to gameplay, which tend to make it hard to get the behaviour you want.
    I don't want to sound like I'm stifling innovation, but don't use a back propagating
    neural network when a simple table would do the job. At all times make the systems
    workings clear via debugging tools, and as best you can allow rapid iteration
    of AI changes, ideally allow real time changes while the game is running.
  key: 2007/10/09/avoiding-ten-common-game-ai-mistakes.html
- document: I came across a great page for C and C++ function pointers. It includes
    the syntax for how you do most things you would ever do with them. An ideal reference
    because I can never remember the syntax...
  key: 2007/10/24/c-and-c-function-pointers.html
- document: Ubuntu 7.10 With a new version of Ubuntu out (7.10) I decided to repeat
    the painful experience I put myself through every couple of years to see if I
    want to use it as a windows replacement on the desktop. I've been pleasantly surprised
    this time. The install process was a bit of a monumental fuck up, but it turned
    out that my PC has been overheating for a while due to a dirty fan. Windows didn't
    seem to care. Linux kept shutting down, and I eventually found the system log
    that told me why it was shutting down, and the exact temperature that caused it.
    Nice. At least when linux fails it is usually able to tell you exactly whats going
    on. Installing the Nvidia drivers turned out to be a pain in the ass too. The
    simple procedure they give you to do it from the desktop just didn't work. I then
    tried Nvidia's simple shell script, which didn't work. And a day or so later I
    found something called Envy, which did work. Overall I had to be familiar with
    linux commands, logging in as root, and editing configuration scripts to get it
    to do what I needed. It's still a computer experts OS as far as I can tell. Although
    you can pay for phone support, I don't think they're anywhere near capturing the
    typical Best Buy PC owner. So far I can do nearly everything I need to in XP,
    but the user interface is both flashier, faster, and has the benefit of being
    linux. It's still likely I won't be able to fully ditch XP though. I can't chat
    with my webcam yet. The webcam works but the chat software doesn't support it.
    I don't like the fonts, but I'm hoping I can configure that, I haven't spent time
    twiddling with it yet. Ubuntu is definitely getting there.
  key: 2007/10/24/ubuntu-710.html
- document: 'Recently I read the blog post "11 Visual Studio 2005 IDE Tips and Tricks
    to Make You a More Productive Developer" which has some neat tips indeed. I thought
    I would investigate which of the tips can be replicated in emacs, which are easier
    or more powerful in emacs and vice versa.I''ve been using Visual Studio for over
    10 years though I''m certainly not a power user, and recently I only use it for
    building and occasional code editing. I do more editing in emacs. I''m not writing
    this post to prove that one is better than the other, it is more for the learning
    experience for myself, and hopefully somebody will find something interesting
    here.(1) Express Yourself with Regular ExpressionsThe example is to convert, last_name,
    ssn, employee_idinto+ "last_name"+ "ssn"+ "employee_id"using a regex. Well, I''d
    probably record a keyboard macro to do that, but let''s do the regex replace instead.The
    syntax of the regex is a little different in emacs, but the basic sequence looks
    like this:Alt-x replace-regexp\(, \)\(.*$\), "\2"Notice you need slashes for the
    brackets to make the groups.Verdict: Visual Studio lets you use Regex''s in script,
    and emacs lets you do it in elisp code... and they both have the functionality
    needed for the tip. Draw.(2) Take (Keyboard) ShortcutsThis tip is to simply use
    keyboard shortcuts. Well in fact you won''t get anywhere with emacs without using
    them. So this is kind of a mute point.But I''ll list some random keyboard short
    cuts for completeness...Alt z runs zap-to-char, kills everything up until the
    character you enter.Alt . runs find-tag. Finds the next occurence of current tag
    in the tags table, for finding function and variable declarations for example.Ctrl
    U Alt . finds previous tagCtrl < goes to the start of a bufferCtrl > goes to the
    endCtrl H m describes the current mode, which is handy if you just downloaded
    a new editing mode and you want to see what the keys are and so onAlt t runs transpose.
    You can flip two words around.Verdict: Another draw.(3) Make New ShortcutsThis
    is straight forward in emacs...(global-set-key [M-f2] ''zap-to-char)... sets Alt-F2
    to do zap-to-charYou can override keys globally like that, or you can do local-set-key
    to change that key only for the current editing mode.Verdict: emacs and Visual
    Studio both allow remapping anything they can do to a key, and they both allow
    you to redefine a key differently for different modes. Another draw!(4) Use Code
    SnippetsI wasn''t aware of this feature for Visual Studio so I checked it out
    briefly. So it lets you dump out text, such as automatically creating empty for
    loops or adding set and get fields given a field name.Well in emacs there are
    abbreviations. So for example let''s say I want for( to automatically expand to
    for(int i; i??; i++)then I can make an abreviation, by going into the mode I want
    this to be active, and typingAlt-x abbrev-mode (turn the mode on)Alt-X define-mode-abbrev
    (interactively add a new abbreviation for this mode)forfor(int i; i??; i++)and
    now when I type for and space, it will expand automatically.If you don''t want
    it to expand then you type Ctrl-Q before you complete the abbreviation.But snippets
    let you do more advanced stuff like take a field name and create the get, set
    fields. Well I would write elisp code for that kind of thing, or again use a keyboard
    macro.Abbreviations are nice and easy to use, but they don''t have the power of
    snippets.Verdict: Visual Studio code snippets don''t seem to map directly to emacs.
    In emacs you can use the more basic abbreviations, or roll your own solution for
    wrapping text in more dynamic ways.(5) State Your PreferencesNot a lot to say
    here. emacs is fully configurable through the startup file .emacs, so you can
    do configure everything as you want it to be.Verdict: Draw.(6) "Attach to Process"
    to Start Debugging ASP.NETEmacs doesn''t support windows debugging, of course,
    but you can use gdb to debug processes. So the same functionality would be :Alt-x
    gdbattach [process ID]Verdict: Draw.7) Stop Conditionally (Conditional Breakpoints)Again,
    this is a windows only thing... you can run gdb and typebreak [LOCATION]andcondition
    [COND]to set up a conditional breakpoint.Verdict: Draw. You can''t debug windows
    processes from emacs, and you can''t debug linux processes from Windows, but both
    offer debugging from within the IDE.(8) Employ Task List TokensThis is an odd
    feature. By typing // TODO in C++ code, for example, you can view the TODO''s
    in a task list window for that file.Emacs lets you do this with say the ''occur''
    function.Alt-X occurTODOWill give a list of lines containing TODO.You could make
    an elisp function to wrap this up into a task list function:(defun task-list()(interactive)(occur
    "TODO"))Verdict: Not much of a feature really, but yeah, another draw.(9) Go Directly
    to Any File with the Find Combo BoxI couldn''t get this tip to work, but Alt-Shift
    O seems to be the one he is talking about. A very nice list of files, and you
    can quickly open a file by typing part of the filename.emacs doesn''t include
    the files in your current project, so we don''t have a direct comparison, but
    let''s assume you have a root directory containing your source and you want to
    find files matching a regex:Alt-x find-diredd:\YourSourceFiles\-regex ".*SEARCHTEXT.*"This
    will open a dired window (like a file manager dialog box but lets you do lots
    more things to the files) containing the matching files.Verdict: emacs is a bit
    better than studio in that you can search using all the power of the unix find
    command, but it''s more fiddly to use, and there''s no equivalent to Studio managing
    all the files in each project. (That I know of).(10) Type Ahead (Incremental Search)
    in ListsSo for example in Studio, do Ctrl-O and you get a file dialog. Typing
    letters gradually filters the available files until you get the one you want.Emacs
    has exactly the same thing.Ctrl-X Ctrl-F to visit a file for example (although
    this works with anything that asks you for a file.)Firstly you can use the buffer
    history to find files you opened and closed earlier, and also you can edit this,
    so if you just opened a .cpp file, you can change it to .h and load that easily.Secondly
    hitting tab will cycle through possible files based on what you typed so far,
    but also open a buffer with the current valid files, so you can switch and select
    from there.Finally, if you open the wrong file by mistake you can run ''find-alternate-file''
    and load a different file into the buffer you opened.Verdict: emacs wins by a
    nose. More flexibility.(11) Automate with Macros and Visual Studio Automationemacs
    also has very cool macro recording...Ctrl-X ( starts recordingdo your thingCtrl-X
    ) ends recordingCtrl-X e runs the macroIf you make a useful macro that runs on
    one line, you can then run it multiple times:Ctrl-U 10 Ctrl-X eruns the macro
    10 times for example.You can also edit the macro with edit-last-kbd-macro, which
    brings up an editor.Well that''s it, I''m sure I''ve missed out a lot of emacs
    features, I''ve been using it for about 4 years and I know there is still a lot
    of stuff in there I haven''t discovered!'
  key: 2007/09/27/11-visual-studio-tricks-in-emacs.html
- document: ' void getNameRawString(char *string); automatically becomes ... void
    SomeClassName::getNameRawString(char *string); (defun find-function-start-probably()
    (interactive) (re-search-forward " [*&_a-zA-Z]+(") (re-search-backward " ") (forward-char)
    (if (or (char-equal (char-after) ?*) (char-equal (char-after) ?&)) (forward-char)))
    (defun classname-add(classname) (interactive "sEnter class name: ") (find-function-start-probably)
    (insert classname) (insert "::") (beginning-of-line) (forward-line)) I use this
    elisp code to add a C++ class name to a line such as:This is useful as you can
    copy a bunch of class method definitions from a header file you''ve just created
    and then run this on each line to add the class names.First I wrote a utility
    function that finds the function name, which is presumed to be letters and underscores,
    following space and ended with a bracket. The function name includes the word
    probably because it might not work depending on your formatting, but you can twiddle
    the regex to get what you want.So as you can see this finds the match for the
    regex, which will place the point at the end of the search. Then I search backwards
    for a space which puts the point where we want to insert the class name and double
    colons...Finally the function below calls find-function-start-probably. It prompts
    for the class name, finds the function and inserts the text. The program automatically
    aborts if there is no match. You can override that behavior by passing arguments
    to re-search-forward.Improvements on the way:Multi-line version: do this over
    multiple linesImprovements unlikely but would be nice:Parse the header file more
    intelligently and create all the class function definitions with empty function
    bodies in a specified buffer'
  key: 2007/09/11/adding-c-class-names-to-function-name.html
- document: 'c:\code\haskell\cats\monkeys Needs to be converted to: /cygdrive/c/code/haskell/cats/monkeys
    (defun win32-to-cygwin-path() "Converts a win32 path into a cygwin happy one"
    (interactive) (save-excursion (save-restriction (narrow-to-region (point) (mark))
    (goto-char (point-min)) (insert "/cygdrive/") (goto-char (point-min)) (while (search-forward
    ":" nil t) (replace-match "" nil t)) (while (search-forward "\\" nil t) (replace-match
    "/" nil t))))) I use emacs within Cygwin, and often I want to paste a pathname
    from an explorer window into emacs and use it there. Unfortunately you have to
    edit it by hand before it will work.So for example a path like:The following interactive
    elisp function does that with the currently selected text:Nothing much clever
    going on here, just two search and replaces for the slashes and to removed the
    colon, and I insert the cygdrive prefix.'
  key: 2007/09/07/fixing-up-windows-pathnames-to-use-in.html
- document: ' c++-comment-line c++-comment (defun c++-comment-region() "Comment a
    region out" (interactive) (save-excursion (save-restriction (narrow-to-region
    (point) (mark)) (goto-char (point-min)) (while (> (point-max) (point)) (c++-comment-line)
    (forward-line))))) (defun c++-comment-line() "Comment a line of C++ out" (beginning-of-line)
    (insert "//")) Here are couple more simple functions, used for commenting out
    a block of C++ code.below simple inserts "//" at the start of a lineregion will
    take the current region and run the c++comment-line on each line.'
  key: 2007/09/12/commenting-out-block-of-c-in-emacs.html
- document: ' #| Word Numbers This is a partial solution to the problem found at http://www.itasoftware.com/careers/puzzles07.html
    by Justin Heyes-Jones I say partial because it does actually work, and if you
    had a lisp environment with enough memory, it would finish in about a day. But
    the real solution seems to be either to spot patterns so you don''t have to generate
    and sort all 1 billion numbers, or to use the file system to cope with what your
    computer memory cannot. "If the integers from 1 to 999,999,999 are written as
    words, sorted alphabetically, and concatenated, what is the 51 billionth letter?"
    To be precise: if the integers from 1 to 999,999,999 are expressed in words (omitting
    spaces, ''and'', and punctuation[1]), and sorted alphabetically so that the first
    six integers are * eight * eighteen * eighteenmillion * eighteenmillioneight *
    eighteenmillioneighteen * eighteenmillioneighteenthousand and the last is * twothousandtwohundredtwo
    then reading top to bottom, left to right, the 28th letter completes the spelling
    of the integer "eighteenmillion". The 51 billionth letter also completes the spelling
    of an integer. Which one, and what is the sum of all the integers to that point?
    [1] For example, 911,610,034 is written "ninehundredelevenmillionsixhundredtenthousandthirtyfour";
    500,000,000 is written "fivehundredmillion"; 1,709 is written "onethousandsevenhundrednine".
    |# ; (load (compile-file "wordnumbers.lisp")) ; (solve 999999999 51000000000)
    ; unlikely to finish unless you have a massive memory heap ; (solve 10 26) ; will
    work, but may not get you the job ;-) ;;;; Utilities (defmacro with-string-words((str
    word) &body body) "Utility macro to iterate over a string and return each word
    (anything between spaces)" `(do* ((start 0 (if end (1+ end) nil)) (end (position
    #\Space ,str :start 0) (if end (position #\Space ,str :start (1+ end)) nil)) (,word
    (subseq ,str start end) (if start (subseq ,str start end) nil))) ((null start))
    ,@body)) ;;;; Numbers are stores as the number in words, the length of this string
    and finally the numeric value (defun get-words(lst) (first lst)) (defun get-length(lst)
    (second lst)) (defun get-value(lst) (third lst)) (defun remove-and(str) "remove
    occurences of ''and'' from a string" (let ((new-str (make-array 0 :element-type
    ''character :fill-pointer 0 :adjustable t))) (with-string-words (str word) (if
    (string/= "and" word) (and (setf new-str (concatenate ''string new-str word))
    (setf new-str (concatenate ''string new-str " "))))) new-str)) (defun char-space-or-hyphen-p(c)
    (if (or (char= #\Space c) (char= #\- c)) t nil)) (defun remove-spaces-and-hyphens(str)
    "remove spaces and hyphens from a string" (remove-if #''char-space-or-hyphen-p
    str)) (defun get-number-as-words(n) "Use common lisps built in English text number
    output" (format nil "~r" n)) (defun get-numbers-as-word-list(n) "get the numbers
    from 1 to n and return as a list of strings and the lengths" "of each string as
    a list of three items, words, length of word string and" "actual numeric value"
    (loop for n from 1 to n collect (let* ((str (get-number-as-words n)) (len (length
    str))) (list (convert-text str) len n)))) (defun compare-word-and-len(a b) "given
    a string, length pair compare on alphabetical order" (string< (get-words a) (get-words
    b))) (defun sort-number-word-list-alphabetically(lst) (sort lst #''compare-word-and-len))
    (defun convert-text(str) (remove-spaces-and-hyphens (remove-and str))) (defun
    get-number-from-letter-index(lst target-index) (do ((number 0 (1+ number)) (index
    0 (+ index (get-length (nth number lst))))) ((> number (1- (length lst)))) (if
    (<= target-index (+ index (get-length (nth number lst)))) (return-from get-number-from-letter-index
    number))) nil) (defun sum-to-n(lst n) (if (>= n 0) (+ (get-value (car lst)) (sum-to-n
    (cdr lst) (1- n))) 0)) (defun solve(num n) "Solve the problem for ''num'' numbers,
    finding character position n" (let ((lst (sort-number-word-list-alphabetically
    (get-numbers-as-word-list num)))) (format t "Made list~%") (let ((number (get-number-from-letter-index
    lst n))) (format t "Found number~%") (let ((value (get-value (nth number lst))))
    (format t "Done.~%Number at character pos ~a is ~a. Sum to that number is ~a~%"
    n value (sum-to-n lst number)))))) Reading Reddit last week I came across an interesting
    programming puzzle.I''ve written a straightforward Common Lisp solution which
    is pasted below. What is interesting about this problem, and what would make it
    a good interview question, is that coding up the basic solution as I have here
    only poses more problems.None of the Lisp environments I''ve tried have enough
    heap space to complete this problem, even though in terms of time complexity it
    is O(n). Judging by how long it takes to run on a few hundred thousand numbers,
    and then several million, it would take about 20 hours on my 2Ghz PC to solve
    for 1 billion numbers.Even if I used the file system to hold the numbers, assuming
    each number fits in 50 chars of text, 4 bytes for the value and a further 4 to
    hold the length of the string, that is still in the order of 50Gb. You would then
    need to sort that file a bit at a time in memory, using a merge sort, and finally
    do a linear run through the file until you get the 51,000,000,000nth number.Some
    clever folk have presented a more intelligent solution here...Here is my solution
    so far:'
  key: 2007/09/22/word-numbers-programming-puzzle.html
- document: ' // How to pass a variadic argument list to another function // Justin
    #include "iostream" #include "stdarg.h" using namespace std; void debugMessageHelper(char
    *buffer, const char* format, va_list arglist) { vsprintf(buffer, format, arglist);
    } void debugMessage(char *buffer, const char* format, ...) { va_list arg; va_start(arg,
    format); debugMessageHelper(buffer, format, arg); va_end(arg); } int main(int
    argc, char *argv[]) { char testBuffer[128]; debugMessage(testBuffer, "hello %s
    %u %-04.2f", "world", 21 33.122f); cout << "\''" << testBuffer << "\''" << endl;
    } I needed to do this today, and it took me a while to google it, so here is complete
    sample showing how it''s done:'
  key: 2007/12/07/c-passing-on-variadic-function.html
- document: 'emacs: how-many Discovered another emacs command yesterday: how-many
    Returns the count of a regex following the point (cursor position). For example
    M-x how-many \b\w returns a word count from point to the end of the buffer. Nice.'
  key: 2007/12/08/emacs-how-many.html
- document: Action Pants Inc (always recruiting multiple positions) Blue Castle Games
    (14 jobs + 3 co-op jobs) I've copied this excellent list of Vancouver game companies
    from :Please not that the number of jobs for each one is constantly changing,
    and so will be only (roughly) correct at the time I posted this.
  key: 2009/03/18/vancouver-game-companies.html
- document: find . -regex ".*\(h$\|cpp$\)" > files.txt Next pass this to etags to
    generate the tags table. etags.exe - < files.txt Then when you're in emacs you
    need to visit the tags table, which will have been saved as TAGS. M-x visit-tags-table
    then browse to the folder where you made the TAGS file. Now when you have the
    curser on some function you can type... M-. to go to a tag and C-u M-. to go to
    the next tag. Once you're done, you can return to where you started with M-* Another
    useful function is tags-apropos Which will list all the tags matching a regex
    in a buffer. This requires you install the Gunwin32 tools or Cygwin, and describes
    how to build a tags table for the project you're working on, when using emacs
    to edit the source.First you want to generate a file containing all the source
    files you want to have tagged. Go to the root folder of your project.
  key: 2009/03/09/using-tags-in-emacs-on-windows.html
- document: scp /cygdrive/c/Documents and Settings/myname/My Documents/interestingfile.txt
    usernameonmachine@1.2.3.3:/home/usernameonmachine/ Quick post about copying files
    between computers over a secure connection.Linux and Cygwin comes with scp, a
    secure version of cp.Usage... in this case I'm copying a file from my cygwin (putty)
    terminal to a remote machine.You should get a password prompt and see the transfer
    complete as follows.interestingfile.txt 100% 34KB 34.3KB/s 00:00
  key: 2009/04/02/securely-copying-files-to-another.html
- document: Chain Tool by Florian ;;; iterating over files in dired ;;; usage example
    - for-each-dired-marked-file returns a filename and path ;;; for each marked file,
    so this is what a function using it looks like (defun view-stuff(filename) "opens
    up the file and gets the length of it, then messages the result" (let (fpath fname
    mybuffer len) (setq fpath filename) (setq fname (file-name-nondirectory fpath))
    (setq mybuffer (find-file fpath)) (setq len (buffer-size)) (kill-buffer mybuffer)
    (message "Buffer length %d %s" len (buffer-file-name mybuffer)))) ; Usage example
    (defun test-for-each-dired-marked-file() (interactive) (for-each-dired-marked-file
    'view-stuff)) (defun for-each-dired-marked-file(fn) "Do stuff for each marked
    file, only works in dired window" (interactive) (if (eq major-mode 'dired-mode)
    (let ((filenames (dired-get-marked-files))) (mapcar fn filenames)) (error (format
    "Not a Dired buffer \(%s\)" major-mode)))) If you have some function, say some
    custom refactoring operation, you can call it from a dired buffer, and have it
    run on each marked file, using the code below.Go into a dired buffer, mark some
    files, and then do M-x and run your command. In this case it would be
  key: 2009/04/15/running-elisp-function-on-each-marked.html
- document: 'Linux: Looking at files changed recently This is really handy (on Linux
    and Cygwin) when you''re working on a project that may not be in source control
    and you want to see what you changed recently. I made this blog post, when it
    seems a trivial use of find, because I don''t think the man page covers it well.
    This command finds all files modified in the last 60 minutes: find . -type f -cmin
    -60'
  key: 2009/05/27/linux-looking-at-files-changed-recently.html
- document: 'Image by MarkyBon In a previous post I outlined how to use webjump, a
    built in feature of emacs to quickly launch web pages in a browser, after querying
    the user for search phrases and so on. This describes how to simply setup webjump
    to search the API documentation for whatever framework you are using. The example
    will be Java''s Platform documentation. Find the base url you want to search.
    We will use google to only find things that begin with this. In the case of Javas
    documentation I''m going to search at http://java.sun.com/javase/6/docs/api /
    Set up the web jump code as below. The three arguments in square brackets are
    [ base url, normal search url prefix, search url post fix ]. You just need to
    replace the JAVA API part of my URL with the URL you are interested in. M-x webjump
    Type your query and hit enter Browser opens with search results (require ''webjump)
    (global-set-key [f2] ''webjump) (setq webjump-sites (append ''( ("Java API" .
    [simple-query "www.google.com" "http://www.google.ca/search?hl=en&as_sitesearch=http://java.sun.com/javase/6/docs/api/&q="
    ""]) ) webjump-sample-sites)) '
  key: 2009/05/07/emacs-searching-programming-apis-with.html
- document: 'emacs: Renaming multiple files at once with a regular expression M-x
    dired (navigate to the folder) M-x wdired-change-to-wdired-mode M-x replace-regexp
    (enter search and replace expressions) C-c C-c Which writes out the changes to
    the directory.'
  key: 2009/05/08/emacs-renaming-multiple-files-at-once.html
- document: This is just a link to a great description of converting flac to mp3 files.
    There's a tonne of commercial and useless sites that try to answer this questionSo
    I thought I'd add another link to this one that actually works, and uses free
    software.
  key: 2009/05/12/converting-flac-to-mp3.html
- document: 'Linking MingW32 with psapi Here''s something I came across that didn''t
    have a good answer when I googled. If you get link errors with MingW32 like: undefined
    reference to `GetProcessMemoryInfo@12'' or c:/justinhj/mem.cpp:55: undefined reference
    to `EnumProcesses@12'' Then you are not linking with the library psapi, and you
    need it. To do this just add -lpsapi to your command line. It needs to be last
    in the list of libraries too!'
  key: 2009/05/14/linking-mingw32-with-psapi.html
- document: Often when programming in C++ (or many other languages) it's desirable
    to write a quick program, usually a console application, to test something quickly.
    Working in developer studio, it takes an amount of fiddling and clicking large
    enough that you may not want to bother.Working in emacs and MingW32 (or Microsoft's
    CL.exe) I can quickly create a CPP file, and then compile it. To compile a program
    though you need to either write a makefile, or build up a complex g++ command
    line.Rather than do either of those I make a helloworld.cpp file which can be
    built like this:g++ helloworld.cpp -g -o helloworld.exeSo I hitM-x compilethen
    type in the above to compile and link it.However there's a better way. You can
    add the compile command as the first line of the file as a file local variable.//
    -*- compile-command:"g++ helloworld.cpp -g -o helloworld.exe"; -*-Now I can hit
    the compile and it works right away, between sessions. No makefile or project
    settings in sight, and now there are minimal barriers involved in creating a simple
    test program beyond copy and pasting the file.
  key: 2009/05/14/writing-quick-c-programs-in-emacs.html
- document: Thanks to a commenter in my earlier blog post for pointing me to this
    way of sending mail that actually does work:You need to download msstp from sourceforge
    and install the exe in your path.There is one change I needed to make to get this
    working. In the config file:msmtprc.txtYou need to add a linefrom your.email@address.hereWithout
    that I was getting an error number and no email. If you run into a problem like
    that you can make sure MSSTP is running by trying it from the command line:msmtp
    -a yourname some@recipient.comType some mail and hit Ctrl-Z and it should send
    correctly.Once that is working you can enter gnus within emacs, and send a mail
    using:M-x message-mailFill out the fields and type C-c C-c and it should send
    correctly.A security issue with this is that it doesn't seem to work if you leave
    your password empty in the configuration file. From the command line it simply
    prompts you for your password and away you go, but from emacs it just hangs. So
    if you use this method you're taking the huge risk of having your password in
    a readable file on the hard drive. I'll be trying to find a way around that before
    using this permanently.
  key: 2009/02/20/sending-mail-with-emacs-in-windows.html
- document: A* algorithm bug fixes It's been a while since I checked the issues page
    on my A* algorithm google code project. So it turns out there's a possible memory
    leak and the Manhattan distance calculation in the findpath.cpp is wrong. I've
    investigated both of these and uploaded a fixed version. In the case of the memory
    leak, there is some code in my "fast simple allocator" which allocates some memory,
    assigns it to a temporary pointer, then converts it and stores it in a member
    variable. Apparently, this shows up in memory tracking software as a leak, even
    though the memory is released in the destructor, so I've changed the code so that
    the allocation and free is done with the same variable. The Manhattan distance
    refers to a simple heuristic for finding a path when you can only move horizontally
    and vertically through a grid. Like calculating how far you would have to walk
    in a city on a grid system, like NY, you simple count how many blocks along and
    how many blocks up you need to walk. Well I implemented this carelessly and forgot
    to make sure that I take the absolute value when calculating the difference between
    'streets'. That's done now. You can download the latest version of the A* algorithm
    here... http://code.google.com/p/a-star-algorithm-implementation/downloads/list
  key: 2009/02/16/algorithm-bug-fixes.html
- document: I often wonder who uses the A* code. Sometimes people write to me to tell
    me they've used the code in their University assignments or just for fun, but
    has anyone used this in a project that I don't know about?During my time at Activision
    I worked on a code base that included some code from their game Gun, and was happy
    to find my code, verbatim included there too!Also, today, I downloaded a 2d game
    prototyping engine called Angel, from some EA guys. When I looked at how their
    path finding worked, I was surprised to see my code in there too!It's cool that
    people are using this code. If you do use it in some commercial or interesting
    project, please let me know. A credit or thank you in your product would be nice
    too!
  key: 2009/02/16/who-uses-a-code.html
- document: ' (defun url-to-buffer(url) (interactive "sEnter site url : ") (let ((buffer
    (get-buffer-create "*url-to-buffer*"))) (shell-command (format "c:/coreutils/bin/wget.exe
    -q -O - %s" url) buffer))) (defun get-item(tag node) (let ((child-node (car (xml-get-children
    node tag)))) (car (xml-node-children child-node)))) (defun parse-rss(filename)
    (interactive "fRss file :") (let ((parsed-xml (xml-parse-file filename)) (buffer
    (get-buffer-create (format "%s-parsed.txt" filename)))) (goto-line 1 buffer) (erase-buffer)
    (let* ((rss (car parsed-xml)) (channel (xml-get-children rss ''channel)) (items
    (xml-get-children (car channel) ''item))) (dolist (item items) (let ((title (get-item
    ''title item)) (description (get-item ''description item)) (date (get-item ''pubDate
    item))) (insert (format "*%s* %s %s " title description date))))))) Today I''ve
    been playing around with emacs, and one of the things I''ve wanted to write is
    something to grab a web page, do some manipluations to it and dump that to a buffer.So
    what I''ve got going is two things that are not quite joined up yet. Firstly grabbing
    some URL and sticking it in a buffer...As you can see I''m using windows here,
    but as long as you have a path to wget this should work. I''m simply running wget
    and capturing the output to a buffer.So running that on BBC''s news RSS feed,
    I then saved it to a file called bbc.xml.Since this is an XML file I can parse
    it without any effort using xml.el. Here is some code that walks through the items
    in the RSS file and prints them out in human readable format (ie: not XML) into
    a buffer.There is some helpful info about xml.el herewhich was neccesary to figure
    to figure out the syntax to grab the text from a tag. I wrote helper function
    to go from a node to the text for that node, since the syntax is quite verbose:This
    lets you go from a tag name (eg title) and a node that you parsed from the xml
    file, to the item.xml-parse-file is our one shot call to parse the xml file, which
    returns a nested lisp structure representing the xml document. I grab the channel,
    then grab any items within the channel and print out three items that I''ve grabbed
    from them, the title, description and date.So each item output looks like this:*Obama
    defends economic stimulus*The US president defends his economic stimulus plan
    as "absolutely necessary", and urges Congress to approve it quickly.Sat, 07 Feb
    2009 22:23:20 GMTNote that if you want to read RSS feeds in emacs, look up the
    builtin function newsticker. All this information I''m writing about is really
    useful if you want to code up something custom though.'
  key: 2009/02/07/fun-with-rss.html
- document: ' ; install starttls from here (no need for patch) ; http://josefsson.org/emacs-smtp-starttls.html
    (setq send-mail-function ''smtpmail-send-it message-send-mail-function ''smtpmail-send-it
    smtpmail-starttls-credentials ''(("smtp.gmail.com" 587 nil nil)) smtpmail-auth-credentials
    (expand-file-name "~/.authinfo") smtpmail-default-smtp-server "smtp.gmail.com"
    smtpmail-smtp-server "smtp.gmail.com" smtpmail-smtp-service 587 smtpmail-debug-info
    t starttls-extra-arguments nil smtpmail-warn-about-unknown-extensions t starttls-use-gnutls
    nil) I got this working in linux, and it''s fairly easy. I''m still trying to
    get it working on my win32 machines, and I''ll post about that later if I get
    it working.This post has most of the details I needed:http://obfuscatedcode.wordpress.com/2007/04/26/configuring-emacs-for-gmails-smtp/So
    I put the following in my .emacsAnd followed the instructions to make the .authinfo
    file containing:machine smtp.gmail.com login [your name]@gmail.com password [your
    password]And finally download, unzip, make and install startttls:http://josefsson.org/emacs-smtp-starttls.htmlYou
    don''t need to apply the patch there, it works without as far as I can tell.Finally
    you can create and send mail.'
  key: 2009/02/07/sending-email-via-gmail-in-emacs.html
- document: ' (load "/YOURPATHTOSLIME/slime/swank-loader.lisp") (swank-loader:init)
    (swank::create-server :port 4005) I''ve always used this excellent pair of blog
    posts by Bill Clementson to get lispworks personal working with emacs/slime on
    windows.Having had the joy of a hard drive failure last week I had to reinstall
    everything, and I''ve found that with the latest CVS version of slime you need
    to change your ".slime.lisp" file to look like this:So if your slime/lispworks
    personal setup stops working when you upgrade slime, hopefully you found your
    way here.'
  key: 2009/02/13/setting-up-lispworks-personal.html
- document: ' (require ''webjump) (global-set-key [f2] ''webjump) (setq webjump-sites
    (append ''( ("Reddit Search" . [simple-query "www.reddit.com" "http://www.reddit.com/search?q="
    ""]) ("Google Image Search" . [simple-query "images.google.com" "images.google.com/images?hl=en&q="
    ""]) ("Flickr Search" . [simple-query "www.flickr.com" "flickr.com/search/?q="
    ""]) ) webjump-sample-sites)) ("astar algorithm" . "http://www.heyes-jones.com/astar")
    ("Reddit Search" . [simple-query "www.reddit.com" "http://www.reddit.com/search?q="
    ""]) I came across another brilliantly useful corner of emacs today. webjump by
    Neil Van Dyke is part of emacs and Xemacs, and gives you a way to assign memorable
    names to web site urls, and to build simple search queries. It then opens the
    website using emacs'' built in browse-url function.Set up is easy. All you need
    to add something like this to .emacs:The first line just makes sure the feature
    is loaded, and then I bind the webjump function to F2 in the second line.To use
    webjump, just press F2, and press TAB to expand the sample sites that are built
    in, and the ones we just added above. Type Flickr Search for example, and then
    you get a prompt for the search string. Once you enter that your browser should
    open with flickr showing the search.I''ve added Reddit, Flickr, and Google image
    search above, but it''s easy to add your own as follows:Each entry in the jump
    list takes the form (name . url|builtin), where the simplest shortcut is just
    a name, url pair like this:There are some builtin functions that you can use.
    For example simple-query lets you enter some text that will be inserted between
    two strings. The format is:When doing something more clever than an url you pass
    in a vector (hence the []''s), where the first argument is the function, the second
    is the default url (if the user doesn''t enter anything, and the third and forth
    arguments are the prefix and the postfix wrapped around the users input to make
    the search work. In this case the last argument is the empty string.You can provide
    your own functions to do something really fancy if you need to.'
  key: 2009/02/13/search-reddit-flickr-and-google-from.html
- document: 'In an earlier post I covered finding the writable files in a directory,
    which is something you often need to do when messing around with source control.
    For example, if there''s a writable file in your source folder that isn''t checked
    out, then you know you need to add it before checking in. In fact I have a tool
    that compares my changelist with the list of writable files, and lets me know
    if I''m about to break the build when I check in. Anyway I digress. Once you have
    found the writable files using: dir source_folder /a-r-d /s /b > files.txt then
    you may want to run some operation on them; for example make them read only. Here''s
    how to do that with the windows for command (see here for documentation) for /F
    %i in (files.txt) do attrib -R %i The for command with the /F option can iterate
    through a file full of filenames, which is what we generated with the first command,
    and run the operation after the do instruction. It''s actually quite powerful;
    you can specify comment markers, delimiters, and choose which of a number of columns
    you want to make into variables. '
  key: 2009/10/09/msdos-iterating-filenames-in-file.html
- document: ' Here''s a handy function which lets you choose a transparent level (0
    is fully transparent and 100 is opaque), for the main emacs frame in both focused
    and unfocused state. (defun transparent(alpha-level no-focus-alpha-level) "Let''s
    you make the window transparent" (interactive "nAlpha level (0-100): nNo focus
    alpha level (0-100): ") (set-frame-parameter (selected-frame) ''alpha (list alpha-level
    no-focus-alpha-level)) (add-to-list ''default-frame-alist `(alpha ,alpha-level)))
    To run M-x transparent. Enter the values you want for when the window has focus
    and when it does not. In the background you can see system status information
    on the desktop, which is another excellent utility from sysinternals called BgInfo.
    It let''s you display useful info about your system right on your desktop, similar
    to tools you may find on linux. '
  key: 2009/10/12/transparent-emacs-on-windows.html
- document: ' I''ve always wished emacs could notify me of it''s doings. For example
    the message function just pops up text in the minibuffer and is easy to miss,
    and impossible to see when the window is not in focus. So I was pleased when looking
    through the code to find out about todochiku, and emacs interface to Growl. Download
    and set it up. Send yourself a test growl at the command prompt like this: "C:/Progra~1/Growlf~1/growlnotify.exe"
    /T:"title" "message" Once that''s working you can send notifications from emacs.
    is an emacs package for sending notifications to growl, snarl or whatever you
    have. In our case we have growl. Unfortunately the windows default is to use snarl,
    and there''s no support for growl. I''ve made a few modifications to the original
    to get that working and uploaded the new file here. C-x e You will need (require
    ''cl) somewhere before this is loaded (.emacs perhaps) Customize the variables
    for the program using M-x customize-group todochiku You''ll need to set the `todochiku
    command'' to something like this: C:/Progra~1/Growlf~1/growlnotify.exe Use "Dir
    /x *" in a folder to find out what the 8 character name is. If you want icons
    that come with todochiku then download them from the todochiku wiki page and point
    to them with the variable `todochiku icons directory''. For example mine is set
    to: ~/localemacs/todochiku-icons Finally you can do a growl... try this (growl
    "Emacs" "Hello") There''s also `todochiku-message'' which let''s you specify an
    icon. This can be an image filename, and url, or an icon symbol from the built
    in list of icons you can find by the variable `todochiku-icons''. (todochiku-message
    "Emacs" "You''re growlingnow" ''social) (todochiku-message "Emacs" "You''re growlingnow"
    "http://www.growlforwindows.com/gfw/images/downloadlatest.gif") (todochiku-message
    "Emacs" "You''re growlingnow" "c:/cygwin/home/Justin/localemacs/todochiku-icons/binary.png")
    There''s a command `todochiku-in'' which will send you a notification from emacs
    in a set number of minutes. (todochiku-in "hello" 3) If you use twit.el you should
    find that todochiku automatically notifying you of tweets if you have called `show-recent-tweets''.
    It''s very simple to use todochiku and growl so you should find all kinds of applications
    for this. Have fun! something like this:Use "Dir /x *" in a folder to find out
    what the 8 character name is.If you want icons that come with todochiku then download
    them from the todochiku wiki page and point to them with the variable `todochiku
    icons directory''. For example mine is set to:Finally you can do a growl... try
    thisThere''s also `todochiku-message'' which let''s you specify an icon. This
    can be an image filename, and url, or an icon symbol from the built in list of
    icons you can find by the variable `todochiku-icons''.There''s a command `todochiku-in''
    which will send you a notification from emacs in a set number of minutes.If you
    use twit.el you should find that todochiku automatically notifying you of tweets
    if you have called `show-recent-tweets''.It''s very simple to use todochiku and
    growl so you should find all kinds of applications for this. Have fun! (Ideally
    I should make it so it searches both for windows and for growl or snarl being
    installed but for now the choice is made manually)Download the elisp file into
    a directory in your emacs load-path (or add it) and add the (require ''todochiku)
    command to your .emacs file. Reload emacs, or just hitafter the (require command
    in your .emacs)'
  key: 2009/09/10/making-emacs-growl.html
- document: Directional window movement in emacs One thing I sometimes miss about
    the text editor Brief, which I stopped using a decade ago, is being able to move
    between windows easily by pressing a function key and then an arrow key to switch
    to a window in that direction. In emacs I only knew how to move between windows
    using `other-window', mapped to C-x o and that only cycles around the windows,
    and if you have a few windows open and possibly you're also editing the mini-buffer,
    that's quite a round trip. I just learned about `M-x windmove-default-keybindings',
    which binds a set of commands that do exactly the kind of directional movement
    I'm talking about (`windmove-right', `windmove-up' and so on) to the cursor keys
    (with shift key held).
  key: 2009/09/08/directional-window-movement-in-emacs.html
- document: 'keep-lines flush-lines These handy functions prompt you for a regular
    expression and will either remove every line that does not contain that expression
    (keep) or remove the ones that do (flush ). finder-list-keywords This function
    shows all the keywords used in the packages within emacs. In other words you can
    find a lot of stuff in emacs that you never knew was there. '
  key: 2009/09/01/handful-of-emacs-tips.html
- document: ' title Poop ha ha Now that''s only really useful for making windows with
    rude words in their title bars right? Well actually, I''ve found a great use for
    it. If you have a bunch of command prompt windows open then you have no idea which
    one is which on the Windows taskbar, once they are stacked. So naming them is
    a really useful habit since once named you can see which window is which. Did
    you know you could change the title in the window of a command prompt using the
    title command? Example:'
  key: 2009/09/23/windows-command-window-title.html
- document: ' The code is hosted on google code as emacs-easy-budget and is also released
    as GPL v3. Hope somebody finds it useful. When I first moved from England to North
    America one of the things I found hard to get used to was getting paid every two
    weeks instead of monthly. This means that some of your bills are monthly, some
    are biweekly, and occasionally I had more or less money than I expected as they
    got out of sync.I''ve been using a simple elisp program I wrote to let you manage
    your upcoming bills, weekly budget items like groceries, and your regular income.
    It runs through a period of dates you supply, and a list of incomes and expenses,
    and produces a csv file and a buffer that contains the output of the forecast.
    It shows the highest and lowest balance of the period too, so you can spot if
    you will go over drawn, and also see peaks when it''s a good time to move money
    to savings.'
  key: 2009/08/26/simple-budget-forecasts-in-emacs.html
- document: ' (defun get-buffer-create-and-clear(name) (interactive "sName: ") (let
    ((buffer (get-buffer-create name))) (goto-line 1 buffer) (erase-buffer) buffer))
    (defun p4-blame() "blame the current line of code... it seeks out the change list
    of the last person to change this line. The arguments to annotate, which dumps
    the source file with the change list number it was last altered in, are q (no
    header) i (follow branches) and c for change numbers rather than revision numbers."
    (interactive) (let* ((line (line-number-at-pos)) (source-file (buffer-file-name))
    (annotate-buffer (get-buffer-create-and-clear "*p4-annotate*"))) (shell-command
    (format "p4.exe annotate -q -i -c %s" source-file) annotate-buffer) (goto-line
    line annotate-buffer) (let ((change-number (number-at-point))) (if change-number
    (let ((blame-buffer (get-buffer-create-and-clear "*p4-blame*"))) (shell-command
    (format "p4.exe describe %d" change-number) blame-buffer)) (message "error: could
    not get change list number for line %d" line))))) My team use Perforce for version
    control, and I recently wrote an implementation of ''blame'', also known as ''praise''.
    When editing a file that is in Perforce, I can run p4-blame, and it will figure
    out the last change list that this file, and the line that point is on, was changed.
    It then opens a buffer containing that change list. This is often useful while
    working, and is so fast when accessed from the editor, it makes it trivial to
    do.First, I wanted it to open two buffers, one with the annotated file (the file
    you''re working on with the change list number at the start of each line), and
    another with the changelist you''re interested in. When running the command multiple
    times I want these buffers to be deleted. So I added a helper function that creates
    a named buffer, and if it exists already, makes sure it is empty.Ok now for the
    blame code. As you can see, mostly what it''s doing is called the P4 command line
    and passing the output to buffers. Firstly I call annotate to get the change list
    numbered lines. Then I go to that file and go to the same line that point was
    at. (number-at-point) returns that number. Finally I call p4 describe to get the
    changelist information.The error detection is a bit sloppy here. I don''t know
    how to figure out if the shell-command failed. But it''s not a big deal because
    if you do this in a file that is not in P4 then it will simply print a message
    saying could not get change list.Ideally I could send the error output to a buffer,
    and then parse it to see if it''s empty.'
  key: 2009/01/08/who-changed-line-your-working-on-last.html
- document: ' (defun p4-checkout-buffer() "Check out the current buffer from perforce
    using a shell command line" (interactive) (shell-command (format "p4.exe edit
    %s" (buffer-file-name))) (toggle-read-only -1)) I know there are all kinds of
    clever perforce modes, but I prefer to have a few common perforce actions that
    I write myself and can easily extend and customise as needed.For example this
    is all you need to checkout a file you are visiting.'
  key: 2009/01/23/simple-perforce-checkout-in-emacs-using.html
- document: ' dir /a-r-d /s /b Simple thing, but if you want to find which files in
    a directory are writable, use this dos command .../a is to search for attributes.
    In this case r is read only and d is directory. The minus signs negate those attributes.
    So we''re looking for writable files only./s means recurse subdirectories/b means
    bare format. Path and filename only.'
  key: 2009/01/12/finding-writable-files-in-directory-in.html
- document: I noticed today that my StackOverflow reputation is 1337. What an incredibly
    geeky way to begin Wednesday!
  key: 2009/06/17/1337-on-stackoverflow.html
- document: "Previous related post: Hacker News API part 2 Github project related\
    \ to this post In part 2 of this series I presented an interative command line\
    \ app that used the Fetch library to pull data from an online data source (the\
    \ Hacker News API). In the related github repo I\u2019ve developed that project\
    \ in the following ways: Converted the code from a command line JVM app to a Scala.js\
    \ app that runs in the browser Created a custom cache so we can query its size\
    \ and clear it on demand Used Udash to create an interactive frontend to operate\
    \ the fetches Visualize each round of the data fetch using reftree You can check\
    \ out the project live here or watch a short video demonstration What is hnfetchhs\
    \ and how do you use it? The idea of this blog post and accompanying github repo\
    \ is to provide an interactive demo of the Fetch library. The Stories per page\
    \ input field lets you specify how many stories to fetch from the API, whilst\
    \ the Page input chooses the offset. In the background I use the top stories endpoint\
    \ to get the IDs of all the top stories. The number of top stories known is shown\
    \ in the title bar. At anytime you can reload the top story IDs using Refresh\
    \ Top Stories . Hitting the Fetch Page button will start a fetch job for the Ids\
    \ with the current Page . So if you are are on page 1 and you have 30 stories\
    \ per page you will get the top 30 stories as shown on Hacker News right now.\
    \ Once a fetch has been run you can view a diagram of the fetch operation in detail\
    \ using the Last Fetch tab. If you play around with different page numbers and\
    \ stories per page you can see the cache filling up, and you will see that repeated\
    \ fetches of stories will result in a Nil fetch with no data to show. You can\
    \ also clear the current cache using the Clear Cache . All these tools together\
    \ make it easy to experiment with the fetch data source and different kinds of\
    \ caches etc. The rest of the post explains some of the process involved in building\
    \ this app. What is Fetch? Fetch, an open source project by 47 Degs, is inspired\
    \ by the Haskell library Haxl developed at Facebook to simplify the concurrent\
    \ retrieval of data from multiple sources. You can read more about that There\
    \ is no Fork: an Abstraction for Efficient, Concurrent, and Concise Data Access\
    \ You can read more about Fetch at their documentation page https://47deg.github.io/fetch/docs.html\
    \ Converting code to scala.js This is the first time I\u2019ve ported code written\
    \ for the JVM to Scala.js so it was a learning experience but also the shortest\
    \ part of the project. I created a Udash frontend using the built in project generator\
    \ and started moving my code into the new project a piece at a time. It involved\
    \ doing the following: Change library import paths \"com.47deg\" %%% \"fetch\"\
    \ % \"0.6.3\", \"com.lihaoyi\" %%% \"upickle\" % \"0.4.4\", \"org.typelevel\"\
    \ %%% \"cats\" % \"0.9.0\" This part was easy since these libraries are all available\
    \ for scala.js. You just change the first @@ to @@@ and the scala.js library will\
    \ be imported instead. Java libraries In my original code I used the PrettyTime\
    \ library which is written in Java \"org.ocpsoft.prettytime\" % \"prettytime\"\
    \ % \"3.2.7.Final\" and is not available to Scala.js since all code must be either\
    \ compiled from Scala or Javascript. I found a similar library to PrettyTime called\
    \ moment.js which had the functionality I needed. In order to use a Javascript\
    \ library you must add it to the Assets folder and load it on your pages, and\
    \ you need a facade type to wrap the Javascript API. Fortunately there is one\
    \ already for the moment.js library, so by important that you can immediately\
    \ start using it as if it were a Scala library. \"ru.pavkin\" %%% \"scala-js-momentjs\"\
    \ % \"0.9.0\" Replace scalaj-http Since fetching HTTP pages in my original code\
    \ uses the ScalaJ HTTP library \"org.scalaj\" %% \"scalaj-http\" % \"2.3.0\" and\
    \ this is not available in a scala.js version, I needed to replace it. Fortunately\
    \ Javascript comes with the functionality needed to make requests to a a http\
    \ endpoint. This is exposed to the Ajax library in scala.js. So removing the scalaj\
    \ library and replacing the calls with Ajax was all that was needed. You can see\
    \ the implementation for this in the source file HNFetch.scala def hnRequest[T](url:\
    \ String)(implicit r: Reader[T]) : Future[Either[String, T]] Custom DataCache\
    \ The DataCache interface in Fetch allows you to update the cache with new elements\
    \ and to get a particular element from the cache if it is there. In order to write\
    \ an interactive tool to explore Fetch I wanted to be able to show the number\
    \ of elements in the cache. I also wanted to be able to empty the cache, but that\u2019\
    s straightforward, you just replace the existing cache with a new empty one. Take\
    \ a look at the code in Cache.scala for a simple DataCache implementation with\
    \ the size function exposed. Udash frontend The Udash guide tells you everything\
    \ you need to know to make great interactive frontends (and two kinds of backends)\
    \ in a typesafe manner and entirely in Scala. I\u2019ve used the Bootstrap add-on\
    \ to utilize features such as tabbed panes to switch between the stories and the\
    \ fetch diagram. Visualizing the Fetch rounds Probably the most interesting part\
    \ of this project, although it was also fairly easy to implement, was the visualization\
    \ of each fetch round. For this I used reftree, and you can find out more about\
    \ it in this video https://www.youtube.com/watch?v=6mWaqGHeg3g Reftree takes care\
    \ of the hard part of rendering the view using Javascript\u2019s Vis.js (or GraphViz\
    \ on the JVM), you just need to be able to translate your data into a RefTree\
    \ by writing an implicit conversion: implicit def fetchInfoToRefTree : ToRefTree\
    \ [ FetchInfo ] = ToRefTree [ FetchInfo ] { fetchInfo => RefTree . Ref ( fetchInfo\
    \ , Seq ( RefTree . Val ( fetchInfo . count ). toField . withName ( \"count\"\
    \ ), fetchInfo . dsName . refTree . toField . withName ( \"datasource\" ) )) }\
    \ implicit def roundToRefTree : ToRefTree [ Round ] = ToRefTree [ Round ] { round\
    \ => val fetchInfos : List [ FetchInfo ] = getRoundCountAndDSName ( round ) RefTree\
    \ . Ref ( round , Seq ( RefTree . Val (( round . end - round . start ) / 1000000\
    \ ). toField . withName ( \"ms\" ), fetchInfos . refTree . toField . withName\
    \ ( \"Fetches\" ) )) } Here\u2019s a sample diagram of the Fetch rounds Here you\
    \ can see that each round grabbed at least 8 items (that\u2019s the number of\
    \ items per round my data source specifies) and you can see the time in ms for\
    \ each one. One thing to note is that the rounds are actually a queue not a list,\
    \ but I found the list view was a lot easier to understand visually. Next steps\
    \ Some ideas I have for extending the project: Do fetch and display of comments\
    \ for the stories Interactive queries around users, stories and comments Periodic\
    \ update of top stories animating the movers on the current page Feel free to\
    \ fork the code on github and expand it your needs, and as always feel free to\
    \ contact me at the links above with any questions or comments. Copyright (C)\
    \ 2017 Justin-Heyes-Jones - All Rights Reserved"
  key: 2017/10/10/hacker-news-api-3.html
- document: "Previous post: Hacker News API part 1 Github project related to this\
    \ post hnfetch Note: I\u2019ve updated this project a lot since this post but\
    \ you can get the version from this post from this tagged release. In the last\
    \ post I demonstrated building a program to fetch data from the Hacker News API\
    \ using a combination of libraries including scalaj-http and uPickle. This time\
    \ I will demonstrate a wrapper around the core functionality using the Fetch library\
    \ by the cool folk at 47 Degrees. Fetch is based on the Facebook\u2019s Haskell\
    \ library Haxl and is designed to reduce the amount of complexity around managing\
    \ calls to data sources such as caches, databases and web api\u2019s. In this\
    \ article I will show how to turn my simple http calls to the Hacker News API\
    \ into Fetch friendly data sources. That will then enable us to take advantage\
    \ of automatic caching of stories and users, management of how many concurrent\
    \ calls to make as well as giving us a nice purely functional interface to the\
    \ data which uses Free Monads. Since their documentation already contains a very\
    \ good tutorial and guide to all the features, I won\u2019t repeat that here and\
    \ encourage you to read that instead. Fetch uses functional programming library\
    \ Cats, so let\u2019s bring that into the project as well as Fetch itself: libraryDependencies\
    \ ++= Seq ( \"org.typelevel\" %% \"cats\" % \"0.9.0\" , \"com.47deg\" %% \"fetch\"\
    \ % \"0.6.2\" ) The next step in converting the Hacker News api code to Fetch\
    \ is to create datasource for the user and story types. As you can see in the\
    \ Fetch documentation (and source) a datasource just has to say how to get one\
    \ of a thing, multiple things, and some behaviour configuration: DataSource Here\u2019\
    s the data sources for Hacker News items and stories. object HNDataSources { //\
    \ Some constants to control the behaviour of Fetch executions // These could be\
    \ moved to a config file in a real applications val fetchTimeout : Duration =\
    \ 10 seconds // max time to wait for a single fetch val batchSize = Some ( 8 )\
    \ // max concurrent requests of each data source val executionType : ExecutionType\
    \ = Sequential // whether to do batches concurrently or sequentially import cats.data.NonEmptyList\
    \ implicit object HNUserSource extends DataSource [ HNUserID , HNUser ]{ override\
    \ def name = \"user\" override def maxBatchSize = batchSize override def batchExecution\
    \ = executionType override def fetchOne ( id : HNUserID ) : Query [ Option [ HNUser\
    \ ]] = { Query . async ({ ( ok , fail ) => HNFetch . getUser ( id ) onComplete\
    \ { case Success ( futSucc ) => futSucc match { case Right ( item ) => println\
    \ ( s \"GOT Item $id\" ) ok ( Some ( item )) case Left ( err ) => ok ( None )\
    \ } case Failure ( e ) => fail ( e ) } }, fetchTimeout ) } // If the data source\
    \ supports multiple queries (the HN API does not) you can implement it here //\
    \ otherwise you can just tell it to use the single one using this built in function...\
    \ override def fetchMany ( ids : NonEmptyList [ HNUserID ]) : Query [ Map [ HNUserID\
    \ , HNUser ]] = { batchingNotSupported ( ids ) } } implicit object HNItemSource\
    \ extends DataSource [ HNItemID , HNItem ]{ override def name = \"item\" override\
    \ def maxBatchSize = batchSize override def batchExecution = executionType override\
    \ def fetchOne ( id : HNItemID ) : Query [ Option [ HNItem ]] = { Query . async\
    \ ({ ( ok , fail ) => println ( s \"GET Item $id\" ) HNFetch . getItem ( id )\
    \ onComplete { case Success ( futSucc ) => futSucc match { case Right ( item )\
    \ => println ( s \"GOT Item $id\" ) ok ( Some ( item )) case Left ( err ) => ok\
    \ ( None ) } case Failure ( e ) => fail ( e ) } }, fetchTimeout ) // If the data\
    \ source supports multiple queries (the HN API does not) you can implement it\
    \ here // otherwise you can just tell it to use the single one using this built\
    \ in function... override def fetchMany ( ids : NonEmptyList [ HNItemID ]) : Query\
    \ [ Map [ HNItemID , HNItem ]] = { batchingNotSupported ( ids ) } } def getUser\
    \ ( id : HNUserID ) : Fetch [ HNUser ] = Fetch ( id ) def getItem ( id : HNItemID\
    \ ) : Fetch [ HNItem ] = Fetch ( id ) } Some things to note: You also need to\
    \ make smart constructors for each datasource to create Fetch[T] Each data source\
    \ has a name to identify it. \u201Citem\u201D and \u201Cstory\u201D in this case\
    \ You can define how mant requests to make to each data source in batches, if\
    \ the underlying DB or resource supports batching for example. With that underway\
    \ we can now utilize the Fetch library to grab our data in various ways. The example\
    \ program FrontPageWithFetch demonstrates the runF command fetchItems.runF[Future](cache.get)\
    \ which returns both the Fetch result and a FetchEnv. The FetchEnv includes a\
    \ detailed history of the fetch operaion as well as a cache that we can pass into\
    \ the next call and avoid retrieving duplicate items. Check the Fetch documentation\
    \ for how to implemnent your own cache should you need specific behaviour. Here\u2019\
    s a little video of the interactive front page terminal app showing how repeated\
    \ requests to the same page do not request them from the API\u2026 Fetch\u2019\
    s big idea is to hide complexity such as caching, rate limiting and other complexities\
    \ from client code, another big advantage of such a functional approach is that\
    \ you can compose queries. In this example (not in the github repo) I demonstrate\
    \ grabbing a user and his submitted items in a for comprehension. Note that the\
    \ call to getUser and getItems compose nicely into Fetch operations and are then\
    \ executed with runA to get the result. def monadicFetch () = { println ( s \"\
    Main thread id ${Thread.currentThread().getId}\" ) val seqFetch = for ( user <-\
    \ getUser ( \"justinhj\" ); //item <- getItem(user.submitted(0)) // get one item\
    \ //items <- (user.submitted.map(getItem(_))).sequence // get multiple as a sequence\
    \ _ = println ( s \"user has ${user.submitted.size} submitted items\" ); items\
    \ <- user . submitted . take ( 10 ). traverse ( getItem ) // get multiple using\
    \ traverse ) yield ( user , items ) val ( user , items ) = Await . result ( seqFetch\
    \ . runA [ Future ], Duration . Inf ) println ( s \"\"\"I got user ${user.id}\
    \ and his submissions \"${items.size}\"\"\"\" ) items . filter ( i => i . `type`\
    \ == \"story\" ). foreach { i => println ( s \"${i.id} : ${i.`type`}\" )} } This\
    \ has been a short and sweet introduction to Fetch. It seems like a solid library\
    \ with a lot of use cases, and a good example of Free Monad\u2019s in the wild.\
    \ Postscript: Thanks to a suggestion from @peterneyens I\u2019ve update the async\
    \ datasources to use onComplete rather than map/recover"
  key: 2017/07/29/hacker-news-api-2.html
- document: "Previous post: Future Either with Cats In a small project I\u2019m working\
    \ on I needed a way to limit the amount of time my program waits for a future,\
    \ returning a timeout if it takes too long. This functionality is not built into\
    \ the Scala\u2019s standard Future and, although you can use Await from scala.concurrent\
    \ , this will block your thread which is not always desirable. I came across several\
    \ ways to achieve the result such as this post on Nami\u2019s Tech Blog Scala\
    \ Futures with Timeout The solution here involves using Akka\u2019s akka.pattern.after\
    \ which let\u2019s you make a future that returns a specified result (succesful\
    \ or otherwise) after a specified time. Unfortunately this solution requires one\
    \ to pull in Akka, which is a heavy dependency if you don\u2019t need it for anything\
    \ else. Akka after pattern Next I found the following Stackoverflow question which\
    \ has several solutions Scala Futures - built in timeout? but all of them dependencies\
    \ you may not want including the Play framework and Akka. Taking these solutions\
    \ as inspiration I wrote my own that has no dependency outside the Scala and Java\
    \ library. It uses a thread that sleeps for the duration of the timeout then throws\
    \ an exception. By using Future.firstCompletedOf with the timeout future and the\
    \ callers future we have achieved our goal. // SAMPLE CODE ONLY, DO NOT USE AS\
    \ THIS CREATES A BLOCKING THREAD FOR EVERY FUTURE THAT USES IT def futureWithTimeout\
    \ [ T ]( future : => Future [ T ], timeout : FiniteDuration )( implicit ec : ExecutionContext\
    \ ) : Future [ T ] = { lazy val timeoutF = Future { Thread . sleep ( timeout .\
    \ toMillis ) throw new TimeoutException () } Future . firstCompletedOf ( List\
    \ ( timeoutF , future )) } Well this is fine in that it works, but as noted in\
    \ my comments we need to create a thread that also blocks using Thread.sleep .\
    \ Remember our initial goal was to do this without any blocking certainly with\
    \ bringing an additional thread into the picture. The next step was to determine\
    \ how to make the timeout happen without starting a new thread and without any\
    \ blocking. To the rescue comes java.util.Timer which we can use to trigger the\
    \ timeout event in the future. Timer has some very nice properties: It\u2019s\
    \ built into Java, it uses one thread per timer, it is thread safe and it is designed\
    \ to manage thousands of active Timer events on each Timer object. In order to\
    \ use the Timer we need a TimerTask which is a simple Runnable object. Here\u2019\
    s what\u2019s happening in the code below: User calls futureWithTimeout We create\
    \ a promise with which to complete the future We start a timer task which will\
    \ run at the timeout When the timeout occurs we complete the promise with TimeoutException\
    \ if it is not already complete When the user\u2019s future completes we succesfully\
    \ (or otherwise) complete the Promise if it has not alread been completed Return\
    \ the Promise\u2019s future to the user Here\u2019s a small test suite showing\
    \ the two cases for the users future succeeding and the users future timing out:\
    \ I\u2019ve add this code to the StackOverflow question about Scala and Future\
    \ timeouts. If you want to go there and upvote (or downvote) the link is here:\
    \ Scala Futures - built in timeout? And finally a quick demo of this in action\
    \ using Li Haoyi\u2019s awesome Ammonite REPL"
  key: 2017/07/16/future-with-timeout.html
- document: "Previous post: Future with Timeout Github project related to this post\
    \ hnfetch This is a quick post that will develop code to query Hacker News stories\
    \ and users using the provided Firebase API. Although you can access the API using\
    \ a Firebase client library, I thought it would be fun to develop my own to revisit\
    \ some of the error handling topics from previous posts and demonstrate a couple\
    \ of common libraries in the Scala ecosystem. We will only be concerned with queries,\
    \ so all we need to pull data down from the API is a HTTP library. I\u2019ll use\
    \ ScalaJ-HTTP. This is a nice and simple library that is also thread safe, so\
    \ although it doesn\u2019t offer an Asynchronous API, we can use Scala\u2019s\
    \ concurrency library to make it behave like it is. Since the data will come back\
    \ as JSON we need to parse it into Scala data structures. In production projects\
    \ I\u2019d recommend a more full featured and performant library such as Scala\
    \ Jackson, but a much easier to use library uPickle Finally we\u2019ll include\
    \ scalatest so we can write some tests as we go. I\u2019ll post a link to the\
    \ working code at the end of the post but for now here are the required dependencies.\
    \ \"org.scalaj\" %% \"scalaj-http\" % \"2.3.0\" , \"com.lihaoyi\" %% \"upickle\"\
    \ % \"0.4.4\" , \"org.typelevel\" %% \"cats\" % \"0.9.0\" , \"org.ocpsoft.prettytime\"\
    \ % \"prettytime\" % \"3.2.7.Final\" , \"org.scalatest\" %% \"scalatest\" % \"\
    3.0.1\" % \"test\" , \"com.lihaoyi\" % \"ammonite\" % \"1.0.0\" % \"test\" cross\
    \ CrossVersion . full I\u2019ve also add lihaoyi\u2019s ammonite library, set\
    \ up so that you run the job test:run in sbt and get an interactive repl to play\
    \ with the api. > test:run [info] Running amm Welcome to the Ammonite Repl 1.0.0\
    \ (Scala 2.12.2 Java 1.8.0_60) If you like Ammonite, please support our development\
    \ at www.patreon.com/lihaoyi @ import justinhj.hnfetch._ import justinhj.hnfetch._\
    \ @ val f1 = HNFetch.getUser(\"justinhj\") f1: concurrent.Future[Either[String,\
    \ HNFetch.HNUser]] = Future(<not completed>) @ f1 res2: concurrent.Future[Either[String,\
    \ HNFetch.HNUser]] = Future(Success(Right(HNUser(justinhj,1249966944,1247, ...\
    \ We\u2019ll build up a simple companion object HNFetch to do all the work and\
    \ put it in the file src/main/justin/hnfetch/HNFetch.scala When using scalaj-http\
    \ we can use the built in Http object to do all out queries but it also is simple\
    \ to override it with some custom options. Let\u2019s do that and change the user\
    \ agent: object CustomHttp extends BaseHttp ( proxyConfig = None , options = HttpConstants\
    \ . defaultOptions , charset = HttpConstants . utf8 , sendBufferSize = 4096 ,\
    \ userAgent = \"justinhj/hnfetch/1.0\" , compress = false ) All API calls will\
    \ share the same base URL so let\u2019s define that and then constructing the\
    \ query URL\u2019s is straightforward. I\u2019ll just define a few here for now\u2026\
    \ val baseHNURL = \"https://hacker-news.firebaseio.com/v0/\" def getUserURL (\
    \ userId : HNUserID ) = s \"${baseHNURL}user/$userId.json\" def getItemURL ( itemId\
    \ : HNItemID ) = s \"${baseHNURL}item/$itemId.json\" val getTopItemsURL = s \"\
    ${baseHNURL}topstories.json\" Actually making the query is very simple CustomHttp(url).asString\
    \ . The asString part actually executes our query in a blocking manner and returns\
    \ the response as string data. On success we can parse the result into case classes\
    \ representing the data and we\u2019re done. One thing to note is that uPickle\
    \ handles Option types by writing them as JSON arrays. For example OptionInt would\
    \ be saved as [1] whilst None would saved as []. Now the Hacker News API has some\
    \ mandatory fields and others that are optional. Since we can\u2019t tell the\
    \ API to store options in a uPickle friendly way, we must use default values for\
    \ any fields that are not mandatory. That means I needed to take the rather ugly\
    \ step of defining \u2018missing IDs\u2019 which you can see in the code below\
    \ defining the data structures we\u2019ll deal with\u2026 type HNUserID = String\
    \ type HNItemID = Int val HNMissingItemID : HNItemID = - 1 val HNMissingUserID\
    \ : HNUserID = \"\" case class HNUser ( id : HNUserID , // The user's unique username.\
    \ Case-sensitive. Required. //delay : Int, // Delay in minutes between a comment's\
    \ creation and its visibility to other users. created : Int , // Creation date\
    \ of the user, in Unix Time. karma : Int , // The user's karma. about : String\
    \ , // The user's optional self-description. HTML. submitted : List [ HNItemID\
    \ ] ) // List of the user's stories, polls and comments. case class HNItem ( id\
    \ : HNItemID , // The item's unique id. deleted : Boolean = false , // true if\
    \ the item is deleted. `type` : String , // The type of item. One of \"job\",\
    \ \"story\", \"comment\", \"poll\", or \"pollopt\". by : HNUserID = HNMissingUserID\
    \ , // The username of the item's author. time : Int , // Creation date of the\
    \ item, in Unix Time. text : String = \"\" , // The comment, story or poll text.\
    \ HTML. dead : Boolean = false , // true if the item is dead. parent : HNItemID\
    \ = HNMissingItemID , // The comment's parent: either another comment or the relevant\
    \ story. poll : HNItemID = HNMissingItemID , // The pollopt's associated poll.\
    \ kids : List [ HNItemID ] = List (), // The ids of the item's comments, in ranked\
    \ display order. url : String = \"\" , // The URL of the story. score : Int =\
    \ - 1 , // The story's score, or the votes for a pollopt. title : String = \"\"\
    \ , // The title of the story, poll or job. parts : List [ HNItemID ] = List (),\
    \ // A list of related pollopts, in display order. descendants : Int = 0 // In\
    \ the case of stories or polls, the total comment count. ) The final step is to\
    \ write code to fetch and parse the data. Since the only difference between fetching\
    \ a User and a Story is the type of the case class we parse, I wrote a function\
    \ that is parameterized by the type and handles making the call asynchronous with\
    \ errors reported in an Either \u2026 def hnRequest [ T ]( url : String )( implicit\
    \ r : Reader [ T ]) : Future [ Either [ String , T ]] = { Future { CustomHttp\
    \ ( url ). asString }. map { response => if ( response . code == 200 ) { Try (\
    \ read [ T ]( response . body )) match { case Success ( good ) if good == null\
    \ => println ( \"got empty\" ) Left ( \"Not found\" ) case Success ( good ) =>\
    \ println ( \"got successfully\" ) Right ( good ) case Failure ( e ) => println\
    \ ( s \"got parse error ${response.body}\" ) Left ( \"Failed to read \" + e .\
    \ getMessage ()) } } else { println ( \"got no response\" ) Left ( s \"Failed\
    \ to retrieve $url code: ${response.code}\" ) } } . recover { case e : Exception\
    \ => println ( s \"got exception ${e.getMessage} due to ${e.getCause}\" ) Left\
    \ ( \"Failed to retrieve $url becasue ${e.getMessage}\" ) } } With all this in\
    \ place writing queries is simple: // constuct the query to get an item def getUser\
    \ ( userID : HNUserID ) : Future [ Either [ String , HNUser ]] = { val url = getUserURL\
    \ ( userID ) println ( s \"GET $url\" ) hnRequest [ HNUser ]( url ) } def getItem\
    \ ( itemId : HNItemID ) : Future [ Either [ String , HNItem ]] = { val url = getItemURL\
    \ ( itemId ) println ( s \"GET $url\" ) hnRequest [ HNItem ]( url ) } type HNItemIDList\
    \ = List [ HNItemID ] def getTopItems () : Future [ Either [ String , HNItemIDList\
    \ ]] = { hnRequest [ HNItemIDList ]( getTopItemsURL ) } There are some scalatest\
    \ tests that check the \u2018happy path\u2019, if this was a real project I would\
    \ add more tests for failure\u2019s of various kinds but take a look if you are\
    \ interested in the new AsyncFlatSpec for testing futures more conveniently. Finally\
    \ let\u2019s write a main program to test drive the functions. I\u2019ve tried\
    \ to make the output mirror the Hacker News home page, just for fun. One interesting\
    \ thing is the part which prints relative times on the posts such as \u201C3 minutes\
    \ ago\u201D and \u201C2 days ago\u201D. Rather than implement that myself I imported\
    \ the library org.ocpsoft.prettytime which makes this a breeze. Here\u2019s a\
    \ look at the code that prints a page of news items: def printPage ( startPage\
    \ : Int , numItemsPerPage : Int ) : Unit = { // helper to show the article rank\
    \ def itemNum ( n : Int ) = ( startPage * numItemsPerPage ) + n + 1 val futureItems\
    \ = getTopItems (). flatMap { case Right ( items ) => val pageOfItems = items\
    \ . slice ( startPage * numItemsPerPage , startPage * numItemsPerPage + numItemsPerPage\
    \ ) getItems ( pageOfItems ) case Left ( err ) => Future . failed ( new Exception\
    \ ( err )) } val printItems = futureItems . map { _ . zipWithIndex . foreach {\
    \ case ( Right ( item ), n ) => println ( s \"${itemNum(n)}. ${item.title} ${getHostName(item.url)}\"\
    \ ) println ( s \" ${item.score} points by ${item.by} at ${timestampToPretty(item.time)}\
    \ ${item.descendants} comments \" ) case ( Left ( err ), n ) => println ( s \"\
    ${itemNum(n)}. No item (err $err)\" ) } } Await . ready ( printItems , 10 seconds\
    \ ) } Most of this is straightforward use of Scala\u2019s concurrency library,\
    \ building up a chain of futures and then waiting for them to complete, as a side\
    \ effect printing the page. First we call getTopItems which returns a Future Either\
    \ , then flatMap it rather than map it since we want to take the result of the\
    \ future (the item ids of the top items) and chain them into the call to getItems\
    \ which returns a list of futures: def getItems ( itemIDs : Seq [ HNItemID ])\
    \ : Future [ Seq [ Either [ String , HNItem ]]] = { val f = itemIDs . map { itemID\
    \ => getItem ( itemID ) } Future . sequence ( f ) } At this point we take futureItems,\
    \ zip it with an index so we can label the items by nuber, then print out each\
    \ item. Finally we use Await.ready to block until everything is done. Note that\
    \ blocking is frowned upon but it is okay in a program like this since we need\
    \ to wait for the result so we can print it out. In a more interactive program\
    \ you want to keep working with futures as long as possible. Here\u2019s a demo\
    \ run: > run 0 [info] Running justinhj.hnfetch.FrontPage 0 1. BTC-E Charged in\
    \ 21-Count Indictment for Laundering Funds from Hack of Mt. Gox (www.justice.gov)\
    \ 150 points by ryanlol at 5 hours ago 59 comments 2. Slack Is Raising $250M from\
    \ SoftBank, Others (www.bloomberg.com) 52 points by Element_ at 3 hours ago 20\
    \ comments 3. First Human Embryos Edited in U.S (www.technologyreview.com) 231\
    \ points by astdb at 7 hours ago 101 comments 4. A WWII Vet Was Docked Pay for\
    \ Escaping His German Captors. Now He Wants His $13 (taskandpurpose.com) 17 points\
    \ by smacktoward at 1 hour ago 0 comments 5. Britain to Ban New Diesel and Gas\
    \ Cars by 2040 (www.nytimes.com) 13 points by kimsk112 at 2 hours ago 0 comments\
    \ 6. Remotely Compromising Android and iOS via a bug in Broadcom's WI-FI Chipsets\
    \ (blog.exodusintel.com) 233 points by pedro84 at 10 hours ago 97 comments 7.\
    \ Google and a nuclear fusion company have developed a new algorithm (www.theguardian.com)\
    \ 272 points by jonbaer at 12 hours ago 83 comments 8. Longest Lines of Sight\
    \ on Earth (beyondhorizons.eu) 168 points by pilom at 7 hours ago 68 comments\
    \ 9. Announcing the Windows Bounty Program (blogs.technet.microsoft.com) 214 points\
    \ by el_duderino at 11 hours ago 91 comments 10. An American acquitted of spying\
    \ for the Soviets\u2013even after he confessed to it (longreads.com) 35 points\
    \ by samclemens at 3 days ago 7 comments [success] Total time: 1 s, completed\
    \ 26-Jul-2017 10:58:37 PM Please take a look at the source code for hnfetch and\
    \ play around with it. I welcome any feedback in the comments section or on Twitter.\
    \ In a future post I plan to revisit this code to demonstrate some of the cool\
    \ capabilities of 47deg\u2019s Fetch library."
  key: 2017/07/26/hacker-news-api-1.html
- document: "In this post I\u2019ll walk through building this Roman numeral to decimal\
    \ converter using Scala.js and the Udash web application framework See the project\
    \ on Github Udashroman Clojurescript to Scala Several years ago when I was working\
    \ through the Clojure exercises on 4clojure.org I implemented conversion from\
    \ decimal numbers to roman numerals Write Roman Numerals and the same thing in\
    \ reverse Read Roman Numerals. Next, when learning how to write Clojurescript\
    \ web frontends, I implemented a simple web app to do the conversion live as you\
    \ make changes to either the decimal or roman inputs which is modelled on the\
    \ conversion UI you may see on Google when converting between pounds and kg and\
    \ so on. You can try out this clojurescript version of the app here romanclojure\
    \ and the source code is available at http://github.com/justinhj/cljs-roman. The\
    \ code consists of a single, quite concise, Clojurescript source file main.cljs\
    \ Building an app with Udash Udash is designed to write rich single page apps\
    \ and using the provided project generator to create one with some sample pages\
    \ made it really easy to get started although I\u2019d recommend skimming through\
    \ most of the Udash guide before you start. After creating my project I modified\
    \ the RoutingRegistryDef which defines the routing rules to map the URL to the\
    \ individual views of your application. In my case there is only one page so this\
    \ is straightforward. private val ( url2State , state2Url ) = Bidirectional [\
    \ String , RoutingState ] { case \"\" => RomanConverterState } It is good practise\
    \ to separate your application\u2019s business logic from UI code to make it more\
    \ testable, and by not having any dependencies on other libraries it is easy to\
    \ move into another project if you need to. For that reason I created a companion\
    \ object com.justinhj.romanconvert.Convert which contains functions to convert\
    \ back and forth between Roman and Decimal. If you compare my original Clojurescript\
    \ with the new Scala code you can see that the functions converted quite cleanly.\
    \ The only complication I ran into is that the Scala standard library does not\
    \ have an exact equivalent of Clojure\u2019s partition function which I use as\
    \ part of the conversion. As an example if you pass in \u201CIX\u201D then I will\
    \ map that to the pairs List((1, 10), (10, 0)) and if you pass \u201CXI\u201D\
    \ I want List((10, 1), (1, 0)) . In other words we pair each value with the one\
    \ before it and use 0 as a pad value when we run out at the end. Scala\u2019s\
    \ partition function sliding does not allow this default pad value. In order to\
    \ get around this I instead implemented the function pairUp to do exactly what\
    \ I needed in this case. Please be aware that one the goals of 4Clojure puzzles\
    \ is to solve the problem with as little code as possible as there is a code golf\
    \ leaderboard for each one. For that reason my original Clojure code has no comments\
    \ and is not written in what I\u2019d call a maintable style. In porting to Scala\
    \ I did try to make it more readable and so it is a little more verbose. With\
    \ Udash each page of your app requires a number of classes defined to make the\
    \ view work and since our app is only one page all of the code is in RomanConverterView.scala\
    \ and I\u2019ll walk through the pieces from top to bottom. Your application data\
    \ is represented as a Property. You can aggregate several fields together to make\
    \ a ModelProperty and that\u2019s what I\u2019ve done in this case. The data for\
    \ our application consists of the current decimal number and the current roman\
    \ numeral. trait ConversionModel { def decimal : String def roman : String } Next\
    \ we need a ViewPresenter RomanConverterViewPresenter which is used by Udash to\
    \ create a presenter and view and in our case is very simple as you can see in\
    \ the code for RomanConverterViewPresenter . It creates a model and passes that\
    \ to both the Presenter which will handle business logic and the View which will\
    \ handle the rendering of our application. RomanConverterPresenter represents\
    \ the interactive portion of our app and is responsible for validating the data\
    \ in the model and converting from decimal to roman when the properties change.\
    \ The method handleState is an initialization function called when the state becomes\
    \ active. It adds a Validator to each property. With that in place you can check\
    \ if an input is valid using the isValid method. Interestingly this returns a\
    \ Future indicating that you could perhaps perform some web request or other IO\
    \ operation without blocking Javascript\u2019s single thread. My validators are\
    \ fairly simple and only check that your Roman property contains valid Roman numeral\
    \ characters whilst the decimal one will ensure that you are converting a positive\
    \ non-zero number less that a certain maximum (since large numbers quickly fill\
    \ up the screen with M\u2019s!). As a bonus we can use the validators to modify\
    \ the class of the inputs to .error which will highlight the field in red as shown\
    \ below: In the original Clojure app I used the Dommy library to add listeners\
    \ to each field to make the conversion when the input changes. In Udash the same\
    \ thing is done using the listen callback on properties. By adding a listener\
    \ to decimal and roman sub properties of our model, if the user changes them our\
    \ code will get triggered. Let\u2019s look at handling a change to the roman property,\
    \ the decimal one is similar. As you can see we define the listen callback as\
    \ a function which will call validate on the property and only proceed if the\
    \ result is Valid . Folowing that we trigger the conversion and if all is well\
    \ call set on the sub property to update the decimal value. model . subProp (\
    \ _ . roman ). listen { r => model . subProp ( _ . roman ). isValid . onComplete\
    \ { case Success ( Valid ) => Convert . safeRomanNumeralsToDecimal ( r ) match\
    \ { case Right ( converted ) => model . subProp ( _ . decimal ). set ( converted\
    \ ) case Left ( err ) => println ( s \"$r roman convert error $err\" ) } case\
    \ Success ( errors ) => println ( s \"$r has validation errors $errors\" ) case\
    \ Failure ( err ) => println ( s \"validating $r caused exception $err\" ) } }\
    \ So far so good but we don\u2019t yet have any HTML markup for the user to interact\
    \ with. The last piece is the view itself which takes the model and presenter\
    \ as parameters as it needs to work with both of them: class RomanConverterView\
    \ ( model : ModelProperty [ ConversionModel ], presenter : RomanConverterPresenter\
    \ ) In the clojurescript code I needed to write the HTML code fro the page and\
    \ then have the script itself interact with it. In the Udash version I can write\
    \ the HTML using ScalaTags directly in the code for the view. private val content\
    \ = div ( h2 ( \"Roman Numerals Converter\" ), div ( cls := \"col-md-6\" , convertForm\
    \ , div ( DemoStyles . textVOffset ), div ( `class` := \"container\" , \"Scala.js\
    \ source code on \" , Image ( \"bitbucket.png\" , \"Bitbucket source\" , DemoStyles\
    \ . logo ), \" \" , a ( DemoStyles . underlineLinkGrey , href := ExternalUrls\
    \ . bitbucketSource , ExternalUrls . bitbucketSource ) ), div ( `class` := \"\
    container\" , \"Made with \" , Image ( \"udash_logo.png\" , \"Udash Framework\"\
    \ , DemoStyles . logo ), \" \" , a ( DemoStyles . underlineLinkGrey , href :=\
    \ ExternalUrls . homepage , \"UDash\" ), \" Scala web framework\" ) ) ) override\
    \ def getTemplate : Modifier = content getTemplate is a function in the view that\
    \ the Udash library will call to render our page and my method content contains\
    \ the markup needed to do so. As you can see a piece of markup is just a function\
    \ call and I call convertForm to generate the html for the actual input fields\
    \ which is as follows: def convertForm : Modifier = div ( UdashForm ( UdashForm\
    \ . numberInput ( validation = Some ( UdashForm . validation ( model . subProp\
    \ ( _ . decimal )))) ( \"Decimal\" ) ( model . subProp ( _ . decimal )), div (\
    \ DemoStyles . center , div ( `class` := \"glyphicon glyphicon-chevron-up\" ),\
    \ br , div ( `class` := \"glyphicon glyphicon-chevron-down\" )), UdashForm . textInput\
    \ ( validation = Some ( UdashForm . validation ( model . subProp ( _ . roman ))))\
    \ ( \"Roman\" ) ( model . subProp ( _ . roman )) ). render ) The interesting part\
    \ here is the validation parameter of the inputs. This is what enables Udash to\
    \ give the user visual feedback when validation fails. Summary My key takeaways\
    \ from this mini-project are that converting Clojurescript to Scala.js is quite\
    \ painless, and I will certainly use the Udash web more in future. Pros A large\
    \ and well documented library Write your entire frontend and backend in the same\
    \ library in the same language including type checked CSS and HTML Project generator\
    \ to get started Cons"
  key: 2017/08/26/roman-numeral-tool-with-udash.html
- document: "Disclaimer Monad transformers have some overhead, so make sure you benchmark\
    \ before and after switching to them If Scalaz or Hamster isn\u2019t your thing\
    \ check my next post: Future Either with Cats When handling errors in Scala the\
    \ Either type is very useful since it allows us to define the type of our right\
    \ result (the success) as well as the type of the left (failure) result. Just\
    \ a warning, I use Either and \\/ (ScalaZ disjunction) interchangably in this\
    \ post. Often our functions are also expected to run concurrently using a Future.\
    \ When we want to combine both capabilities together we end up with type signature\
    \ like this one: A => Future [ Either [ FailureType , SuccessType ]] Both Either\
    \ and Future are monads, which means that we can chain them together using a sequence\
    \ of flatmap and map operations. Let\u2019s consider two rather contrived functions\
    \ just for exploring how Future and Either work together. // halves the input\
    \ if it is even else fails // to investigate exception handling we will throw\
    \ an ArithmeticException if n is zero def dummyFunction1 ( n : Int )( implicit\
    \ ec : ExecutionContext ) : Future [ \\/ [ String , Int ]] = { if ( n == 0 ) {\
    \ Future . failed ( new ArithmeticException ( \"n must not be zero\" )) } else\
    \ { Future . successful ( if ( n % 2 == 0 ) \\/-( n / 2 ) else -\\/( \"An odd\
    \ number\" ) ) } } // appends a suffix to the input after converting to a string\
    \ // it doesn't like numbers divisible by 3 and 7 though def dummyFunction2 (\
    \ n : Int )( implicit ec : ExecutionContext ) : Future [ \\/ [ String , String\
    \ ]] = { Future . successful ( if ( n % 3 != 0 && n % 7 != 0 ) \\/-( n . toString\
    \ + \" horay!\" ) else -\\/( s \"I don't like the number $n\" ) ) } As you can\
    \ see it\u2019s a bit messy to work with Future[Either] because at each step of\
    \ the computation we need to reach into the Future with map, check the Either\
    \ and then pass it on to the next step. dummyFunction1 ( 14 ). flatMap { case\
    \ \\/-( rb1 ) => dummyFunction1 ( 12 ). flatMap { case \\/-( rb2 ) => dummyFunction2\
    \ ( rb2 + rb1 ). map { case \\/-( rb3 ) => rb3 // Finally we got the result }\
    \ } } Usually when we see this staircase pattern you can utilize a for comprehension\
    \ to simplify things. val r = for ( rb1 <- dummyFunction1 ( 8 ); rb2 <- dummyFunction1\
    \ ( 12 ) ) yield ( rb1 + rb2 ) r . map { _ shouldBe \\/-( 11 ) } Except we can\u2019\
    t do that because rb1 and rb2 are getting the result of the future but not inside\
    \ the disjunction. And since you can\u2019t have different effect types in a for\
    \ comprehension (it has to play nicely with flatmap) we are stuck. We could extract\
    \ the values from the futures in one for comprehension, then in a second one we\
    \ could extract from the Eithers, but that has the problem that all of the futures\
    \ have to run before our second for comprehension, and that means we could waste\
    \ time completing one of the later futures when an earlier result is Left (failure)\
    \ case. Monad Transformers Introducting EitherT. EitherT is a monad transformer,\
    \ and appears in various libraries such as ScalaZ, Cats and Hamsters. For the\
    \ Cats version of EitherT checkout this interesting blog post eed3si9n For ScalaZ\
    \ and Hamsters keep reading! ScalaZ (7) Using ScalaZ transformers we can write\
    \ our code very similarly to the code above simply by wrapping each step in an\
    \ eitherT constructor\u2026 import scalaz.EitherT.eitherT val r = for ( rb1 <-\
    \ eitherT ( dummyFunction1 ( 14 )); rb2 <- eitherT ( dummyFunction1 ( 12 )); rb3\
    \ <- eitherT ( dummyFunction2 ( rb2 + rb1 )) ) yield rb3 That\u2019s very straightforward,\
    \ and now you can see that we are able to reach into the Future result and the\
    \ Either result at the same time. Behind the scenes we\u2019re constructing the\
    \ transformer which when flatmapped knows how to do the steps that we would have\
    \ done manually. The only complication here is that now our result type at the\
    \ end is not Future[\\/[String, String]] like we\u2019d expect but in fact is\
    \ EitherT[Future, String, String] In order to get back to where we were ScalaZ\
    \ provids a run function. So the full example looks like this: import scalaz.EitherT.eitherT\
    \ val r = for ( rb1 <- eitherT ( dummyFunction1 ( 14 )); rb2 <- eitherT ( dummyFunction1\
    \ ( 12 )); rb3 <- eitherT ( dummyFunction2 ( rb2 + rb1 )) ) yield rb3 r . run\
    \ // Future[\\/[String, String]] There is one further complication with this.\
    \ In order to transform to EitherT we need a Monad[Future] otherwise we\u2019\
    ll get a compile error as follows. Error:(64, 13) could not find implicit value\
    \ for parameter F: scalaz.Functor[scala.concurrent.Future] You don\u2019t get\
    \ one for free (no pun intended) in Scalaz so let\u2019s define one as follows\
    \ implicit def MWEC ( implicit ec : ExecutionContext ) : Monad [ Future ] = new\
    \ Monad [ Future ]{ def point [ A ]( a : => A ) : Future [ A ] = Future ( a )\
    \ def bind [ A , B ]( fa : Future [ A ])( f : ( A ) => Future [ B ]) : Future\
    \ [ B ] = fa flatMap f } There\u2019s a little bit of extra work going on here,\
    \ I allow the Monad[Future] to be constructed from an execution context. The reason\
    \ for that is you need to know which execution context your future is running\
    \ in. By making the class this way I\u2019m able to pick up an execution context\
    \ implicitly defined in the same scope. See this stackoverflow question (I asked\
    \ it!) for more detail on this. Here\u2019s a scala fiddle to demonstrate all\
    \ this working: Hamsters If you don\u2019t want to bring in a big library like\
    \ ScalaZ just for this feature, there is a nice micro library called Hamsters\
    \ which contains some useful utilities, one of them being FutureEither. Using\
    \ FutureEither mirrors our approach above almost exactly. The difference is we\
    \ don\u2019t need to jump through hoops to make our own Monad[Future] and instead\
    \ of a \u2018run\u2019 function, hamsters has a function \u2018future\u2019 which\
    \ turns the FutureEither back into a Future[Either[]] The other difference is\
    \ that we\u2019re required to use the built in Scala Either instead of ScalaZ\u2019\
    s disjuction. val r = for ( rb1 <- FutureEither ( dummyFunction1 ( 14 )); rb2\
    \ <- FutureEither ( dummyFunction1 ( 12 )); rb3 <- FutureEither ( dummyFunction2\
    \ ( rb2 + rb1 )) ) yield rb3 r . future . map { case Right ( s ) => // s == \"\
    13 horay!\" case Left ( e ) => // oops } Hamsters has the advantage that the source\
    \ code is a lot easier to read than that of Scalaz. Take a look! MonadTransformers.scala\
    \ You can also take advantage of an implicit conversion to get rid of the need\
    \ for calling \u2018future\u2019 at the end. Note that I added a type annotation\
    \ when setting r which will make Scala look for the impclicit conversion. import\
    \ io.github.hamsters.MonadTransformers.futureEitherToFuture val r : Future [ Either\
    \ [ String , String ]] = for ( rb1 <- FutureEither ( dummyFunction1 ( 14 )); rb2\
    \ <- FutureEither ( dummyFunction1 ( 12 )); rb3 <- FutureEither ( dummyFunction2\
    \ ( rb2 + rb1 )) ) yield rb3 Libraries used Just for reference the libraries used\
    \ when writing this post are as follow:"
  key: 2017/06/02/future-either-and-monad-transformers.html
- document: "Disclaimer Monad transformers have some overhead, so make sure you benchmark\
    \ before and after switching to them In a previous post I was exploring the use\
    \ of the EitherT to make it easier to work with Either when it is nested in a\
    \ Future. I\u2019m currently reading the book Advanced Scala with Cats and decided\
    \ to rewrite some of my code using the Cats library instead. There\u2019s also\
    \ a page on Herding Cats where Eugene Yokota covers the same ground. I wanted\
    \ to expand my examples from last post so that they actually execute in a Future\
    \ so I can map that to my own error handling code in real programs. For example\
    \ in the Herding Cats blog the demonstration code returns values like this: EitherT\
    \ . right ( Future { List ( User ( 1 , \"Michael\" )) }) What I wanted to figure\
    \ out was how this looks in real code where you may have a function that works\
    \ with a Future[Either]. I went back to my code from last post and modified the\
    \ dummy functions so that: The code executes in a Future The function returns\
    \ Cats EitherT type response This makes things easier at the call site because\
    \ instead of converting the response from Future[Either[String, A]] as I did then,\
    \ you can simply use the EitherT directly. So instead of: val r : FutureEither\
    \ [ String , Int ] = for ( rb1 <- FutureEither ( dummyFunction1 ( 8 )); rb2 <-\
    \ FutureEither ( dummyFunction1 ( 12 )) ) yield rb1 + rb2 you can use the results\
    \ directly { for ( rb1 <- dummyFunction1 ( 8 ); rb2 <- dummyFunction1 ( 12 ) )\
    \ yield ( rb1 + rb2 )} If you check the example below the only thing needed to\
    \ make your function return an EitherT[Future] is to use the EitherT constructor\
    \ on the final value EitherT [ Future , String , Int ]( f ) The other thing you\
    \ need to know about EitherT in Cats is that you need to use \u2018value\u2019\
    \ instead of \u2018run\u2019 to get into the results at the end. I found this\
    \ post useful for more ways to create a Future[Either] stack. Final thoughts;\
    \ whilst the the syntax is slightly different when working with EitherT and Cats,\
    \ Scalaz and the Hamsters library, the concept is the same and it comes down to\
    \ finding a way to use them that makes them easier to work with at the calling\
    \ site. I think I can make things even cleaner with an implicit conversion from\
    \ Future[Either] to EitherT[Future, String, A] but that will be possibly a later\
    \ post. Libraries used Again for reference the libraries used when writing this\
    \ post are as follow:"
  key: 2017/06/18/future-either-with-cats.html
- document: Picture from flickr by Windwirral First you want to create and add files
    to the archive. Go to the target directory and enter individual filenames and
    directories you want to have included. tar -vzcf mystuff.tar.gz file1.txt file2.doc
    mypictures/ Now you can test if that worked by listing the files in the archive.
    tar -tvf mystuff.tar.gz When you want to extract the files, go to the folder where
    you want to extract them, in this case 'targetfolder'. cd targetfolder tar -vxf
    mystuff.tar.gz Here are the basic steps to use tar and gzip to package up some
    files in a compressed archive, so that you can move them to another computer or
    back them up.
  key: 2010/04/17/using-tar-and-gzip.html
- document: ' Everything is the same except you need to install Growl for Mac (obv)
    and also make sure you copy the folder called Extras somewhere. Open up a terminal
    and then cd to where you put the Extras directory. Find a sub-directory called
    growlnotify. Enter that and run ''sudo ./install.sh'' which will prompt you for
    your admin password, and then go ahead and install growlnotify You can now run
    growlnotify from a terminal window. Try it out, if it doesn''t work you won''t
    be able to growl from emacs. Now follow the instructions in my blog post above
    but ignore all the windows parts. You''ll need to customize the growl command
    (M-x customize group, todochiku) and replace the full path I used for windows
    with just ''growlnotify''. If everything is cool you can now do M-x todochiku-in
    and type a message, a time in minutes (zero for now), and pop, you should have
    a notification. Last year I wrote a blog post about how to make growl notifications
    (little pop ups driven by the application Growl) appear from emacs in windows.
    Since then I''ve become a total Mac-head. Here''s an update on how you get that
    working from emacs on a mac...'
  key: 2010/05/16/growling-mac.html
- document: Another handy function is `browse-url' which will prompt for the url but
    default to whatever your point is at. If you're in a html file and you'd like
    to open that with your browser then `browse-url-of-file' will open it up. Finally,
    and I just found this today, if you have some html code in a buffer that isn't
    even a file, you can open that in your browser to using `browse-url-of-buffer'
    and emacs will write it to a temporary file and open that in the browser for you.
    It's handy in emacs to be able to go straight to your browser to view a page,
    and you can do fancy stuff with `webjump' as I mentioned in a previous post
  key: 2010/11/02/just-browsing.html
- document: 'Download the zip file and extract it to c:\unxutils Add the following
    path to the very front of your path by editing your system environment variables
    C:\unxutils\usr\local\wbin\; That''s it. You can run rgrep now and hopefully you''re
    up and running. If not make sure you have restarted emacs so it picks up the new
    setting of PATH. Open a shell in emacs and type ''find --version''. You should
    see something like this if your path is configured correctly: c:\find --version
    find --version GNU find version 4.1 and if not you will see: C:\Windows\system32>find
    --help FIND: Parameter format not correct I lost an hour configuring this, so
    seems worthy of a blog post.A fresh install of emacs for windows will have functionality
    that does not work because it depends on unix style utilities.One very useful
    example is the command rgrep, which searches files recursively through subfolders
    looking for a regular expression in those files.Under the hood it uses the unix
    command line tools find, and egrep. Unfortunately the windows version of find
    takes entirely different parameters and will not function. In fact you will get
    an error that looks like this:FIND: Wrong parameter formatUsing the set of native
    ports of Unix command line tools UnxUtils you can easily fix this:'
  key: 2010/10/19/rgrep-on-windows-7-for-emacs.html
- document: ' show processlist ; Shows you all the active threads, which is very handy
    indeed. It shows what each thread is doing, and how long it has been doing it
    for. Thread safe record insertion When doing a record insert, another thread could
    be trying to insert a record that would violate any DB contraints, and if it gets
    there before you, then your insert will fail. There may be cases where you want
    don''t want to have it fail and try again; you may want to take a different action
    if the record already exists. For example lets say you have some data like this,
    where the Name is a unique key... Name, Number of products purchase Bob, 1, Ben,
    2, Now if two threads try to insert a user ''Roger'' who has just bought an item,
    then the one that arrives at the server last will fail. INSERT INTO purchase (Name,
    PurchaseCount) VALUES (''Roger'', ''1'') ON DUPLICATE KEY UPDATE PurchaseCount=PurchaseCount+1;
    This will handle the key collision and execute the update clause instead, in the
    event that somebody beat you to it. This makes it much easier to write thread
    safe code that adds records. '
  key: 2010/07/30/couple-of-mysql-tips.html
- document: ' For example: nohup ./myapp > output.txt will run the program myapp and
    send the output to output.txt. You can then follow the output.txt with a command
    tail -f output.txt but if you hit Ctrl-C or close the terminal (or have a power
    cut), the application will still be running on the remote machine. A more powerful
    solution is the Gnu screen application. This lets you run multiple shell sessions
    and switch between them. Using screen you can be logged into a server in your
    office, then detach from the screen session, go home and reattach to it there
    (assuming you have network access to the computer). Here''s a cheat sheet for
    using screen. Running it: screen Learning to use it: Ctrl-a help Important commands:
    Ctrl-a c (open a new window) Ctrl-a p (prev window) Ctrl-a n (next window) exit
    or C-a q to exit How to reattach to the screen session: screen -ls That shows
    screen sessions on the machine your logged on to, and then you reattach using:
    screen -r name That''s all folks! When running a linux app, perhaps on a remote
    box, you don''t want it to terminate when you close the terminal window. You can
    run some applications as daemons, or run them with the nohup command (no hang
    up).'
  key: 2010/01/01/using-screen.html
- document: ' Port knocking and listening on a high numbered non-standard port. make
    it harder for an attacker to even start trying to hack your connection. But this
    also requires you connect with a machine that you have the knock program installed
    on. Again, less convenient, more secure. However, once an attacker does find your
    port there''s nothing to stop brute force password hacking. If you look in your
    log file, you should see people connecting to your ssh port quite frequently and
    trying password attacks. cat /var/log/auth.log If you have a secure password then
    it would require days of brute force hacking to gain access to your ssh account,
    but even so, if you don''t watch your logs then it''s perfectly possible somebody
    will gain access eventually. Brute force attacks can be limited using fail2ban.
    There''s a great article on setting it up here . This program will scan your auth.log
    for you, using a regular expression to find failed password attempts. On a specified
    number of failures from a given IP, it will then modify the iptables on your machine
    (the firewall), to lock that IP out for a specified time. Now instead of watching
    your auth.log fill up with reams of failed passwords, you''ll see a greatly reduced
    amount of brute force attacks, and you can watch your fail2ban log file fill up
    with the IP addresses of hackers. There are all kinds of ways to secure an ssh
    server, with varying degrees of increasing security and decreasing flexibility.
    For example by limiting your server to only accept connections from certain known
    IP''s, you are secure from random hackers on the internet, but you lose the ability
    to connect to your machine from anywhere you want to. Perhaps while travelling,
    for example.'
  key: 2010/01/01/securing-ssh-server-with-fail2ban.html
- document: ipin.py Firstly check out this Python code The python code is clean, easy
    to read, almost like literate programming. Very useful if you want to write a
    similar application that processes every file in a directory. Firstly check out
    this Python code ipin.py , by Axel E. Brzostowski, which converts png files from
    an iphone application into a format that you can read on any computer.The python
    code is clean, easy to read, almost like literate programming. Very useful if
    you want to write a similar application that processes every file in a directory.
    transmission Another really nice program, is really a website. When you run transmission-daemon
    (linux bittorrent program), you can connect to it with a command line app called
    transmission-remote. In addition you can connect via a built in web server, which
    is a really excellently designed application. The html and javascript is so well
    documented and tidy it's as beautiful as the actual web page. Check it out here.
    Just wanted to point out a couple of very nice pieces of source code I came across
    recently.
  key: 2010/01/23/nice-code.html
- document: 'log4j is an awesome logging library for Java. One thing I found out today
    is that you can change the logging level (debug, warn, info) at runtime, with
    a few lines of code. static { // This monitors the log4j for changes over a specified
    period of milliseconds PropertyConfigurator.configureAndWatch("./resources/log4j.properties",
    60000); } What this function does is to tell log4j to check the configuration
    file every minute (60000 ms) for changes. So you can deploy a production server
    with only warn and error logging, but if something goes wrong you can enable debug
    and info logging (for example) simply by editing the configuration file and waiting
    a minute. '
  key: 2010/06/08/adjusting-server-logging-level-at.html
- document: 'Nice article comparing directly some code written in C# vs one in F#
    What''s interesting is that now that VM''s are starting to become the new platforms,
    we are starting to be less restricted by language choice. When it''s native code
    with hand crafted memory management you want, it has to be C++. But when you start
    to look at the JDK and the .Net VM''s, the language choice has far less impact
    on performance... after all you''re using the same garbage collector, same base
    libraries and so on. This is great news for those of us with more peculiar tastes
    in language (I like Clojure and Common Lisp for example). Although I think it
    will be a few years until AAA console games run on VM''s, if ever, due to the
    nature of that business. Memory is always at a premium, and the goal is to choke
    every last hz of CPU performance. '
  key: 2010/12/15/f-vs-c.html
- document: "Updated June 29th 2019 to work with latest ZIO version (1.0.0-RC8-12)\
    \ This post has accompanying source code on Github: Hacker News is a news aggregation\
    \ site which provides a simple API over http, for which the documentation can\
    \ be found here. Over several blog posts I have been writing programs that interact\
    \ with the API as a way of exploring new techniques in Scala pure functional programming.\
    \ This post is the fifth in a series. Here\u2019s what came before: A few months\
    \ ago I attempted to update the code using two other techniques. The first was\
    \ tagless final style (see https://softwaremill.com/free-tagless-compared-how-not-to-commit-to-monad-too-early/)\
    \ and the second was using a monad transformer library approach https://typelevel.org/cats-mtl/\
    \ What these techniques have in common is they allow us to defer the specific\
    \ Monad type used in our code until later, allowing more flexibility and the ability\
    \ to, for example, replace an asynchronous Task effect with a simpler Monad such\
    \ as Id. This would enable us to write test suites that run faster. In addition\
    \ it allows to swap out implementations of things like logging. Something like\
    \ dependency injection at the higher kinded type level. While I was able to get\
    \ my Hacker News API working with both these techniques, I never really got the\
    \ code to a state where I wanted to share it with the world, or would be prepared\
    \ to push it onto a team as an example of good style, so having seen this John\
    \ de Goes talk The Death Of Final Tagless and his follow up Beautiful, Simple,\
    \ Testable Functional Effects for Scala, I decided it was time to start investigating\
    \ ZIO. Like Monix, ZIO is a library that provides a full suite of tools for writing\
    \ asynchronous and concurrent programs. You can see the full documentation here:\
    \ Zio documentation The example code consists of three example programs. The first\
    \ is based on my previous posts and simply retrieves and displays the current\
    \ stories a page at a time. Showing front page stories ShowStories.scala is one\
    \ of the examples include that simply gets the top stories (a list of story IDs\
    \ ranked by their position on the Hacker News page) and then displays them in\
    \ the console\u2026 val runtime = new LiveRuntime {} val program = ( for ( s <-\
    \ httpclient . get ( getTopItemsURL ); items <- parseTopItemsResponse ( s ); _\
    \ <- showPagesLoop ( items ) ) yield ()). foldM ( err => putStrLn ( s \"Program\
    \ threw exception. ${err.getMessage}\" ), succ => ZIO . succeed (()) ) runtime\
    \ . unsafeRunSync ( program ) The showPagesLoop asks the user for a page number\
    \ and continues looping until the user enters something that is not a number:\
    \ def showPagesLoop ( topItems : HNItemIDList ) : ZIO [ Env , Throwable , Unit\
    \ ] = { val itemsPerPage = 5 getUserPage . flatMap { case Some ( pageNumber )\
    \ => for ( _ <- putStrLn ( s \"Page $pageNumber\" ); items <- fetchPage ( pageNumber\
    \ , itemsPerPage , topItems ); _ <- printPageItems ( pageNumber , itemsPerPage\
    \ , items ); _ <- showPagesLoop ( topItems ) ) yield () case None => putStrLn\
    \ ( \"Have a nice day!\" ) } } Modules and the environment The programs are built\
    \ from modules that make up the R part of ZIO[R,E,A]. I\u2019m using the built\
    \ in ones Blocking and Console, along with my own HttpClient that takes of retrieving\
    \ data from a url as a string. An Environment for the runtime is an aggregation\
    \ of the modules that make up your whole program: type Environment = Clock with\
    \ Console with System with Random with Blocking with HttpClient Blocking is module\
    \ that allows blocking operations to use a special threadpool, so that blocking\
    \ calls don\u2019t deplete threads from your main thread pool. Effects can be\
    \ made to run on the blocking pool just by wrapping them as follows: HttpClient.scala\
    \ blocking ( ZIO . effect ( requestSync ( url ))) Testing The nice thing about\
    \ HttpClient being a module is that I can test my code without a web connection,\
    \ or without hitting the real Hacker News by swapping the real implementation\
    \ with a test one. You can see that in action in the test suite: HNApiTest.scala\
    \ - sample test suite // The test http runtime trait HttpClientTest extends HttpClient\
    \ { val sampleTopStories = Test data omitted val sampleItem = Test data omitted\
    \ val httpClient : Service [ Any with HttpClient with Blocking ] = new Service\
    \ [ Any with HttpClient with Blocking ] { def requestSync ( url : String ) : String\
    \ = { if ( url == HNApi . getTopItemsURL ) sampleTopStories else if ( url == HNApi\
    \ . getItemURL ( 11498534 )) sampleItem else throw new Exception ( s \"$url not\
    \ found in http mock client\" ) } final def get ( url : String ) : Task [ String\
    \ ] = { ZIO . effect ( requestSync ( url )) } } } This concept of swapping out\
    \ modules can be useful for testing different databases, different JSON parsers\
    \ and so on. Fibers ZIO allows a large number of concurrent operations by using\
    \ an implementation of green threads called Fibers. The API is straightforward.\
    \ For example in this function that retrieves an item and them recursively retrieves\
    \ its \u2018kids\u2019 (for example kids of a comment are nested comments, kids\
    \ of a news story are the top level comments on that story) and we use the function\
    \ foreachParN(8) to split the jobs across up to 8 individual fibers. This gives\
    \ you control over the amount of active fibers in each part of your application.\
    \ HNApi.scala def getItemAndKidsList ( parentId : Int ) : ZIO [ Env , Throwable\
    \ , List [ HNItem ]] = for ( itemResponse <- httpclient . get ( getItemURL ( parentId\
    \ )); item <- parseItemResponse ( itemResponse ); kids <- ZIO . foreachParN (\
    \ 8 )( item . kids ){ id => getItemAndKidsList ( id )} ) yield kids . flatten\
    \ :+ item This function is used in the code below to show all the comments for\
    \ a given news story (by its ID): ShowStoryComments.scala val program = ( for\
    \ ( itemId <- getItemId ; itemsAndKids <- getItemAndKids ( itemId ); _ <- showComments\
    \ ( itemId , itemsAndKids ) ) yield ()). foldM ( err => putStrLn ( s \"Program\
    \ threw exception. $err\" ), succ => ZIO . succeed (()) ) Scheduling Another feature\
    \ of ZIO is the scheduler data type. Again, the API is composed of simple operations\
    \ that you can compose together to make more complex overall behaviours. In this\
    \ simple example we grab the latest story or comment submitted to Hacker News\
    \ every 10 seconds until the user quits. LastItem.scala val showLastItem = for\
    \ ( maxItemResponse <- httpclient . get ( getMaxItemURL ); maxItem <- parseMaxItemResponse\
    \ ( maxItemResponse ); itemResponse <- httpclient . get ( getItemURL ( maxItem\
    \ )); item <- parseItemResponse ( itemResponse ); _ <- showComment ( item ) )\
    \ yield () val program = showLastItem . repeat ( Schedule . spaced ( 10. seconds\
    \ )) runtime . unsafeRunSync ( program ) Final words ZIO is easy to use and very\
    \ powerful, a great combination. Even though the applications are built using\
    \ solid pure fp concepts such as the Reader and State monads, these are beneath\
    \ the surface of the API, and the user can concentrate on building the application.\
    \ I am just getting started with ZIO and any feedback on my example program and\
    \ post, good or bad, is welcome. You can contact me via Twitter or Email at the\
    \ top of the page, or open a Github issue. Thanks for getting to the end! Post\
    \ script Thanks for all the great feedback on this article! I have now changed\
    \ all occurences of the word Fibre with Fiber. I accidentally used the British\
    \ spelling of the word which is inconsistent with the spelling in Zio itself.\
    \ Copyright (C) 2019 Justin-Heyes-Jones - All Rights Reserved"
  key: 2019/04/07/hacker-news-api-5.html
- document: "This post has accompanying source code on Github: https://github.com/justinhj/hnfetch/tree/zio-cats-effect\
    \ Updated to latest ZIO etc: February 23 2020 This post is an update to an ongoing\
    \ series. See previous post here: Fetch 1.0 47 Degrees create and maintain a useful\
    \ library called Fetch, \u201CA library for Simple & Efficient data access in\
    \ Scala and Scala.js\u201D, which I\u2019ve written about before, and recently\
    \ reached version 1.0. You can check the full releases notes here: There are a\
    \ few interesting changes in this release but most notable is the move to using\
    \ Cats Effect. Previously, Fetch operated under the hood using FetchMonadError\
    \ , a monadic type which you can implement in order to manage how your Fetch is\
    \ interpreted at runtime. Twitter Futures, vanilla Scala Future\u2019s and Monix\
    \ Task were supported. As functional programming libraries start to standardise\
    \ on a common API for effects, it makes it possible for library authors to implement\
    \ their code in terms of a generic effect type, and then for the user, who may\
    \ also be attached to a particular library, to provide their runtime and effect\
    \ of choice. Another interesting change which I haven\u2019t checked out yet,\
    \ but is something I felt lacking from the pre-1.0 library was the ability to\
    \ fetch potentially missing items. Rather than get an error if an item does not\
    \ exist you can specify that it is optional. Still present are the former features\
    \ such as logging and caching, though oddly the ability to run a fetch with a\
    \ cache and a log at the same time has been removed. Conversion to use Cats Effect\
    \ Step one of upgrading my code (a simple Hacker News API client) to use Fetch\
    \ 1.0 was to update the DataSources that specify what things can be fetched and\
    \ how. object HNItemSource extends Data [ HNItemID , HNItem ] { override def name\
    \ = \"item\" def source [ F [ _ ] : ConcurrentEffect ] = new DataSource [ F ,\
    \ HNItemID , HNItem ] { override def data = HNItemSource override def CF = ConcurrentEffect\
    \ [ F ] override def fetch ( id : HNItemID ) : F [ Option [ HNItem ]] = CF . delay\
    \ ( HNFetch . getItemSync ( id ). toOption ) } } def getItem [ F [ _ ] : ConcurrentEffect\
    \ ]( id : HNItemID ) : Fetch [ F , HNItem ] = Fetch ( id , HNItemSource . source\
    \ ) The interesting changes from the original code are that we are passing in\
    \ a higher kinded type F which must implement ConcurrentEffect from Cats. We also\
    \ have a new type Data which wraps the DataSource\u2019s familiar from the previous\
    \ version. Now the file HNDataSources.scala is updated to use generic effects\
    \ we can implement the program using Zio, Cats Effect and any other compatible\
    \ effect library. In FrontPageWithFetchCats.scala I\u2019ve ported the previous\
    \ version which used Monix Task to use Cats Effect. This process was straightforward\
    \ because of the similarities between Monix and Cats. Using ZIO Making the conversion\
    \ to ZIO is a similar process except in the process I also modified the program\
    \ to use Zio\u2019s new environment. This enables me to use Console replace all\
    \ the println and readline code, and used ZIO\u2019s API to make the code a bit\
    \ clearer than the original. If I wasn\u2019t sharing the code between Cats and\
    \ Zio it would be better to add things like the Http retrieval and Json parsing\
    \ as environments, so that they can be swapped out for testing performance of\
    \ different libraries and for testing purposes. val cache = InMemoryCache . from\
    \ [ Task , HNItemID , HNItem ]() val program = ( for ( items <- ZIO . absolve\
    \ ( getTopItems (). mapError ( _ . getMessage )); _ <- showPagesLoop ( items ,\
    \ cache ) ) yield ()). foldM ( err => printError ( err . toString ), _ => ZIO\
    \ . succeed (())) runtime . unsafeRun ( program ) Since getTopItems handles errors\
    \ using Either[String, A] I use a couple of ZIO\u2019s functions to map that to\
    \ ZIO[Env, String, A] . We are now using, on the surface, ZIO\u2019s runtime and\
    \ types, to call into Fetch and have it do work for us even though there is no\
    \ explicit support for Scalaz in general, and ZIO in particular, in the Fetch\
    \ library. Quite magical! All we need to make this work is some implicit conversion\
    \ that lets ZIO take care of converting our ZIO structures to and and from Cats\
    \ Effect ones: FrontPageWithFetchZio.scala import scalaz.zio.interop.catz._ import\
    \ scalaz.zio.interop.catz.implicits._ You can read about this in ZIO\u2019s documentation\
    \ here: ZIO Cats Effect interop Combinators - sequence and traverse As discussed\
    \ in the Fetch documentation you can use the combinators traverse and sequence\
    \ to combine fetch\u2019s together. In the Cats Effect version we can fetch many\
    \ items at once by constructing each invidual fetch (which has type Fetch[F, A\
    \ ) and adding them to a list. We then need to convert List[Fetch[F, A] to Fetch[F,\
    \ List[A]] . This is done as follows: val pageOfItems = hNItemIDList . slice (\
    \ startPage * numItemsPerPage , startPage * numItemsPerPage + numItemsPerPage\
    \ ) val fetchItems : Fetch [ IO , List [ HNItem ]] = pageOfItems . traverse (\
    \ getItem [ IO ]) Fetch . runCache [ IO ]( fetchItems , cache ) Now although I\
    \ can run simple fetch\u2019s using ZIO interop without having to do much work,\
    \ it\u2019s not as easy to use traverse with Scalaz and ZIO. I did spend some\
    \ time trying but it appears that the reason this works in my Cats Effect code\
    \ is that fetch itself implements a Monad for Fetch and that Monad is implemented\
    \ in terms of Cats. In order to use the combinators without Cats you need to either\
    \ reimplement the Fetch Monad, or at least enough operations to support traverse\
    \ (applicative and pure), and then it will be fine. Rather than go to those lengths,\
    \ for the purposes of just making this work I implemented a helper function in\
    \ the DataSources file, which uses Cats and returns the appropriate data structure\
    \ which can then be used by ZIO when the Fetch executes. def getMultipleItems\
    \ [ F [ _ ] : ConcurrentEffect ]( ids : List [ HNItemID ], cache : DataCache [\
    \ F ]) ( implicit cs : ContextShift [ F ], timer : Timer [ F ]) = { val fetchItems\
    \ : Fetch [ F , List [ HNItem ]] = ids . traverse ( getItem [ F ]) Fetch . runCache\
    \ [ F ]( fetchItems , cache ) } Conclusion The experience of porting code to use\
    \ Cats Effect and ZIO with a library that uses an effect type as its API was quite\
    \ straightforward, and I find this style promising for the future, particularly\
    \ as effects get more features and hopefully more standardised. It can get interesting\
    \ to mentally juggle which typeclasses and data types you are using at any particular\
    \ part of the program. Thanks for reading! Copyright (C) 2019 Justin-Heyes-Jones\
    \ - All Rights Reserved"
  key: 2019/05/05/using-47degs-fetch-with-zio.html
- document: "This post is aimed at the Scala programmer with some experience pure\
    \ functional programming with the Cats fp library: https://typelevel.org/cats/.\
    \ We will look at Comonads, a type class closely related to Monads, firstly from\
    \ an abstract point of view and progressing to a couple of practical, yet simple,\
    \ examples of using Comonads for interesting applications. Example code used in\
    \ this post is from this github project: Presentation based on this post from\
    \ the Vancouver Scala Meetup: Monads To explain comonads, a good place to start\
    \ is how they relate to monads. In order to get from monad to comonad, we define\
    \ operations that are the dual of those in monad. By dual, we mean that the direction\
    \ of the data flows is reversed. The Functor type class has a single operation\
    \ map which lets us take a pure function that converts pure values A to pure values\
    \ of type B , and as you can see from the type signature it does so in some context\
    \ F . Examples of a context could be lists, asynchronous or deferred calculations\
    \ (Future, Cats Effect, ZIO, Monix Task) and options. For our simple example we\
    \ will consider lists of things as our context but bear in mind that contexts\
    \ are not always simple containers. trait Functor [ F [ _ ]] { def map [ A , B\
    \ ]( fa : F [ A ])( f : ( A ) \u21D2 B ) : F [ B ] } Examples of using a map would\
    \ be to map a list of strings into a list of numbers (the length of those strings)\u2026\
    \ import cats._ import cats.implicits._ List ( \"Hello\" , \",\" , \"how\" , \"\
    \ \" , \"are\" , \"you\" , \"?\" ). map ( _ . size ) // List[Int] = List(5, 1,\
    \ 3, 1, 3, 3, 1) Monads are all Functors, so we can can define it as an extension\
    \ of Functor, being assured that it has a definition of map. How can we be sure?\
    \ Well it is possible to implement map using pure and flatmap, we\u2019ll see\
    \ that shortly, which proves that all monads are functors. Here\u2019s the type\
    \ class definition for Monad. trait Monad [ F [ _ ]] extends Functor [ F ] { def\
    \ pure [ A ]( x : A ) : F [ A ] def flatMap [ A , B ]( fa : F [ A ])( f : ( A\
    \ ) \u21D2 F [ B ]) : F [ B ] } Aside from map, Monads must implement pure which\
    \ lifts a pure value of type A into the effect context F . What that means for\
    \ collection types like list, is that it creates a new collection containing only\
    \ that element. Generally, implementing pure for a data type involves calling\
    \ a type constructor for F . 10. pure [ List ] // List[Int] = List(10) flatmap\
    \ , as you can see from the types, takes a pure value A in a context F and applies\
    \ a user supplied function to it. The function has the signature A => F[B] ; in\
    \ other words functions that take a pure value and lifts them into the context.\
    \ The return value is the new pure value B lifted into that same F context. Concretely,\
    \ imagine a function that takes an integer and returns the digits of the string\
    \ as a list. That function would match the signature A => F[B] . def intToDigits\
    \ ( n : Int ) = { n . toString . toList . map ( _ . toString . toInt ) } intToDigits\
    \ ( 1001 ) // List[Int] = List(1, 0, 0, 1) Functions that take pure values and\
    \ return their results lifted into a context are quite common, and often we want\
    \ to chain the together. If you have a function that takes a user id and has to\
    \ go to a DB it will likely return something like a IO[User] . Often these DB\
    \ lookups need to be chained together, where each cannot begin until the one before\
    \ it because it is dependent on some value returned from a previous step. Chaining\
    \ together effectful functions like this is what flatMap does. To give a concrete\
    \ example of this chaining we need a second function that we can chain with intToDigits\
    \ . def intToRepeat ( n : Int ) = { List . fill ( n )( n ) } intToRepeat ( 5 )\
    \ // List[Int] = List(5, 5, 5, 5, 5) intToDigits ( 12345 ). flatMap ( intToRepeat\
    \ ) // List[Int] = List(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5) Just to enforce\
    \ why we need flatMap here let\u2019s look at what happens if we use map instead.\
    \ intToDigits ( 12345 ). map ( intToRepeat ) // List[List[Int]] = List(List(1),\
    \ List(2, 2), List(3, 3, 3), List(4, 4, 4, 4), List(5, 5, 5, 5, 5)) As you can\
    \ see what happened here is we ended up with a nested context F[F[A]] instead\
    \ of what we wanted, F[A] . The reason flatMap is so named is that it can be implemented\
    \ by first mapping each A to a F[A] giving the F[F[A]] then flattening in it to\
    \ an F[A] . In fact flatten is implemented for monad in Cats, and the standard\
    \ library for that matter, and when we get to comonads it will be helpful to implement\
    \ it\u2019s dual, which we shall call coflatten . We are done with monads for\
    \ now, but just going back to what I said before about monads being functors,\
    \ here\u2019s how we can implement map in terms of pure and flatmap. def map [\
    \ A , B ]( n : List [ A ], f : A => B ) : List [ B ] = n . flatMap ( a => f (\
    \ a ). pure [ List ]) map [ Int , Int ]( List ( 1 , 2 , 3 ), a => a + 1 ) //List[Int]\
    \ = List(2, 3, 4) Comonads From an abstract point of view Monads allow us to chain\
    \ effects, and to lift pure values into effects. Let\u2019s now consider Comonads\
    \ and their dual operations. trait Comonad [ F [ _ ]] extends Functor [ F ] {\
    \ def extract [ A ]( x : F [ A ]) : A def coflatMap [ A , B ]( fa : F [ A ])(\
    \ f : F [ A ] => B ) : F [ B ] } extract is the dual of pure . In some libraries\
    \ or languages extract is known as counit (and pure is known as unit ), making\
    \ the relationship between the two more obvious. Remember that pure lifts values\
    \ into a context. The type signature shows us that extract instead can reach into\
    \ the context F[A] and give us an A . Not all data types have an implementation\
    \ of extract. Our example of List above does not, because Lists can be empty and\
    \ the there would be no way to extract a value. In pure functional programming\
    \ we can\u2019t simply return null or throw an exception; in order to remain pure\
    \ we have to return an A , so any data types that cannot implement extract do\
    \ not have Comonad instances. For our purposes let\u2019s switch to NonEmptyList\
    \ , which you can find in Cats and represents a list that cannot be empty. Since\
    \ it cannot be empty we can always extract a value. import cats.data.NonEmptyList\
    \ val nel1 = NonEmptyList . of ( 1 , 2 , 3 , 4 , 5 ) // NonEmptyList[Int] = NonEmptyList(1,\
    \ List(2, 3, 4, 5)) nel1 . extract // Int = 1 I found extract is simple to understand,\
    \ but coflatMap takes some mental gymnastics to follow. Before we consider that,\
    \ let\u2019s look at coflatten , the dual of flatten . Remember that flatten made\
    \ it easy for us to implement flatMap which requires a way to reduce a nested\
    \ structure by one level. As you can see from the type signature, a coflatten\
    \ takes a value A in a context and returns it in a nested context. def coflatten\
    \ [ A ]( fa : F [ A ]) : F [ F [ A ]] When implementing Comonad\u2019s for our\
    \ own data types we need to make a decision on how to take a structure and create\
    \ a nested version of it. This is not totally arbitrary, as Comonads have a set\
    \ of laws like Monads, and so our implementation must satisfy those laws. As we\u2019\
    ll see shortly, a way to make a lawful Comonad for NonEmptyList is for the coflatten\
    \ to create a NonEmptyList[NonEmptyList[A]]] which is a list of the original list\
    \ and all of its suffixes (tails). val nel1 = NonEmptyList . of ( 1 , 2 , 3 ,\
    \ 4 , 5 ) //NonEmptyList[Int] = NonEmptyList(1, List(2, 3, 4, 5)) nel1 . coflatten\
    \ // NonEmptyList[NonEmptyList[Int]] = NonEmptyList( // NonEmptyList(1, List(2,\
    \ 3, 4, 5)), // List(NonEmptyList(2, List(3, 4, 5)), NonEmptyList(3, List(4, 5)),\
    \ NonEmptyList(4, List(5)), NonEmptyList(5, List())) // ) One of the comonad laws\
    \ is the left identity which specifies fa.coflatten.extract <-> fa . (All of the\
    \ laws can be checked using the ComonadLaws in Cats). You can see that this makes\
    \ sense in terms of the implementation of NonEmptyList above. Once we have the\
    \ coflatten implementation for a type we can implement coflatMap . Based on the\
    \ signature def coflatMap[A, B](fa: F[A])(f: F[A] => B): F[B] you can see that,\
    \ just like extract , we have just reversed the direction of data flow from A\
    \ => F[B] to F[A] => B . That means the caller of the function is going provide\
    \ a function that gets to look at each suffix of the NonEmptyList and combine\
    \ each to a single value of type B . Those values are returned to the user in\
    \ a new NonEmptyList. For example taking the size of a NonEmptyList matches the\
    \ type signature. NonEmptyList . of ( 1 , 2 , 3 , 4 , 5 ). coflatMap ( _ . size\
    \ ) //NonEmptyList[Int] = NonEmptyList(5, List(4, 3, 2, 1)) Notice that when you\
    \ flatMap a list, the mapping part looks at the list one element at a time, transforming\
    \ it to a list. When you coflatMap a list you\u2019re looking at the list and\
    \ all of its tails one by one, collapsing each of them down into a single value.\
    \ Comonad laws In this section I\u2019ll demonstrate each of the Comonad laws\
    \ in code using NonEmptyList . val fa = NonEmptyList . of ( 1 , 2 , 3 , 4 ) //\
    \ fa: NonEmptyList[Int] = NonEmptyList(1, List(2, 3, 4)) Left identity: fa.coflatten.extract\
    \ == fa fa . coflatten . extract == fa // Boolean = true Right identity: fa.coflatmap(extract)\
    \ == fa fa . coflatMap ( _ . extract ) == fa // Boolean = true Associativity:\
    \ fa.coflatten.coflatten == fa.coflatmap(coflatten) fa . coflatten . coflatten\
    \ == fa . coflatMap ( _ . coflatten ) // Boolean = true Cats contains implementations\
    \ of checks for these laws which can be found here: https://github.com/typelevel/cats/blob/master/laws/src/main/scala/cats/laws/ComonadLaws.scala\
    \ You can checkout my last post for how to setup a Scalacheck test for your own\
    \ datatypes using Cats Monoids for Production Image processing with a Comonad\
    \ I created a data type, FocusedGrid , which consists of a 2d grid of values of\
    \ some type A and a focus point which will be a Tuple2[Int, Int] . This focus\
    \ point specifies a row and column of the grid. case class FocusedGrid [ A ](\
    \ focus : Tuple2 [ Int , Int ], grid : Vector [ Vector [ A ]]) Next we implement\
    \ the Comomad (and Functor) operations for our new type. implicit val focusedGridComonad\
    \ = new Comonad [ FocusedGrid ] { override def map [ A , B ]( fa : FocusedGrid\
    \ [ A ])( f : A => B ) : FocusedGrid [ B ] = { FocusedGrid ( fa . focus , fa .\
    \ grid . map ( row => row . map ( a => f ( a )))) } override def coflatten [ A\
    \ ]( fa : FocusedGrid [ A ]) : FocusedGrid [ FocusedGrid [ A ]] = { val grid =\
    \ fa . grid . mapWithIndex (( row , ri ) => row . mapWithIndex (( col , ci ) =>\
    \ FocusedGrid (( ri , ci ), fa . grid ))) FocusedGrid ( fa . focus , grid ) }\
    \ // Gives us all of the possible foci for this grid def coflatMap [ A , B ](\
    \ fa : FocusedGrid [ A ])( f : FocusedGrid [ A ] => B ) : FocusedGrid [ B ] =\
    \ { val grid = coflatten ( fa ). grid . map ( _ . map ( col => f ( col ))) FocusedGrid\
    \ ( fa . focus , grid ) } // extract simply returns the A at the focus def extract\
    \ [ A ]( fa : FocusedGrid [ A ]) : A = fa . grid ( fa . focus . _1 )( fa . focus\
    \ . _2 ) } extract is the simplest operation and simply returns the grid value\
    \ at the focus. Looking at the type signature for coflatten you can see that it\
    \ does what we expect; creates a FocusedGrid of FocusedGrids. We iterate through\
    \ each row and column using mapWithIndex so that we can set the appropriate focus\
    \ at each point. Note that the grid itself will not be duplicated in memory for\
    \ each Vector, just a reference will be added. What is different at each row and\
    \ column is the focus. Here\u2019s an example of a coflattened FocusedGrid. FocusedGrid\
    \ (( 0 , 0 ), Vector ( Vector ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0\
    \ , 0 , 0 ))). coflatten FocusedGrid ( ( 0 , 0 ), Vector ( Vector ( FocusedGrid\
    \ (( 0 , 0 ), Vector ( Vector ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0\
    \ , 0 , 0 ))), FocusedGrid (( 0 , 1 ), Vector ( Vector ( 5 , 3 , 0 ), Vector (\
    \ 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))), FocusedGrid (( 0 , 2 ), Vector ( Vector\
    \ ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))) ), Vector ( FocusedGrid\
    \ (( 1 , 0 ), Vector ( Vector ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0\
    \ , 0 , 0 ))), FocusedGrid (( 1 , 1 ), Vector ( Vector ( 5 , 3 , 0 ), Vector (\
    \ 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))), FocusedGrid (( 1 , 2 ), Vector ( Vector\
    \ ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))) ), Vector ( FocusedGrid\
    \ (( 2 , 0 ), Vector ( Vector ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0\
    \ , 0 , 0 ))), FocusedGrid (( 2 , 1 ), Vector ( Vector ( 5 , 3 , 0 ), Vector (\
    \ 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))), FocusedGrid (( 2 , 2 ), Vector ( Vector\
    \ ( 5 , 3 , 0 ), Vector ( 3 , 1 , 0 ), Vector ( 0 , 0 , 0 ))) ) ) ) Once coflatten\
    \ is available, the implementation of coflatMap follows by simply executing coflatten\
    \ then map . Notice how this is the reverse of Monad\u2019s flatmap, which maps\
    \ first and then flattens. Now that FocusedGrid is a Comonad, what can we do with\
    \ it? Note the function signature for f is FocusedGrid[A] => B . That means we\
    \ can write a function that looks at the whole grid and lets do a calculation\
    \ from the point of view of the focus and create a single value of type B , which\
    \ will be the new value of the final grid at that position. The full implementation\
    \ can be found here: FocusedGrid.scala Image smoothing We can map image data directly\
    \ to our FocusedGrid data type, and then use it to do image processing. A simple\
    \ example is a box filter, which can be used to smooth out noise in images. In\
    \ this implementation, which you can find in the file ImageProcessor.scala, we\
    \ will load an image file, copy the image data to a FocusedGrid, and then write\
    \ the filter using the function signature FocusedGrid[(Int,Int,Int) => (Int,Int,Int)\
    \ . Note that we represent image pixels as a tuple containing the red, green and\
    \ blue components. Here\u2019s the implementation of boxfilter. You pass in the\
    \ width of the filter and it will then average the pixels for a square of the\
    \ provide width (and height) and set each pixel to that average. The function\
    \ localSum handles the summing the values found around the current focus, and\
    \ then we create the new pixel by dividing to get the mean. def boxFilter ( width\
    \ : Int ) : FocusedGrid [( Int , Int , Int )] => ( Int , Int , Int ) = { fg =>\
    \ val widthSqr = width * width val sum = localSum ( fg , ( 255 , 255 , 255 ),\
    \ width ) (( sum . _1 / widthSqr ). toInt , ( sum . _2 / widthSqr ). toInt , (\
    \ sum . _3 / widthSqr ). toInt ) } Here is the original image and some smoothed\
    \ examples at various box filter sizes: We can do any image transformation that\
    \ requires access to the whole image to make some per-pixel change. Here\u2019\
    s another example to mirror the image along the vertical axis. def mirrorHorizontal\
    \ ( fg : FocusedGrid [( Int , Int , Int )]) : ( Int , Int , Int ) = { val mirrorX\
    \ = ( fg . grid ( 0 ). size - 1 ) - fg . focus . _2 fg . grid ( fg . focus . _1\
    \ )( mirrorX ) } One of the benefits of functional programming is composability.\
    \ We can sequence coflatMaps and maps together to generate new images. For example\
    \ we would smooth and flip an image using focusedGrid.coflatMap(boxFilter(9)).coflatMap(mirrorHorizontal)\
    \ , which gives the following image. Comonads for (Conway\u2019s) Life Code for\
    \ this section can be found here: Conway.scala With a couple of small changes\
    \ our image processing algorithm can be put to work to simulate the zero player\
    \ game Conway\u2019s Life. See the Wiki for Conway\u2019s Life for more details.\
    \ For a TL;DR the game involves a starting grid of cells which are alive (0) or\
    \ dead (1). At each step we count the neighbours of each cell to see if it will\
    \ be alive or dead in the next generation. In order to animate the game in presentable\
    \ manner in a regular terminal we can use a combination of unicode characters,\
    \ ansi control commands and the Cats Show typeclass. implicit def focusedGridShow\
    \ [ A : Show ] = new Show [ FocusedGrid [ A ]] { def show ( fg : FocusedGrid [\
    \ A ]) : String = { fg . grid . map { row => row . iterator . map ( _ . show ).\
    \ mkString ( \"\" ) }. mkString ( \" \" ) } } We need a simple function to convert\
    \ the 0\u2019s and 1\u2019s of our life simulation with more attractive characters.\
    \ By using map to apply the prettify then showing the grid we get a more pleasing\
    \ representation than the zeros and ones. def prettify ( i : Int ) : Char = {\
    \ i match { case 1 => 0x2593 . toChar case 0 => 0x2591 . toChar } } FocusedGrid\
    \ (( 0 , 0 ), Vector ( Vector ( 1 , 1 , 1 ), Vector ( 1 , 1 , 0 ), Vector ( 0\
    \ , 0 , 0 ))). map ( prettify ). show \u2593\u2593\u2593 \u2593\u2593\u2591 \u2591\
    \u2591\u2591 Note that code for life has a slightly different implementation of\
    \ localSum which does not include the current focus point, we only want to know\
    \ about the neighbours. Apart from that the code is very similar to the image\
    \ processing example, since if we use 0 for dead and 1 for living, we can count\
    \ living neighbours using localSum . With everything in place we can implement\
    \ the core of the game of life algorithm with just a few lines of code. def conwayStep\
    \ ( fg : FocusedGrid [ Int ]) : Int = { val liveNeighbours = localSum ( fg ) val\
    \ live = getAt ( fg , fg . focus ) if ( live == 1 ) { if ( liveNeighbours >= 2\
    \ && liveNeighbours <= 3 ) 1 else 0 } else { if ( liveNeighbours == 3 ) 1 else\
    \ 0 } } Note that the function getAt here is written to handle wrapping around\
    \ the edges of the grid. Summary In this post we\u2019ve seen how monads and comonads\
    \ are related, what the operations and laws of comonads are, and how they can\
    \ be used to make useful, composable programs. References Bartosz Milewski has\
    \ this great series of posts \u201CCategories for Programmers\u201D https://bartoszmilewski.com/2017/01/02/comonads/\
    \ I came across this post by Eli Jordan when I\u2019d almost finished writing\
    \ this one and saw that he already covered a lot of the same ground; especially\
    \ interesting is his use of Store which is the Comonad version of the State monad\
    \ https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/ Read about Comonads\
    \ in the Cats API documentation https://typelevel.org/cats/api/cats/Comonad.html\
    \ From 2015, Red Book Runar has a very detailed introduction to Comonads and their\
    \ laws http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/\
    \ Otfried Cheong has a great intro to image processing with Scala, utilizing the\
    \ standard Java library http://otfried.org/scala/image.html"
  key: 2019/06/20/comonads-for-life.html
- document: "What\u2019s in this post? Why use category theory in Scala? Quick intro\
    \ to Semigroups and Monoids How to implement Monoids in Scala Using the Cats and/or\
    \ Scalaz libraries to work with Monoids An example of Monoids in production code\
    \ Testing the Monoid laws of your Monoid instances Bonus footnotes: Mini reviews\
    \ of some Functional Programming in Scala books The code for this post can be\
    \ found here: Category Theory and Scala If you\u2019ve already read a few Monoid\
    \ tutorials, you may want to skip to Monoids in Production. Lifting abstract algebraic\
    \ structures like Semigroup and Monoid from mathematics can make simple concepts\
    \ sound complicated. While it would be tempting to come up with new words that\
    \ sound more familiar, it pays for us to adopt these terms because they let us\
    \ talk precisely about the things in terms of their operations and laws. It is\
    \ useful for us to have a shared vocabulary with which we can communicate to other\
    \ programmers and our compilers, what our types can, and cannot, do. To read more\
    \ on pure functional programming in Scala some great books are: Functional Programming\
    \ in Scala , Functional Programming for Mortals and Advanced Scala with Cats .\
    \ Semigroups A semigroup is an algebra that has a binary associative operation;\
    \ a function that takes two values of the same type and combines them into a single\
    \ value. Integer addition, for example, forms a semigroup: def plus ( a : Int\
    \ , b : Int ) : Int = a + b plus ( plus ( 1 , 2 ), 3 ) //res1: Int = 6 plus (\
    \ 1 , plus ( 2 , 3 )) // res2: Int = 6 Note that as long as we don\u2019t change\
    \ the order in which the additions are performed, we get the same result. It is\
    \ this property, associativity, that makes addition with integers a semigroup.\
    \ Multiplication works the same way: def multiply ( a : Int , b : Int ) : Int\
    \ = a * b multiply ( multiply ( 1 , 2 ), 3 ) //res1: Int = 6 multiply ( 1 , multiply\
    \ ( 2 , 3 )) // res2: Int = 6 Another example that follows the Semigroup pattern\
    \ is joining strings together. Take the following strings: \"Hello\" \",\" \"\
    World\" \"!\" As long as we don\u2019t rearrange the strings, we can append them\
    \ in any order we like and get the same final result. Imagine 4 strings a,b,c\
    \ and d: a b c d ab cd abcd a b c d ab c d abc d abcd a b c d a b cd a bcd abcd\
    \ We can do the actual operation in any order and get the same result, which is\
    \ captured by the property: op(op(x,y), z) == op(x, op(y,z)) This property is\
    \ useful because we know that we can do optimisations. If we have long lists of\
    \ integers we can divide them into smaller ones, run the appends in parallel,\
    \ and then combine the results. We can use a left fold or a right fold without\
    \ worrying about the order of operations. Foldable [ List ]. foldLeft ( List (\
    \ 1 , 2 , 3 ), 0 ){ _ |+| _ } //res1: Int = 6 Foldable [ List ]. foldRight ( List\
    \ ( 1 , 2 , 3 ), 0 ){ _ |+| _ } //res2: Int = 6 Note that to fold a list we need\
    \ the list, a binary operation to combine each element, and a \u201Czero\u201D\
    \ value. Without a zero value, it\u2019s impossible to combine all the elements\
    \ of the list into an accumulator. For example, if we have a list with a single\
    \ item, the first step of the foldLeft would be: Foldable [ List ]. foldLeft (\
    \ List ( 1 ), ???){ _ |+| _ } ??? |+| 1 If we had a zero value available for the\
    \ type our semigroup is defined for, we could run a fold using that zero value\
    \ instead of passing it ourselves. The syntax would then be simply: Foldable [\
    \ List ]. fold ( List ( 1 , 2 , 3 )) //res1: Int = 6 By adding a way to get a\
    \ zero for a type, we turn a semigroup into a monoid. Monoids Although it\u2019\
    s called zero, it is not always the number zero. Zero is some value that can be\
    \ combined with other values without changing the original value. Here are some\
    \ examples: Integer addition - the zero value is actually 0 3 + 0 == 3 0 + 3 ==\
    \ 3 Integer multiplication - the zero value is now 1 3 * 1 == 3 1 * 3 == 3 Logication\
    \ or - the zero value is true true || true == true false || true == true String\
    \ append - the zero value is the empty string \u201C\u201D \"Justin\" ++ \"\"\
    \ = \"Justin\" Monoids in Scala In Scala, we can implement Monoids as a Scala\
    \ type class, a way to extend the behaviour of existing types. We will encode\
    \ its operations as a trait. Note that this is an abstract definition. We will\
    \ then define instances of Monoids that make concrete versions of the operations.\
    \ trait SemiGroup [ A ] { def op ( a : A , b : A ) : A } trait Monoid [ A ] extends\
    \ SemiGroup [ A ] { def zero : A } And a sample instance implementation: val intMultiply\
    \ = new Monoid [ Int ] { def zero = 1 def op ( a : Int , b : Int ) : Int = ( a\
    \ * b ) } intMultiply . op ( 10 , 20 ) // res1: Int = 200 intMultiply . op ( 10\
    \ , intMultiply . zero ) //res2: Int = 10 In our production code, we\u2019ll use\
    \ the Scalaz and Cats Monoid implementations instead of rolling our own. This\
    \ gives us premade instances for many common types, syntactic sugar to make working\
    \ with Monoids more concise, a bunch of useful combinators that we can use like\
    \ fold and even automated law tests that verify our own instances obey the laws.\
    \ Let\u2019s have a look at Scalaz for example: import scalaz._ , Scalaz . _ val\
    \ l1 = 10 |+| 20 |+| 30 //res1: Int = 60 Foldable [ List ]. fold ( List ( 10 ,\
    \ 20 , 30 )) //res2: Int = 60 In the example we first use the Monoid combine function\
    \ using the syntax helper |+| and in the second we use the Scalaz foldable instance\
    \ for list to do the same job. There is a Monoid instance defined for integer\
    \ that implements addition, so that is used. We could also define multiplication\
    \ (or any other associative operation) and use that instead. For example, Scalaz\
    \ has a Tag feature which lets us change the datatype of a thing at compile time\
    \ only, and it can then pick up a different monoid implementation. Tags.Multiplication\
    \ is a tag for numbers that has a Monoid instance that multiplies: l1 . foldMap\
    \ { a => Tags . Multiplication ( a )} // res3: Int @@ Tags.Multiplication = 6000\
    \ Note that we use foldMap instead of fold here because we need to map a function\
    \ over the list to add the multiplication tag. We could also just put a locally\
    \ scoped implicit monoid for multiplication, but that would break type class coherence.\
    \ See FP for Mortals for more on Tags and type class coherence. In Cats there\
    \ is no Tags mechanism so you must find other ways to get your alternate implementations\
    \ in scope. Finally one more example from my sample code MaxMonoid.scala , a Monoid\
    \ instance for the maximum of two numbers: import scalaz.Foldable import scalaz.Monoid\
    \ import scalaz.std.list._ import scalaz.syntax.semigroup._ implicit val maxIntMonoid\
    \ : Monoid [ Int ] = Monoid . instance [ Int ]({ case ( a : Int , b : Int ) =>\
    \ Math . max ( a , b )} , Int . MinValue ) val testAppend = 10 |+| 20 // res1:\
    \ 20 Scalaz provides a function instance that takes two arguments; the combine\
    \ operation and the zero value for a type, so we can easily define a new Monoid\
    \ instance. Note that we can\u2019t import all of scalaz._ like we did before\
    \ because we don\u2019t want to bring in the instance for Monoid[Int] . Once defined\
    \ we can then use the fold over a list to find the max: val l1 = List [ Int ](\
    \ 1 , 2 , 3 , 4 , 5 , 4 , 3 , 2 , 1 ,- 10 , 1 , 2 , 3 ) Foldable [ List ]. fold\
    \ ( l1 ) // res1: 5 Take a look at this post by Adam Warksi at Software Mill for\
    \ more examples of Monoids and what you can do with fold: https://softwaremill.com/beautiful-folds-in-scala/\
    \ Monoids in Production You already know how to append strings and add numbers,\
    \ why bother with all this fancy abstraction? Well, first of all we saw above\
    \ how having a Monoid implementation enables us to use a wider range of combinators\
    \ like folds and traversals; our intentions are made clearer with less code. When\
    \ it comes to our application business objects, that may have more complicated\
    \ append methods and be nested in multiple data structures, we can see that the\
    \ expressive power of Monoids is a great advantage over an imperative solution.\
    \ Let\u2019s take a look at a real example. Taking Inventory Image from Madlands\
    \ - a former online iOS and Android game In many MMOG (massively multiplayer online\
    \ games) you manage a city that contains plots of farmland that produce food,\
    \ oil and so on. On the backend we need to store the things that the player owns\
    \ in a database. When in memory we represent the inventory as a map, where the\
    \ keys are the types of resources we own, and the values are the quantity. For\
    \ example we represent the players\u2019 resources using integer ids: Oil Gold\
    \ Corn A player with just some gold would have an inventory like this: import\
    \ cats._ import cats.data._ import cats.implicits._ val inventory = Map ( 2 ->\
    \ 1000 ) Imagine that the player buys 1000 Oil and 1000 Corn and this will cost\
    \ 200 gold. We could write some code that iterates over the players\u2019 inventory\
    \ map and updates the new values, create new keys as necessary for items the player\
    \ didn\u2019t have. But fortunately because there is a Monoid instance for Map,\
    \ we can simply combine the player inventory map with the purchases and costs\
    \ map to get the new inventory: val updatedInventory = inventory . combine ( Map\
    \ ( 1 -> 1000 )). combine ( Map ( 3 -> 1000 )). combine ( Map ( 2 -> - 200 ))\
    \ //res2: Map(1 -> 20, 2 -> 600, 3 -> 20) In this example we reduced the gold\
    \ by 200 and granted the player 1000 of two types of resources. In fact we could\
    \ simplify to just adding two maps together: val updatedInventory = inventory\
    \ |+| Map ( 1 -> 1000 , 3 -> 1000 , 2 -> - 200 ) //res3: updatedInventory: Map[Int,\
    \ Int] = Map(1 -> 1000, 3 -> 1000, 2 -> 800) The implementation of Map for Monoid\
    \ gathers togethers the values with the same key and appends them with Monoid,\
    \ meaning anything with a Monoid can be combined. Map ( 1 -> \"Hello\" ) |+| Map\
    \ ( 1 -> \" \" ) |+| Map ( 1 -> \"World\" ) //res1: Map(1 -> \"Hello World\")\
    \ We can also fold it like this: Foldable [ List ]. fold ( List ( Map ( 1 -> \"\
    Hello\" ), Map ( 1 -> \" \" ), Map ( 1 -> \"World\" ))) //res1: Map[Int, String]\
    \ = Map(1 -> \"Hello World\") Produced Items We stored the players inventory as\
    \ a Map, and we can easily use Monoids to perform operations on inventories as\
    \ well as lists of items and currencies. But also in our game the players had\
    \ resources that increased or decreased over time. For example if you have a Level\
    \ 1 Oil drill it produces oil at 10 units an hour. Over 10 hours it would accumulate\
    \ 100 units of oil. What we don\u2019t want to do is have to constantly update\
    \ the players production item count at some discrete interval. For one, that would\
    \ be very costly on our servers, and for another we may want to show the resources\
    \ increasing or decreasing in real time on the client. In order to model this\
    \ we can simply store the starting amount (this will be zero for a new oil drill),\
    \ and the players rate of production. We also store the time the production began\
    \ (when the oil drill is built). With these three variables we can always calculate\
    \ the current amount of the resource by the simple formula: current_amount = initial_amount\
    \ + (time_passed * production_rate) Storing production items in this way means\
    \ we can calculate the current value at any time to display it. Note that we can\
    \ adjust the initial amount whenever we want by a positive or negative amount,\
    \ and things will work out. But if we change the production rate then we need\
    \ to update a few things. Firstly we calculate a new initial amount (the current\
    \ amount from the calculation above). Then we store the current time, and adjust\
    \ the production rate to the new one. Whilst this is all straightforward, it complicates\
    \ the adding and removing of items from the players inventory. We want to be able\
    \ to remove 200 gold and add some resources just as we did before, and ideally\
    \ we shouldn\u2019t have to worry about things like what time it is and production\
    \ rates. Of course the solution is to model this by creating a Monoid instance\
    \ for produced items, and that is what we did. There are two implementations and\
    \ two demo programs to show the Scalaz and Cats implementations which have minor\
    \ differences and caveats. case class ProducedItem ( snapshotAmount : Long , snapshotTime\
    \ : Long , amountPerHour : Double ) { def currentAmount ( implicit clock : Clock\
    \ ) = snapshotAmount + ((( clock . currentTimeMillis - snapshotTime ) / Clock\
    \ . oneHourMillis ) * amountPerHour ). toLong } Here you can see the amount and\
    \ time of the last snapshot as well as the production rate amountPerHour . The\
    \ player\u2019s current amount is no longer a static field, but a function that\
    \ calculates the current amount based on the snapshot data. Note that we are passing\
    \ in a Clock object implicitly. We\u2019ll see why later but for now you just\
    \ need to know that a clock is a datatype that lets us get the time so we can\
    \ make the calculation. implicit def monoidProducedItemOps ( implicit clock :\
    \ Clock ) = new Monoid [ ProducedItem ] { def empty = ProducedItem ( 0 , 0 , 0\
    \ ) def combine ( p1 : ProducedItem , p2 : ProducedItem ) : ProducedItem = { val\
    \ p1A = p1 . currentAmount val p2A = p2 . currentAmount ProducedItem ( p1A + p2A\
    \ , clock . currentTimeMillis , Math . max ( Math . abs ( p1 . amountPerHour ),\
    \ Math . abs ( p2 . amountPerHour ))) } } Next we implement the Monoid instance\
    \ for our new data type. The zero function is simply a ProducedItem with a snapshot\
    \ at time zero, zero amount of stuff and zero production rate. While the combine\
    \ (or append for scalaz) function is a bit more involved. It must calculate the\
    \ current amount of both ProducedItem s. The new snapshot value will be the sum\
    \ of those p1A + p1A . The new time snapshot will be right now, which we get from\
    \ the clock, and the new production rate is simply the production rate with the\
    \ most magnitude. Just to explain that a little; in our use case production items\
    \ always have the same production rate for the same player. Whenever the production\
    \ rate changes for an item, we update all items of that type. So typically we\
    \ will always have the same value on each side of a produced item type. However\
    \ the zero value has no way to know the production rate, so simply taking the\
    \ biggest one does what we need. You need to pay attention to details like this\
    \ on your own Monoid instances to make sure the combine operation makes sense\
    \ with respect to your business logic. Now we have all we need to start adding\
    \ ProducedItems (there are example programs in the source code, or you can do\
    \ the following at the Scala console to try it out). import cats.syntax.monoid._\
    \ import cats.instances.map._ import org.justinhj.production._ import org.justinhj.production.productioncats.ProducedItem\
    \ import org.justinhj.production.productioncats.ProducedItem._ implicit val clock\
    \ = FixedClock ( System . currentTimeMillis + Clock . oneHourMillis ) val now\
    \ = clock . currentTimeMillis val inventory1 = Map ( 1 -> ProducedItem ( 10 ,\
    \ now - Clock . oneHourMillis , 10 ), 2 -> ProducedItem ( 10 , now - Clock . oneHourMillis\
    \ , 5 )) val inventory2 = Map ( 1 -> ProducedItem (- 5 , 0 , 0 ), 2 -> ProducedItem\
    \ (- 5 , 0 , 0 ), 3 -> ProducedItem ( 1 , 0 , 0 )) val inventory3 = Map ( 3 ->\
    \ ProducedItem ( 1 , 0 , 0 )) val addInventories = inventory1 |+| inventory2 |+|\
    \ inventory3 // addInventories: Map[Int, ProducedItem] = Map( // 1 -> ProducedItem(15L,\
    \ 1560220015450L, 10.0), // 2 -> ProducedItem(10L, 1560220015450L, 5.0), // 3\
    \ -> ProducedItem(2L, 1560220015450L, 0.0) Now we can easily combine our ProducedItem\
    \ structures, and of course we now use other combinators like fold: import cats.Foldable\
    \ import cats.instances.list._ val listOfInventories = Foldable [ List ]. fold\
    \ ( List ( inventory1 , inventory2 , inventory3 )) // listOfInventories: Map[Int,\
    \ ProducedItem] = Map( // 2 -> ProducedItem(10L, 1560220015450L, 5.0), // 1 ->\
    \ ProducedItem(15L, 1560220015450L, 10.0), // 3 -> ProducedItem(2L, 1560220015450L,\
    \ 0.0) // ) The test of time As promised we return to the Clock data type. This\
    \ is implemented in production.Clock.scala and provides the following simple function\
    \ to get the time: trait Clock { def currentTimeMillis : Long } There are two\
    \ implementations; firstly there is a SystemClock, so called because it returns\
    \ the system time. This one will be used in production so that your players corn\
    \ grows correctly. The second is FixedClock which always returns the same time.\
    \ This is to make testing easier. We want to be able to start our corn growing\
    \ then check if it grew the right amount an hour later, and of course we don\u2019\
    t want the tests to run in real time. To get around this if you check my test\
    \ classes such as org.justinhj.production.ProducedItemTestCats you can see that\
    \ I that I make a fixed time clock with the current time and then set my test\
    \ items to have a snapshot time of one hour ago. Having strict control over time\
    \ like this is vital to testing time and date related logic in a principled way.\
    \ implicit val clock = FixedClock ( System . currentTimeMillis ) val now = clock\
    \ . currentTimeMillis val pi = ProducedItem ( 10 , now - Clock . oneHourMillis\
    \ , 10 ) Checking Monoids are lawful The beauty of functional programming is we\
    \ can build up solid foundations like this, and then go ahead and compose more\
    \ complex programs from our simple lawful data types. But one caveat, did we implement\
    \ a lawful Monoid? In order to make sure, I have include tests in both Scalaz\
    \ and Cats style to show you how to use each library\u2019s law checking facilities.\
    \ In this example we will use Cats. Instructions for this are here https://typelevel.org/cats/typeclasses/lawtesting.html\
    \ but you can also follow my working example in the code. class ProducedItemLawTestsCats\
    \ extends CatsSuite { implicit val clock = FixedClock ( System . currentTimeMillis\
    \ + Clock . oneHourMillis ) checkAll ( \"ProducedItem.MonoidLaws\" , MonoidTests\
    \ [ ProducedItem ]. monoid ) } With the correct imports and library dependencies\
    \ you can now access MonoidTests[ProducedItem].monoid which will contain tests\
    \ for each of the Monoid laws. It will in addition use Scalacheck to generate\
    \ many random instances of your classes to give thorough empirical testing of\
    \ whether the laws hold. Of course this check will not guarantee that your laws\
    \ hold but it will certainly help you feel confident. Ultimately Scala leaves\
    \ it as an exercise to the programmer to ensure that the laws are valid and automated\
    \ testing is no substitute for your own reasoning. Note that in order to generate\
    \ the tests we need an Eq instance for our data type which allows them to be tested\
    \ for equality. We can automatically generate one that just compares each field\
    \ of the class: implicit val eqProducedItem : Eq [ ProducedItem ] = Eq . fromUniversalEquals\
    \ Now we can run our test suite and bask in the glory of our own brilliance\u2026\
    \ [info] - ProducedItem.MonoidLaws.monoid.left identity *** FAILED *** [info]\
    \ GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.\
    \ [info] (Discipline.scala:14) [info] Falsified after 0 successful property evaluations.\
    \ [info] Location: (Discipline.scala:14) [info] Occurred when passed generated\
    \ values ( [info] arg0 = ProducedItem(4960954082650183831,1,1.5706606739076523E-208)\
    \ [info] ) [info] Label of failing property: [info] Expected: ProducedItem(4960954082650183831,1,1.5706606739076523E-208)\
    \ [info] Received: ProducedItem(4960954082650183831,1560221194037,1.5706606739076523E-208)\
    \ Oh, no! What happened? It seems our laws do not hold, for left and right identity\
    \ and other things besides. After a little thought it becomes clear, when we combine\
    \ a ProducedItem with the zero value it should not change the original item. val\
    \ now = 1560221355576L val oneHourAgo = 1560217755576L ProducedItem ( 10 , oneHourAgo\
    \ , 10 ) |+| Monoid [ ProducedItem ]. empty // ProducedItem = ProducedItem(20L,\
    \ 1560221355576L, 10.0) Clearly, we can see that this is not correct. When we\
    \ combined the two items we took a new snapshot and the time changed to now! So\
    \ we changed the equality from true to false and broke the identity laws. At the\
    \ beginning of this exercise we came up with a data structure that helps us represent\
    \ items that increase or decrease over time, and in doing so we introduced these\
    \ new variables. On the other hand from a business logic point of view, two produced\
    \ items are the same if (and only if) their current amounts are the same. We don\u2019\
    t care about production rate or snapshot time or event current snapshot value.\
    \ Let\u2019s rewrite our equals check to take this insight into account: implicit\
    \ def eqProducedItem ( implicit clock : Clock ) = new Eq [ ProducedItem ] { def\
    \ eqv ( x : ProducedItem , y : ProducedItem ) : Boolean = { x . currentAmount\
    \ == y . currentAmount } } And rerunning the tests we can see the tests are now\
    \ all green! [info] ProducedItemLawTestsCats: [info] - ProducedItem.MonoidLaws.monoid.associative\
    \ [info] - ProducedItem.MonoidLaws.monoid.collect0 [info] - ProducedItem.MonoidLaws.monoid.combine\
    \ all [info] - ProducedItem.MonoidLaws.monoid.combineAllOption [info] - ProducedItem.MonoidLaws.monoid.is\
    \ id [info] - ProducedItem.MonoidLaws.monoid.left identity [info] - ProducedItem.MonoidLaws.monoid.repeat0\
    \ [info] - ProducedItem.MonoidLaws.monoid.repeat1 [info] - ProducedItem.MonoidLaws.monoid.repeat2\
    \ [info] - ProducedItem.MonoidLaws.monoid.right identity Check the Scalaz tests\
    \ to see very similar code in action. The End This has been a small sample of\
    \ how Monoids can help simplify your code, and make it more composable. Thank\
    \ you for reading this post, please let me know via the links at the top if you\
    \ have any questions or comments! For more reading on Monoids check the books\
    \ below. I also highly recommend this conference talk by Markus Haulck that shows\
    \ some nice composition tricks Monoids When Everything Fits: The Beauty of Composition\
    \ - Markus Hauck"
  key: 2019/06/10/monoids-for-production.html
- document: 'What''s the problem? Well there are two problems here. For one many readers
    may be saying "What? Surely a monad is a just a monoid in the category of endofunctors!"
    Perhaps another group are completely lost. Well the famous quote about monads
    is absolutely right, but that is a different way to arrive at Monads than the
    simpler one we are looking at here. Instead we will arrive at Monads by making
    a simple change to the Category of Scala types and functions. The only change
    we will make is instead of Scala functions of the form A => B we will instead
    use what is known as a Kliesli arrow, which has the form "A => F[B] . You may
    recognize that shape of function from the argument to Scala''s flatMap. In other
    words it is the type of function that maps a pure value to an effectful value.
    Let''s look at how we can encode this new category directly in Scala as a monad!
    Note I will call the Monad type class Monad1 to avoid confusion with the more
    usual Monad definition in the code. trait Monad1 [ F [ _ ]] : def unit [ A ](a
    : A ) : F [ A ] def compose [ A , B , C ](lf : A => F [ B ], rf : B => F [ C ])
    : A => F [ C ] In the definition above we have all we need to implement the category
    of Scala objects and Kliesli arrows (and incidentally this is, by definition,
    a monad). Firstly what are the objects? Just like before the objects are Scala
    types. Next what are the morphisms? We stated the morphisms would be of the form
    A => F[B] . Finally what is the identity? The identity has the same form as any
    other morphism except that it maps a type to itself, so the identity is A => F[A]
    . We can implement that in Scala with the unit function above. With Scala functions
    we used the compose function. Here we need to write our own code that composes
    two Kleisli arrows returning a new one. This is the direct analog of the compose
    function that works with simple functions. For convenience, just like with any
    other Scala 3 type class we need a way to summon a Monad of a particular type
    into existence and for that we write the apply function as follows.'
  key: 2021/02/02/monads-in-scala-3-for-the-genius.html
- document: 'The following code implements an arithmetic expression evaluator using
    the Numeric type class developed in a previous video and adds error handling by
    using Either. Each step of our evaluator has this signature. type WithEnv [ A
    ] = Env [ A ] ?=> Either [ EvalError , A ] Which means it is a function takes
    an input environment (our symbol table) as an implicit argument, and returns an
    Either where the error (or Left) type is EvalError. EvalError represents the different
    errors our code will handle. It is a sum type implemented as a Scala 3 enum (seen
    in a previous video). enum EvalError { case InvalidSymboName case SymbolNotFound
    } In previous blogs/videos I showed how we can implement a Numeric instance so
    we can do arithmetic on many different types, just so long as we create an instance
    of Numeric to handle them. Now we must implement Numeric for the following type
    Numeric[Either[EvalError, A]] . The instance signature is given evalResultNumeric[
    A : Numeric ] : Numeric [ Either [ EvalError , A ]] with { Now we must implement
    the methods of Numeric. Because our numeric values are inside the EvalResult (an
    Either) we can''t just implement the multiply directly. We need a way to get inside
    it. As we saw in the previous blog/video, Functor gives us a way to apply a pure
    function to an effect. Since mul is a pure function, maybe we can use it? def
    mul (a : EvalResult [ A ], b : EvalResult [ A ]) : EvalResult [ A ] = { a.fmap
    { // DOES NOT COMPILE, WRONG TYPE aa => b.fmap { bb => aa * bb } } } Note I am
    using the name fmap and fflatMap to make it clear we are not using the standard
    library implementations here. This is just for clarity but is not a good practise
    because, for example, you will lose the ability to use for comprehensions. What
    went wrong here is that Functor''s map operation has the signature extension [
    A , B ](x : F [ A ]) def ffmap (f : A => B ) : F [ B ]'
  key: 2021/01/21/functional-error-handling-with-applicative-in-scala-3.html
- document: 'You may not really think of it as Category Theory, but whenever you map
    an Either you are using Functors! The Haskell documentation is a nice place to
    learn about Functors. If you think of a normal pure function as a mapping of values
    from A to B, a Functor can map values that have been embellished, or wrapped in
    some special data type. https://wiki.haskell.org/Functor Helpfully, the kind folks
    behind Scala 3 have added how to implement type classes to their documentation.
    We can use that a starting point to build our own Functor and then make an instance
    that works with Eithers. trait Functor [ F [ _ ]] : extension [ A , B ](x : F
    [ A ]) def ffmap (f : A => B ) : F [ B ] This is all we need to define a Functor
    type class that can extend supported types with a map function. Note that I''ve
    added an f to differentiate the function from the built in map. Then I added another
    f by mistake, don''t tell anyone, they might not notice! Before we can use this
    against an Either we need to implement an instance of the typeclass. Remember
    that Functor needs a type of kind F[_] . It has one "type hole". Either has two,
    which is not going to work, so let''s start by specialising to Either with only
    a fixed error type of String. First we make a type alias that reduces the Either
    to one unknown type, the computation result type A . Next we provide an implementation
    of ffmap that does the work of mapping our pure function over an Either. Note
    that this is roughly the same as the pure function. Instead of A => B we are mapping
    F[A] => F[B] where F is the Either. type StringEither [ A ] = Either [ String
    , A ] given Functor [ StringEither ] with extension [ A , B ](x : StringEither
    [ A ]) def ffmap (f : A => B ) : StringEither [ B ] = { x match { case Right (
    a ) => Right (f(a)) case Left ( err ) => Left (err) } } Let''s try it out. val
    e1 : Either [ String , Int ] = Right ( 10 ) val e2 : Either [ String , Int ] =
    Left ( "Oops" ) val e3 = e1.ffmap(a => a + 1 ) // Right(11) val e4 = e2.ffmap(a
    => a + 1 ) // Left("Oops") We can now apply pure functions to Eithers with String
    error types. Where we want to get to is to be able to apply pure functions to
    Either[Error,Numeric[A]] so we''re not quite there yet. The first problem is that
    we can''t handle the Error type that I want to use in my expression evaluator,
    we can only handle String. Well we can just make another instance of Functor for
    Either[Error,A] ? Well, yes we could, but how about we make a generic instance
    of Functor for all Eithers? To do that we need to use type lambdas. These were
    available in Scala 2 but are greatly simplified in Scala 3. https://dotty.epfl.ch/docs/reference/new-types/type-lambdas.html
    Here''s the new instance for Functor with some notable changes. 1: given eitherFunctor[
    E ] : Functor [[ A ] =>> Either [ E , A ]] with 2: extension [ A , B ](x : Either
    [ E , A ]) 3: def ffmap (f : A => B ) : Either [ E , B ] = { 4: x match { 5: case
    Right ( a ) => Right (f(a)) 6: case Left ( err ) => Left (err) 7: } 8: } Line
    1 is where the action is. First note that we named the given instance eitherFunctor
    . Our previous instance had no name. You can leave the name out, but it''s not
    recommended, especially for libraries, since it makes the code easier to work
    with. See also that the instance itself takes parameter E which will represent
    our error type. Next the instance of Functor is for the type [A] =>> Either[E,
    A] which is our type lambda. It means please give me a type that has a single
    parameter A but that will be substituted into the Either[E,A] in a way that is
    similar to how parameters are substituted into a lambda function. val e1 : Either
    [ String , Int ] = Right ( 10 ) val e2 : Either [ Int , Int ] = Left ( 1 ) val
    e3 = e1.ffmap(a => a + 1 ) // Right(11) val e4 = e2.ffmap(a => a + 1 ) // Left(1)
    Now we can map over any type of Either! As you can see in the first case the pure
    function mapped over the A. In the second case the pure function was not executed
    and the error value is simply passed along.'
  key: 2021/01/06/handling-errors-functionaly-with-scala-3.html
- document: 'Zio Prelude is a new library that acts as a sort of add on library to
    ZIO (a zero-dependency Scala library for asynchronous and concurrent programming)
    which provides an alternative approach to functional abstractions in Scala. For
    the purposes of this blog I''m interested in particular experimental data type
    within the library called ZPure . ZPure has 6 type parameters and supports the
    operations of monads, applicatives and functors, albeit the names are changed
    and some of the abstractions too. From Prelude''s own source code " ZPure can
    be used to model a variety of effects including context, state, failure, and logging.",
    let''s see how it compares to monad transformers to implement the program above.
    ZPure has six type parameters, which may seem like a lot, but bear in mind that
    every time you combine monads you get more type parameters, but they are stacked
    vertically not horizontally. With ZPure you start with all the different effect
    types one might need but you don''t need to keep adding more and more, and you
    don''t suffer from creating multiple objects per layer of effect. In the diagram
    the parameters are. W Logging. The type of logs that this effect produces, analogous
    to Writer Logging. The type of logs that this effect produces, analogous to Writer
    S State. There are two S''s because the type encodes an input and output state
    type State. There are two S''s because the type encodes an input and output state
    type R Reader. The type of the read-only environment Reader. The type of the read-only
    environment E Error. The type of the error channel Error. The type of the error
    channel A Value. The type of the happy path computed value Just as before all
    I need to do is change my programs effect type and modify the implementation accordingly.
    The code for this section can be found here. Although Prelude supports Scala 3
    now I rewrote my program in Scala 2 in order to do the Scalaz and Cats versions,
    so the following is also pre Scala 3 friendly code. First I made a sealed trait
    to represent the error types and an alias to indicate that my log will be strings.
    Note that ZPure is opinionated about the logging type. In the more conventional
    approach, the log has to be a monoid instance. With ZPure the log is handled using
    the ZIO Chunk data type which is a high-performance data structure with a pure
    functional interface. What that means for us is that we can consider our log type
    as a single entity and not worry about how it is appended. sealed trait Error
    object SymbolNotFound extends Error object DivisionByZero extends Error type Log
    = String These types will represent the E or error, and W or log. We can encode
    our symbol table using the R parameter. type Env [ A ] = Map [ String , A ] The
    final type looks like this. type Result [ A ] = ZPure [ Log , Any , Any , Env
    [ A ], Error , A ] Note that I am not using the initial or updated state here
    so I use Any for those parameters so as not to constrain them. Once again let''s
    start with the implementation of literal values. case Val ( value ) => ZPure .succeed(value).log(s
    "Literal value $value " ) What''s going on here is simple and refreshingly free
    of type annotation. Firstly I construct a ZPure consisting of the literal value,
    and then add a log using ZPure''s log method. Now let''s implement the symbol
    table lookup of variables. 1: def handleVar [ A : Numeric ](s : String ) : Result
    [ A ] = { 2: ZPure .environment[ Any , Env [ A ]].flatMap { 3: env => 4: ZPure
    .fromOption(env.get(s)). 5: mapError( _ => EvalZPure . SymbolNotFound ). 6: flatMap{
    7: a => 8: ZPure .log(s "Var $s value $a " ). as (a) 9: } 10: } 11: } First I
    use the ZPure.environment to summon the symbol table and flatMap over it so we
    can access it as a concrete value env . Remember that looking up the variable
    in the symbol table is going to return an Option since it is a normal map get.
    We can then use the ZPure.fromOption to convert that to a ZPure. We may be a ZPure
    at that point but we have the wrong error type. In ZPure and option is simulated
    by yielding a success value A for Some, or giving Unit in the error channel to
    indicate None. This reuse of the error channel is neat, but since I would like
    a homogenous error type for the program I need to convert that error channel from
    unit to my own custom Error type. To do that I use mapError which takes a function
    to map the error from one type to another. The final step is to add a log. Since
    I would like the log to show both the variable name and the actual value I have
    to nest it inside a flatMap so we can access the success value. The last thing
    to note here is the as which helps the type system make a ZPure of the right type.
    implicit def numericZResult [ A : Numeric ] : Numeric [ Result [ A ]] = new Numeric
    [ Result [ A ]] { def add (x : Result [ A ], y : Result [ A ]) : Result [ A ]
    = { x.zip(y).flatMap{ case ( a , b ) => ZPure .succeed(a + b).log(s "Add $a and
    $b " )} } // and so on The final component is to make an instance of Numeric.
    Prelude takes the approach to naming that concepts should be plain English where
    possible, so it uses succeed instead of pure or unit and similarly zip instead
    of applicative terminology. That being the case, we use zip here to combine the
    left and right side effects and apply the appropriate arithmetic operator. So
    far so good, but we can''t log the result of the computation. This is easily solved.
    def add (x : Result [ A ], y : Result [ A ]) : Result [ A ] = { x.zip(y).flatMap{
    case ( a , b ) => { val result = a + b ZPure .succeed(result).log(s "Add $a and
    $b ( $result )" )} } } The last part to note is the driver code to run the program.
    val eval1 = eval(exp1).provide(env1).runAll() eval1._2 match { case Right ( value
    ) => println(s "Succeeded with value ${value._2} " ) eval1._1.foreach { l => println(l)
    } case Left ( err ) => println(s "oops! $err " ) } Here I run eval to create the
    effect, provide to give it the runtime environment and runAll. To be clear what
    eval does is not run a program, but build a data structure of objects based on
    the ZPure operations, and that data structure is evaluated in Prelude using an
    efficient interpreter, that yields the result of the program, the log and any
    state changes. Succeeded with value 200 Literal value 10 Var x value 1 Mul 10
    with 1 (10) Var y value 10 Mul 10 with 10 (100) Var z value 100 Add 100 and 100
    (200)'
  key: 2021/06/04/monad-transformers-the-prelude-to-zpure.html
- document: Org is a mode for keeping notes, maintaining TODO lists, and project planning
    with a fast and effective plain-text system. Like most things in the Emacs world,
    this description of Org mode belies the true depth of what it can do. Mostly I
    use Org mode only superficially as a way to track notes and projects, using it
    as a tree of tasks and the status of each. However, Org mode is good at many other
    tasks, not least of those is authoring content. I write most of the posts in this
    blog using markdown, but since I am in Emacs anyway and Org mode is a much richer
    authoring tool I decided to give it a go. Another thing that motivated the change
    was Sam Halliday's book Functional Programming for Mortals which is written entirely
    in Org mode. As well as as having no problem with code, images and text, the book
    even embeds DOT (graph description language) to define and render diagrams inline
    in the org manuscript. Just a heads up, I host the blog (at the time of writing)
    on Github Pages which uses Jekyll, a static site generator ideal for blogs and
    other content creation. Some of the information here is not relevant if you don't
    use Jekyll, but you can still use these steps to generate HTML and upload that
    to your site. I followed the steps in this post on Using org to Blog with Jekyll
    with some modifications to get everything working.
  key: 2020/03/09/how-to-blog-with-org-mode.html
- document: "One often wants to execute a sequence of commands and collect the sequence\
    \ of their responses, and indeed there is such a function in the Haskell Prelude\
    \ (here specialised to IO) sequence :: [IO a ] \u2192 IO [a ] sequence [ ] = return\
    \ [ ] sequence (c : cs) = do x \u2190 c xs \u2190 sequence cs Before we get started,\
    \ if you're following along in your Scala IDE or REPL you will need some imports\
    \ listed below. You can also clone the Github repository. import zio. _ import\
    \ zio.console. _ import zio.clock. _ import zio.duration. _ import cats. Applicative\
    \ import cats.implicits. _ \u2026 and the following libraries \u2026 libraryDependencies\
    \ ++= Seq ( \"org.typelevel\" %% \"cats-core\" % \"2.1.1\" , \"dev.zio\" %% \"\
    zio\" % \"1.0.0-RC18\" ) I am using ZIO in place of Haskell's IO Monad, and bringing\
    \ in Cats to use its Applicative. Converting the sequence function from Haskell\
    \ to Scala\u2026 def monadicSequence [ Z , E , A ](ios : List [ ZIO [ Z , E ,\
    \ A ]]) : ZIO [ Z , E , List [ A ]] = { ios match { case Nil => zioApplicative.pure(\
    \ List .empty[ A ]) case c :: cs => for ( x <- c; xs <- monadicSequence(cs) )\
    \ yield (x +: xs) } } If you're not familiar with ZIO you can think of it as a\
    \ replacement for the standard library Scala Future , but it has better performance\
    \ and a lot more features. It is also not eagerly evaluated like Future. To explain,\
    \ when you create a future it runs immediately and you cannot run it again. You\
    \ can create a ZIO and run it when you decide to and as many times as you want.\
    \ To demonstrate this sequence running let's write an implementation of a silly\
    \ algorithm called Sleep Sort. Sleep Sort works by waiting an amount of time based\
    \ on the value of the number. Emitting the numbers in this way sorts them (assuming\
    \ your scheduler is accurate enough). Let's be clear, this is a stupid way to\
    \ sort numbers, but it's handy as a way to illustrate our monadicSequence function.\
    \ def delayedPrintNumber (s : Int ) : ZIO [ Console with Clock , String , Int\
    \ ] = { putStrLn(s \"Preparing to say number in $s seconds\" ) *> putStrLn(s \"\
    \ $s \" ).delay(s.seconds) *> ZIO .succeed(s) } val ios1 = List ( 6 , 5 , 2 ,\
    \ 1 , 3 , 8 , 4 , 7 ).map(delayedPrintNumber) // ios1: List[ZIO[Console with Clock,String,Int]]\
    \ The function creates an IO effect, which when run will immediately print a message\
    \ and then wait s seconds before printing the number. We map the function across\
    \ a list of numbers to generate a list of IO effects, which we can then run. You\
    \ may be surprised that this does not work. Instead of running all the effects\
    \ at once and printing them out in order it just executes the first IO (wait 6\
    \ seconds), then the second (wait 5 seconds). Monadic version Preparing to say\
    \ number in 6 seconds 6 Preparing to say number in 5 seconds 5 // ... and so on\
    \ for a while If you were not surprised maybe you're ahead of me, and know that\
    \ our monadicSequence function cannot possibly run all the effects at once by\
    \ virtue of it being monadic in the first place. That for comprehension is really\
    \ hiding that we are calling flatMap on each successive IO, and flatMap sequences\
    \ things together. You must wait for the result of the first effect before you\
    \ can evaluate the second. So whilst the first implementation of sequence in the\
    \ paper will absolutely work, it will not let us implement our sleep sort, nor\
    \ let us parallelize the IO's in general. Back to the paper, at this point the\
    \ authors observe\u2026 In the (c : cs) case, we collect the values of some effectful\
    \ computations, which we then use as the arguments to a pure function (:). We\
    \ could avoid the need for names to wire these values through to their point of\
    \ usage if we had a kind of \u2018effectful application\u2019. By effectful application\
    \ they are talking about the ap function, and they go on to say that it lives\
    \ in the Haskell Monad library. Given that function they rewrite the sequence\
    \ function as follows\u2026 sequence :: [IO a ] \u2192 IO [a ] sequence [ ] =\
    \ return [ ] sequence (c : cs) = return (:) \u2018ap\u2018 c \u2018ap\u2018 sequence\
    \ cs Except for the noise of the returns and aps, this definition is in a fairly\
    \ standard applicative style, even though effects are present. Note that the ap\
    \ they are using here is in the Monad library, and implemented using flatMap,\
    \ so it will not yet allow our sleep sort to work. However, I've implemented an\
    \ Applicative instance for ZIO which does not have that limitation\u2026 implicit\
    \ def zioApplicative [ Z , E ] = new Applicative [ ZIO [ Z , E ,?]] { def pure\
    \ [ A ](x : A ) = ZIO .succeed(x) def ap [ A , B ](ff : ZIO [ Z , E , A => B ])(fa\
    \ : ZIO [ Z , E , A ]) = { map2(ff, fa){ (f,a) => f(a) } } override def map2 [\
    \ A , B , C ](fa : ZIO [ Z , E , A ], fb : ZIO [ Z , E , B ])(f : ( A , B ) =>\
    \ C ) : ZIO [ Z , E , C ] = { fa.zipPar(fb).map{ case ( a , b ) => f(a,b)} } }\
    \ It's not important to understand all the details here, all you need understand\
    \ is we now have an ap that we can apply to ZIO effects that is truly parallel,\
    \ so if you're not interested then skip to the next paragraph. The pure function\
    \ is straightforward, it just wraps a pure value in a succeeded ZIO. The ap function\
    \ is more interesting. Whilst it's not obvious how you would implement ap in for\
    \ ZIO, it is really easy to implement map2 . map2 comes in handy because it lets\
    \ you take the results of two effects and pass them to a pure function. The function\
    \ has the signature f: (A, B) => C . We use the ZIO function zipPar to execute\
    \ the two effects in parallel, and if both fa and fb yield values then they are\
    \ mapped with the pure function giving us a ZIO with the final result inside.\
    \ Happily, you can implement ap in terms of map2, so that solves our problem.\
    \ Here's the conversion of the applicative version of sequence to Scala\u2026\
    \ def applicativeSequence [ Z , E , A ](ios : List [ ZIO [ Z , E , A ]]) : ZIO\
    \ [ Z , E , List [ A ]] = { ios match { case Nil => ZIO .succeed( List .empty[\
    \ A ]) case c :: cs => val ff : ZIO [ Z , E , A => ( List [ A ] => List [ A ])]\
    \ = zioApplicative.pure(((a : A ) => (listA : List [ A ]) => a +: listA)) val\
    \ p1 = ff.ap(c) p1.ap(applicativeSequence(cs)) } } It's a little bit noisier than\
    \ the Haskell code, but most of that is having to be more verbose about the types\
    \ to keep the type checker happy. In fact the parts of each implementation match\
    \ up together. Now we can run that and you will see that the effects are now parellelised\
    \ and our sleep sort works! Applicative version Preparing to say number in 6 seconds\
    \ Preparing to say number in 2 seconds Preparing to say number in 1 seconds Preparing\
    \ to say number in 3 seconds Preparing to say number in 8 seconds Preparing to\
    \ say number in 4 seconds Preparing to say number in 7 seconds Preparing to say\
    \ number in 5 seconds 1 2 3 4 5 6 7 8"
  key: 2020/04/04/whats-ap.html
- document: "Updated: for Scala 3.0.0-M3 `as` keyword was removed This is the companion\
    \ blog for my first Functional Justin video which you can find here https://youtu.be/J01u_Dmrx5U.\
    \ I spend around 15 minutes adding some Scala 3 (formerly Dotty) features to an\
    \ Scala 2 program. The program itself builds a simple Algebraic Data Type (ADT)\
    \ to represent a simple arithmetic expressions. We can then build expressions\
    \ in this algebra and evaluate it using an eval function using pattern matching\u2026\
    \ sealed trait Exp case class Val (value : Int ) extends Exp case class Add (left\
    \ : Exp , right : Exp ) extends Exp case class Mul (left : Exp , right : Exp )\
    \ extends Exp case class Var (identifier : String ) extends Exp Now given an expression\
    \ like Mul(Var(\"z\"), Add(Val(30), Mul(Var(\"x\"), Var(\"y\")))) I'd like to\
    \ be able to recursively traverse it and calculate a final Int value at the end.\
    \ Val represents an Int value, whilst Add and Mul take care of addition and multiplication.\
    \ You could go ahead and add more functions. Var is interesting because it takes\
    \ an a string identifier (i.e., a variable name) and will look it up in an environment.\
    \ The environment is represented a Scala map of String to Int. type Env = Map\
    \ [ String , Int ] For the eval function we just use a pattern match to dispatch\
    \ to functions that handle each particular operation. These handler functions\
    \ and eval are mutally recursive , and note that every function has to have the\
    \ Env passed to it as an implicit parameter, yet only Var needs it. This will\
    \ be important later. Here's the eval function and handlers. def eval (exp : Exp\
    \ )( implicit env : Env ) : Int = { exp match { case Var ( id ) => handleVar(id)\
    \ case Val ( value ) => value case Add ( l , r ) => handleAdd(l,r) case Mul (\
    \ l , r ) => handleMul(l,r) } } def handleAdd (l : Exp , r : Exp )( implicit env\
    \ : Env ) = eval(l) + eval(r) def handleMul (l : Exp , r : Exp )( implicit env\
    \ : Env ) = eval(l) * eval(r) def handleVar (s : String )( implicit env : Env\
    \ ) = env.getOrElse(s, 0 ) Note that we could have inlined these functions in\
    \ eval, but it a larger example it's important to break things out to keep things\
    \ managable. That is all the implementation we need, and all that remains is to\
    \ create an expression, create an environment (declared implicit so Scala knows\
    \ to include it as an implicit when eval is called) and print the result of evaluating\
    \ the expression. val exp1 : Exp = Mul ( Var ( \"z\" ), Add ( Val ( 30 ), Mul\
    \ ( Var ( \"x\" ), Var ( \"y\" )))) implicit val env : Env = Map ( \"x\" -> 17\
    \ , \"y\" -> 10 , \"z\" -> 2 ) val eval1 = eval(exp1) println(s \"Eval exp gives\
    \ $eval1 \" ) You can compile and run the code to see this working. The code is\
    \ here. https://github.com/justinhj/evalexample/blob/master/src/main/scala/Scala2Eval.scala"
  key: 2020/11/18/scala-3-context-functions.html
- document: 'In the seminal paper Applicative programming with Effects, the first
    motivating example for applicative programming is the sequence function. You have
    a list of effects, specifically Haskell IO effects, and you would like to turn
    them into an IO[List[A]] . You might recognise this as having the same shape and
    purpose as Future.sequence from the Scala standard library. sequence is built
    with its more powerful friend traverse. Future .sequence is a function IterableOnce
    [ Future [ A ]] => Future [ IterableOnce [ A ]] Future .traverse is a function
    IterableOnce [ A ], A => Future [ B ] => Future [ IterableOnce [ B ]] In Typelevel
    Cats, the Traverse typeclass makes this more flexible by allows us to traverse
    over any type that is a functor (you can map over it) and foldable (you can fold
    it with foldLeft, foldRight and fold). trait Traverse [ F [ _ ]] extends Functor
    [ F ] with Foldable [ F ] { def traverse [ G [ _ ] : Applicative , A , B ](fa
    : F [ A ])(f : A => G [ B ]) : G [ F [ B ]] } What''s interesting about Traverse
    is that it relies on a number of type classes to build its expressive power. Ultimately
    our little friend ap is the king pin of the whole thing, allowing us to combine
    the effects together as we fold in a way that is "idiomatic" to the effect type.
    When we traverse a list of Id for example (the identity monad) we get map, and
    when we traverse a list of Const, we get fold. In other words changing the data
    type is all we need to make drastically different programs. To demonstrate this
    in my applicative post, I wrote an implementation of a silly algorithm called
    Sleep Sort. Sleep Sort works by waiting an amount of time-based on the value of
    the number. Emitting the numbers in this way sorts them (assuming your scheduler
    is accurate enough). Let''s be clear, this is a stupid way to sort numbers, but
    it does represent some real-world needs we have like being able to run effects
    in parallel. import zio. _ import zio.prelude. _ import zio.console. _ import
    zio.clock. _ def delayedPrintNumber (s : Int ) : ZIO [ Console with Clock , String
    , Int ] = { putStrLn(s "Preparing to say number in $s seconds" ) *> putStrLn(s
    " $s " ).delay(s.seconds) *> ZIO .succeed(s) } val ios = List ( 6 , 5 , 2 , 1
    , 3 , 8 , 4 , 7 ).map(delayedPrintNumber) // ios: List[ZIO[Console with Clock,String,Int]]
    Using Cats we can use Traverse.sequence to flip the List[Zio] to ZIO[List] and
    then execute it. import cats.__ import cats. Traverse val runtime = Runtime .default
    val program = Traverse [ List ].traverse(ios) runtime.unsafeRun(program) Sadly
    we find this does not work because wanted all the effects to start at once and
    then complete at their alloted times, making the sort work. Instead we''ll see
    each executed in sequence. Monadic version Preparing to say number in 6 seconds
    6 Preparing to say number in 5 seconds 5 // ... and so on for a while Happily
    thanks to the joys of Applicative we can fix this by changing the data type. If
    we rewrite using Cats Effect we wrap our IO into a different type called Par.IO
    which has a different implementation of applicative that does NOT sequence the
    IOs together but allows them to run in parallel, we can get the sleep sort behaviour.
    We didn''t change the structure of our code, just the data type! Now all of the
    effects started at the same time and ran in parallel. Preparing to say number
    in 6 seconds Preparing to say number in 2 seconds Preparing to say number in 1
    seconds Preparing to say number in 3 seconds Preparing to say number in 8 seconds
    Preparing to say number in 4 seconds Preparing to say number in 7 seconds Preparing
    to say number in 5 seconds 1 2 3 4 5 6 7 8'
  key: 2020/08/02/whats-ap-with-zio-prelude.html
- document: 'Here are some good references for reading about type classes in Scala
    (they can of course be implemented in other functional programming languages).
    Sam Halliday has a great introduction to data types and type classes in his book
    Functional Programming for Mortals. https://leanpub.com/fpmortals/read#leanpub-auto-data-and-functionality
    This idea of separating data from functions can also be found in the Cats functional
    programming library, with the library itself being organised into distinct sections
    for data types and type classes. https://typelevel.org/cats/typeclasses.html https://typelevel.org/cats/datatypes
    My former colleague and functional programming advocate Francis Toth also has
    a nice blog on this topic. https://contramap.dev/2020/04/09/typeclasses.html In
    my own words, type classes are not explicitly part of the Scala language, but
    are rather a pattern of implementation that enable you to define behaviours which
    can then be implemented for data types. Data types are values like strings and
    numbers, collections like lists and sets and "higher kinded types" like IO, ZIO
    and so on. Type classes do not have to be implemented a certain way, but in Cats,
    Scalaz and other libraries you will find them implemented just as they are here,
    but additional layers of complexity to manage things like stack safety and take
    advantage of tools to generate boilerplate code. In general type classes consist
    of:'
  key: 2020/12/06/type-classes-scala-2.html
- document: "Hacker News API Part 4 - Fun with Monix Previous related posts: Code\
    \ referred to here can be found on Github If you didn\u2019t read the previous\
    \ 3 posts about this little learning project (or as my son calls it writing the\
    \ same boring program over and over), then don\u2019t worry because this will\
    \ be self-contained and an introduction to the Monix library and a couple of fun\
    \ things you can do with it. As a Typelevel project Monix has great documentation\
    \ and high development standards, see here for more. The library was created by\
    \ Alexandru Nedelcu and I highly recommend his entertaining and informative video\
    \ presentation on the monix.io site. In this post, we go back to part 2 of this\
    \ series where I made an interactive command line client for viewing Hacker News\
    \ stories. The first step is to get the list of top stories which is a simple\
    \ list of story IDs. I used the Fetch library from 47Degs to manage the retrieval\
    \ of each story. Fetch manages the number of concurrent operations you do as well\
    \ as handling caching. Under the hood Fetch is implemented using Cats Free As\
    \ you can see in the image there is a bit of diagnostic information in the background\
    \ showing which threads the task is running on. This helps when debugging and\
    \ configuring multi-threaded code. As is often the case when looking at old code,\
    \ maybe especially your own, you see things that make you sad. In this case, there\
    \ are two sad things relating to functional programming and both of them will\
    \ be fixed by the end of the post. The first sad thing is the use of Future and\
    \ the second is the lack of composablity. The Future of Future Scala\u2019s Future\
    \ is a simple to use abstraction that lets you work with values that typically\
    \ will take some time to compute. Common examples are fetching some data from\
    \ a database or calling a remote service endpoint. In imperative programming,\
    \ you would probably have the DB operation start on another thread and ask that\
    \ thread to \u2018callback\u2019 to you when it\u2019s done. Scala\u2019s Future\
    \ provides an ExecutionContext, essentially the instructions and configuration\
    \ for how to run the Future code. Every Future must have an implicit ExecutionContext\
    \ in scope, although you can pass one explicitly if you like. Once created a Future\
    \ will usually execute immediately (it could be that it is asked to run on a thread\
    \ pool that is busy and it will have to wait for a place in the queue.) Once executed\
    \ it will complete by setting its value (or return an error if it fails). As a\
    \ user of the Future we must eventually wait for it somehow, for example using\
    \ the blocking call Await.result. This will wait for the Future to get its value\
    \ set by a successful operation, or for the Future\u2019s error to be set, or\
    \ finally it the Await operation itself could timeout. Unfortunately, this eager\
    \ evaluation of Future means that it is not referentially transparent. As functional\
    \ programmers we want referential transparency because it makes programs easier\
    \ to reason about. I found a very nice and succinct demonstration of this problem\
    \ in a Reddit comment by Rob Norris (@tpolecat): import scala.concurrent.future\
    \ import scala.util.Random import scala.concurrent.ExecutionContext.Implicits.global\
    \ val f1 = { val r = new Random(0L) val x = Future(r.nextInt) for { a <- x b <-\
    \ x } yield (a, b) } // Same as f1, but I inlined `x` val f2 = { val r = new Random(0L)\
    \ for { a <- Future(r.nextInt) b <- Future(r.nextInt) } yield (a, b) } In this\
    \ example, we are running some side-effecting code in the Future (generating a\
    \ random number mutates the Random object by updating its seed). The result of\
    \ running f1 is: Future[(Int, Int)] = Future(Success((-1155484576,-1155484576)))\
    \ Whilst f2 gives: Future[(Int, Int)] = Future(Success((-1155484576,-723955400)))\
    \ For referential transparency, we can take any function and its arguments and\
    \ replace it with the result. val x = something (x, x) should be the same as (something,\
    \ something) That is broken in the Future example above because x in the first\
    \ example is eagerly evaluated on creation, and the random value is fixed (memoized)\
    \ for as long as the Future exists. Monix Task Monix provides Task that we can\
    \ use instead of Future. It adds a lot of features, most notably for our purposes\
    \ is that it allows us to lazily evaluate our code. In fact, that is the default.\
    \ In the Future example above we can simply replace Future with Task and we will\
    \ find that referential transparency is restored: import monix. import scala.util.Random\
    \ import monix.execution.Scheduler.Implicits.global val t1 = { val r = new Random(0L)\
    \ val x = Task(r.nextInt) for { a <- x b <- x } yield (a, b) } // Same as f1,\
    \ but I inlined `x` val t2 = { val r = new Random(0L) for { a <- Task(r.nextInt)\
    \ b <- Task(r.nextInt) } yield (a, b) } Now you\u2019ll find that both t1 and\
    \ t2 return the same value (-1155484576,-723955400) Besides that Monix Tasks have\
    \ a lot of features and improvements over the Scala Future. For example, Monix\
    \ Tasks do not require an execution context for their create, map and flatMap\
    \ operations. In fact, you don\u2019t need to provide one until you actually run\
    \ something, which can be in one nicely contained place in your program \u2018\
    at the end of the world\u2019. The Monix Scheduler has an ExecutionContext and\
    \ includes features such as running a Task after a delay or repeatedly. Another\
    \ advantage of the Task object being so full featured is that we can wrap all\
    \ the parts of our program using it and then compose them neatly at will. Due\
    \ to the way flatMap is defined you cannot use different effect types. That means\
    \ you end up with ugly for comprehensions where most of the flatMaps are operating\
    \ on a certain effect such as Future or Option, but there are outliers that have\
    \ to be cast in-line. If we write our program in terms of simple Task\u2019s we\
    \ can compose them without having to worry about the effect type not lining up.\
    \ Changes to the HNFetch code In order to convert my Hacker News fetch command-line\
    \ code from an essentially imperative Scala program to one that is composed of\
    \ Task\u2019s took a few simple steps: Library Imports I updated the Fetch library\
    \ version and brought in the fetch-monix integration which allows you to use Monix\
    \ Task when running Fetch operations. val fetchVersion = \"0.7.2\" libraryDependencies\
    \ ++= Seq( \"com.47deg\" %% \"fetch\" % fetchVersion, \"com.47deg\" %% \"fetch-monix\"\
    \ % fetchVersion) Fetch will bring in the Monix library but I also wanted the\
    \ monix-reactive module for something we\u2019ll see later in the post, so I brought\
    \ that in manually. \"io.monix\" %% \"monix-reactive\" % \"3.0.0-M3\" Fetch documentation\
    \ for working with Monix is here. This is not really related to the process of\
    \ replacing Future with Task but a refactor to replace Query.async calls with\
    \ Query.sync. This goes hand in hand with removing Future from other parts of\
    \ the program. Since my http library is synchronous, and Fetch can handle synchronous\
    \ functions, this change made sense. Note that this file no longer has any reference\
    \ to Future or Monix Task which makes it more flexible. The caller should be able\
    \ to specify the effect type. override def fetchOne(id: HNUserID): Query[Option[HNUser]]\
    \ = { Query.sync(HNFetch.getUser(id) match { case Right(a) => Some(a) case Left(_)\
    \ => None }) } In this code most of the changes were removing Future from functions\
    \ that can actually be simply synchronous. We\u2019ll later let Monix Task handle\
    \ scheduling them on threads. The one exception is the function getTopItems which\
    \ will we call as a single Task (the other http gets are made by Fetch itself\
    \ and will be wrapped by Tasks later). So in refactoring, I\u2019ve created a\
    \ Sync (blocking) and a regular (Task wrapped) version of the supported Hacker\
    \ News API. def getTopItems(): Task[Either[String, HNItemIDList]] = Task.eval\
    \ { hnRequest[HNItemIDList](getTopItemsURL) } Note that all the side effects in\
    \ the program now occur in Task objects. We can compose the program together from\
    \ these small pieces using all the functional programming tools we have available.\
    \ This is the main loop, asking for user input and showing the next news items:\
    \ def showPagesLoop(topItems: HNItemIDList, cache: Option[DataSourceCache]): Task[Option[DataSourceCache]]\
    \ = // Here we will show the page of items or exit if the user didn't enter a\
    \ number getUserPage.flatMap { case Some(page) => println(s\"fetch page $page\"\
    ) for ( fetchResult <- fetchPage(page, numItemsPerPage, topItems, cache); (env,\
    \ items) = fetchResult; _ = println(s\"${env.rounds.size} fetch rounds\"); _ <-\
    \ printPageItems(page, numItemsPerPage, items); newCache <- showPagesLoop(topItems,\
    \ Some(env.cache)) ) yield newCache case None => Task.now(cache) } and the main\
    \ loop: // Set a fixed size pool with a small number of threads so we can be nice\
    \ to the Hacker News servers by // limiting the number of concurrent requests\
    \ val scheduler = monix.execution.Scheduler.fixedPool(\"monix-pool\", 4, true)\
    \ def main(args : Array[String]) : Unit = { // Finally the main program consists\
    \ of getting the list of top item IDs and then calling the loop ... val program\
    \ = getTopItems().flatMap { case Right(items) => showPagesLoop(items, None) case\
    \ Left(err) => printError(err) } val ran = program.runAsync(scheduler) Await.result(ran,\
    \ Duration.Inf) } } So? With a few changes, we\u2019ve turned a simple ugly program\
    \ that used old-fashioned Futures and was not at all composable into a much more\
    \ useful program made of small composable parts. If you don\u2019t believe me\
    \ then check out the old code here Not only is the new code easier to read, we\
    \ now have the parts that make it up available to easily make new programs. A\
    \ small demo of Monix Reactive I\u2019m just getting started learning about what\
    \ the Monix library, but I spent a few minutes playing around in the Ammonite\
    \ REPL and had a lot of fun. For example, Hacker News has a MaxItem API, which\
    \ tells you the ID of the last posted item (it increase monotonically). So I used\
    \ the Monix Observer (part of the reactive module) to generate a tick every 30\
    \ seconds at which point you can execute a Task. These few lines of code will\
    \ check Hacker News every 30 seconds and print the latest comment: import monix.eval.Task\
    \ import scala.concurrent.duration._ import scala.concurrent.Await import justinhj.hnfetch.HNFetch._\
    \ import monix.execution.Scheduler.Implicits.global import monix.reactive._ def\
    \ latestComment = getMaxItem.flatMap { case Right(itemId) => getItem(itemId).flatMap\
    \ { case Right(item) if item.`type` == \"comment\" => Task(println(s\"\"\"\"${item.text}\"\
    \ - ${item.by}\"\"\")) case Right(item) => Task.unit case Left(err) => Task(println(s\"\
    error $err\")) } case Left(err) => Task(println(s\"error $err\")) } val s1 = Observable.interval(10\
    \ seconds).take(10) val c1 = s1.mapTask(_ => latestComment).subscribe // Starts\
    \ showing messages every 30 seconds (ten times) // When you get bored... c1.cancel\
    \ I leave you with the first comment that came up \"Human kind will be gone in\
    \ 1000 years? That\u2019s a pessimistic view. I hope not!\" - camdenreslink Copyright\
    \ (C) 2018 Justin-Heyes-Jones - All Rights Reserved"
  key: 2018/05/04/hacker-news-api-4.html
- document: "In July 2011 I released an emacs lisp client for the Redis in-memory\
    \ data structure store. You can install either from the Melpa package or just\
    \ clone from Github. The current version at time of writing is 0.9.6 and you will\
    \ need that or later for some of the examples below to work. In my spare time\
    \ over the last few weeks I have been steadily improving eredis by fixing bugs,\
    \ adding support for multiple connections, modernizing the use of emacs lisp and\
    \ adding some features like iterating and mapping over all the keys in the Redis\
    \ DB. In this article I will re-introduce eredis and describe some of these changes,\
    \ as well as going into some details about how it works under the hood. Possible\
    \ uses of eredis Debugging your applications. A convenient way to view the data\
    \ in Redis that uses the full power of Emacs buffers and emacs lisp Monitoring.\
    \ Using the hooks to org mode you can load a list of key/values into an org table.\
    \ With lively.el you can update it periodically. Now emacs is a realtime monitoring\
    \ tool! Data processing. Using iteration and reduction functions in eredis you\
    \ can scan over all the keys in Redis and perform calculations on your data. Scripting\
    \ and testing. Use the full power of emacs lisp to create test data or simulate\
    \ users for test cases. Installation and preparation Installation instructions\
    \ can be found in the Github README.md file. Next you will need access to a Redis\
    \ database. You can run a local test Redis instance using Docker. There are two\
    \ scripts in the github repo to let you run two instances; one on port 6380 and\
    \ the other on the default port 6379. This is because you can connect to multiple\
    \ Redis servers using eredis. Also note we\u2019re using Redis 5.0 so we can try\
    \ out the newer commands. docker run -d -p 6379:6379 --name redis5_80 redis:5.0.0-alpine\
    \ docker run -d -p 6380:6379 --name redis5_81 redis:5.0.0-alpine Connections and\
    \ basic commands Each connection to Redis creates an emacs process. To write a\
    \ network client you use a network process. The following commands open network\
    \ processes to your Redis instances. ( require 'eredis ) ( setq rp ( eredis-connect\
    \ \"localhost\" 6379 )) ( setq rp2 ( eredis-connect \"localhost\" 6380 )) Note\
    \ that the return value is a process. We can then pass that in as the final parameter\
    \ to most eredis calls, so it knows where to route the command. If you omit the\
    \ process it will use the last opened process by default. This ensures backwards\
    \ compatibility with older eredis versions. Let\u2019s try a couple of basic commands.\
    \ Imagine our application stores users and the time they logged in as string key\
    \ that looks likeuser:ID and a value which is the timestamp. We\u2019ll set two\
    \ users that have logged in at the same time, one in each instance: ( eredis-set\
    \ \"user:61\" \"1542084912\" rp ) ( eredis-set \"user:62\" \"1542084912\" rp2\
    \ ) Now you can check the data is stored correctly: ( eredis-get \"user:61\" rp\
    \ ) ( eredis-get \"user:62\" rp2 ) When we issue a Redis command it is sent to\
    \ over the network using the function process-send-string and the response from\
    \ Redis will be sent to an emacs buffer associated with the process. After the\
    \ two commands above you\u2019ll see the buffers look like this: Notice that the\
    \ buffers contain the pre-parsed RESP protocol. Using buffers in this way lets\
    \ you see the history of output from Redis, which helps with debugging and also\
    \ maybe useful depending on how you use eredis. After the command is sent to Redis\
    \ eredis will call accept-process-output which is a signal to Emacs to check for\
    \ any data received over the network connection and put it in the buffer. This\
    \ function can return immediately if there is no data, so you have to keep calling\
    \ it until you\u2019ve got a fully formed response. If the buffers start to get\
    \ big or you want to clear them, you can do so with eredis-clear-buffer passing\
    \ the process as the parameter. You can also disconnect from the process once\
    \ you are done either by using the command eredis-disconnect or by killing the\
    \ process in the window you get if you run the list-processes command. Lolwut\
    \ Salvatore Sanfilippo recently wrote in Redis news LOLWUT: a piece of art inside\
    \ a DB command about how from version 5 onwards LOLWUT will do something fun.\
    \ Currently that draws a piece of randomly generated art using the braille unicode\
    \ characters. eredis supports that command. eredis-lolwut returns the lolwut art.\
    \ Note that it won\u2019t look like this necessarily. In Emacs 26.1 running on\
    \ macOS Mojave I had to download a few fonts before I found one that rendered\
    \ correctly called Swell Braille. A note on multibyte string handling In early\
    \ versions of eredis there was a bug reading multibyte character data. Redis,\
    \ as you may know, only deals with bytes. Whatever encoding you\u2019re using\
    \ for strings on the client side, you send byte strings to Redis and it sends\
    \ those same strings back. In eredis the buffer is set to multibyte mode, so if\
    \ you receive multibyte characters they will display correctly there: ( eredis-set\
    \ \"hello-chinese\" \"\u4F60\u597D\u5417\" ) ;; \"OK\" ( eredis-get \"hello-chinese\"\
    \ ) ;; \"\u4F60\u597D\u5417\" So to the user of eredis everything works. But this\
    \ is not automatic, take this example: ( length \"\u4F60\u597D\u5417\" ) ;; 3\
    \ ( length ( string-as-unibyte \"\u4F60\u597D\u5417\" )) ;; 9 Emacs returns the\
    \ length of a multibyte string as the number of characters, not the number of\
    \ bytes. But Redis returns this string as follows: $9 \u4F60\u597D\u5417 In other\
    \ words Redis sends a string of 9 bytes. You need to be careful when parsing RESP\
    \ data to count actual bytes and not characters. In eredis I convert between multibyte\
    \ and unibyte strings to make sure the parser works correctly, before passing\
    \ the final multibyte string to the caller. org mode integration Note that you\
    \ need version 0.9.6or later for this section as I had to fix some bugs and make\
    \ some improvements for this flow to work correctly. Please note that the org\
    \ functions don\u2019t obey the process parameter, and they work on the last opened\
    \ connection only. If you only have one connection open you should be fine. A\
    \ fix for this will be in the next release. Data from Redis and org-mode tables\
    \ are a natural match, so I have implemented integration between the two. As an\
    \ example let\u2019s create a 1000 random user login times (within the last 15\
    \ minutes) stored in the format above: ( let (( time-now ( round ( float-time\
    \ )))) ( dotimes ( n 1000 ) ( let (( login-time ( - time-now ( random ( * 15 60\
    \ ))))) ( eredis-set ( format \"user:%d\" n ) ( number-to-string login-time )\
    \ rp )))) Now for debugging we want to see a table with login times of some users\
    \ we\u2019re interested in. That can be done like this: ( eredis-org-table-from-keys\
    \ ' ( \"user:11\" \"user:21\" \"user:31\" \"user:41\" )) \u2026 which creates\
    \ a table and inserts it in the buffer \u2026 Of course it wouldn\u2019t be any\
    \ fun if the data flow was one way, so you can also edit the values (and keys)\
    \ in the table and push them back up to Redis using the interactive command eredis-org-table-mset\
    \ If you create the table again in another part of the buffer you\u2019ll see\
    \ the values from your edit session have been stored to Redis. Data processing\
    \ Another capability I recently added and that will be expanded on in future is\
    \ the ability to iterate over all the keys in Redis using SCAN. Redis initially\
    \ only had the KEYS * command for getting all the keys at once. Doing operations\
    \ like that is a big problem when your data sets are very large. If you\u2019\
    re working with a real time data processing system you also don\u2019t want to\
    \ choke DB\u2019s of any type by pulling huge amounts of data in single queries.\
    \ For that reason Redis added the SCAN command so we can iterate through pages\
    \ of keys and Redis can manage making sure that particular clients don\u2019t\
    \ overwhelm the system. To this end I\u2019ve added (so far) two facilities for\
    \ iterating and reducing the entire key set, that wrap the SCAN command and let\
    \ you focus on your data processing task. In addition at each step eredis pulls\
    \ the values for each key using the MGET command. Now we can safely do map and\
    \ reduce type operations over the keys and values in Redis! Since I\u2019m a fan\
    \ of the dash.el list library, I use Dash commands to implement these functions,\
    \ and then compile each page together transparently for the caller. Earlier we\
    \ added 1000 users. Let\u2019s do a simple reduction to count them. There are\
    \ two versions of this reduce function, one that also does a key name match eredis-reduce-from-matching-key-value\
    \ and another that gets all of the keys eredis-reduce-from-key-value . Note the\
    \ function names map to the dash.el reduce-from function and conceptually does\
    \ the same thing but with transparent paging across the key space. In this example\
    \ we will simply count all of the users using the reduce. ( eredis-reduce-from-matching-key-value\
    \ ( lambda ( acc k v ) ( + acc 1 )) 0 \"user:*\" rp ) ;; 1000 Here 's a more useful\
    \ example that actually uses the value ( we stored a timestamp ) in the reduction.\
    \ We 'll figure out how long each user has been logged in, total all the login\
    \ times, and divide by 1000 to get the average time logged in: ( let (( time-now\
    \ ( round ( float-time )))) ( / ( eredis-reduce-from-matching-key-value ( lambda\
    \ ( acc k v ) ( + acc ( - time-now ( string-to-number v )))) 0 \"user:*\" rp )\
    \ 1000 )) ;; 2450 So the average login time is 2450 seconds, or about 40 minutes,\
    \ which is because I created the test users around 40 minutes ago. As well as\
    \ reductions you can iterate over the users using each Note that this is not mapping\
    \ over the key space as that would be very unfriendly to your Emacs environment\
    \ if you have a lot of data. Map creates a new list of keys and values and holds\
    \ them all in memory at once. All we want to do is iterate over the pages of keys\
    \ and values, execute some function for its side effect, and continue on. There\u2019\
    s nothing stopping you materializing the entire key set in emacs should you need\
    \ to, but it\u2019s not supported by the eredis default API. ( let (( most-recent-login\
    \ 0 )) ( eredis-each-matching-key-value ( lambda ( k v ) ( let (( login-time (\
    \ string-to-number v ))) ( if ( > login-time most-recent-login ) ( setf most-recent-login\
    \ login-time )))) \"user:*\" rp ) most-recent-login ) ;; 1542566731 Here we iterate\
    \ all the keys and values and find the most recent login. Note that this could\
    \ be done as a reduction too, there is some overlap between iterators and reductions.\
    \ What\u2019s next? Once eredis has stabilized and supports all Redis commands\
    \ without bugs it will go to version 1.0.0 Before that however, the more immediate\
    \ work is going into support for stream.el which allows us to construct lazy sequences.\
    \ By implementing the SCAN functionality as a lazy stream we then can better compose\
    \ operations on large data sets without blowing our memory. For example you can\
    \ chain a couple of maps and filters together to transform your data before a\
    \ final reduce to make it a single value. In addition the org table support will\
    \ be bolstered with bug fixes and new features. I hope you enjoyed this quick\
    \ tour of eredis and find a use for it, or at the very least see that emacs lisp\
    \ programming can be fun, useful and quite simple. This post is also published\
    \ on Medium medium.com/@justinhj/eredis-an-updated-emacs-api"
  key: 2018/11/18/eredis-updated-emacs-redis-api.html
- document: "Radix trees In the Emacs 26.1 release notes there\u2019s a reference\
    \ to a new library: New Elisp data-structure library \u2018radix-tree\u2019 I\
    \ checked and the radix-tree data structure does not yet appear in the info documentation,\
    \ but there is of course documentation for each of the functions in the implementation\
    \ radix-tree.el . In this post I\u2019ll show how to use radix trees, along with\
    \ company mode (an auto complete library, the name comes from COMplete ANYthing),\
    \ to implement a custom dictionary of words that you would like to be able to\
    \ auto-complete when typing. The source code and dictionary used in this post\
    \ can be found in this bitbucket repo What are radix trees? Rather than go into\
    \ the implementation and detailed explanation of Radix trees check them out on\
    \ Wikipedia or your favourite algorithms textbook . For the purposes of this post\
    \ let\u2019s go with a super imprecise explanation. When you store a map of keys\
    \ that are associated with some value there are a number of ways to represent\
    \ that as a data structure. What Radix Trees offer is that when the key is a sequence\
    \ of some kind (say a string of characters or a list of numbers) we can store\
    \ the keys in a much abbreviated format, taking advantage of the shared prefixes\
    \ amongst many keys. For example most Vancouver phone numbers begin with 778 or\
    \ 604. Most of the numbers in a radix tree can be stored under one of those three\
    \ digit prefixes rather than in three levels of tree (7,7,8\u2026). If that\u2019\
    s confusing never mind, it will become clear as we progress\u2026 Exploring radix\
    \ trees in Emacs A small example\u2026 say we want to store the following keys\
    \ in a key value store: application, appetizer, applicative, apple. To start with\
    \ we need an empty radix tree, which is just defined as nil: ( require 'radix-tree\
    \ ) radix-tree-empty You add key/values to the map like this: ( setq tree-1 (\
    \ radix-tree-insert radix-tree-empty \"application\" t )) ;; ((\"application\"\
    \ . t)) Note that inserting returns a new tree that contains just the single key\
    \ \u201Capplication\u201D. For the purposes of our program we don\u2019t need\
    \ to store an actualy value, we\u2019re just interested in the keys which represent\
    \ valid English words, so we just store `t\u2019 which is true in Emacs Lisp.\
    \ Next we\u2019ll make a new tree by inserting the next word into `tree-1\u2019\
    : ( setq tree-2 ( radix-tree-insert tree-1 \"appetizer\" t )) ;; ((\"app\" (\"\
    lication\" . t) (\"etizer\" . t))) As you can see the radix tree split the key\
    \ up into the shared prefixes between the two words. We can query how many words\
    \ the tree has in total like this: ( radix-tree-count tree-2 ) ;; 2 (#o2, #x2,\
    \ ?\\C-b) Reducing a list and the Dash list API We\u2019ve seen how to add elements\
    \ one at a time to the tree, but our goal is to take a list of words and add them\
    \ to a dictionary. For that we will need to use the `seq-reduce\u2019 function;\
    \ a functional programming construct for reducing a sequence to a single value\
    \ using some function that accumulates results: ( seq-reduce ( lambda ( acc it\
    \ ) ( radix-tree-insert acc it t )) ' ( \"application\" \"appetizer\" \"applicative\"\
    \ \"apple\" ) radix-tree-empty ) ;; ((\"app\" (\"l\" (\"icati\" ... ...) (\"e\"\
    \ . t)) (\"etizer\" . t))) In the output you can see that the four words have\
    \ been neatly split into their shared and non-shared parts. seq-reduce is fine\
    \ for our purposes, but when working with Emacs lisp lists I prefer to use Dash\
    \ which is a package providing a more modern list API. All Dash functions begin\
    \ with a dash hence the name. We can replace the code above using Dash as follows:\
    \ ( require 'dash ) ( -reduce-from ( lambda ( tree word ) ( radix-tree-insert\
    \ tree word t )) radix-tree-empty ' ( \"application\" \"appetizer\" \"applicative\"\
    \ \"apple\" )) ;; ((\"app\" (\"l\" (\"icati\" ... ...) (\"e\" . t)) (\"etizer\"\
    \ . t))) In English when you refer to a word used earlier in the conversation\
    \ you will say \u201Cit\u201D instead, and this is called anaphora. Dash provides\
    \ \u201Canaphoric\u201D versions of many of its functions that begin with two\
    \ dashes that let you abbreviate the lambda form we used above and refer to each\
    \ item as it. In the case of the --reduce-from we get both it and acc (for the\
    \ accumulated result): ( --reduce-from ( radix-tree-insert acc it t ) radix-tree-empty\
    \ ' ( \"application\" \"appetizer\" \"applicative\" \"apple\" )) ;; ((\"app\"\
    \ (\"l\" (\"icati\" ... ...) (\"e\" . t)) (\"etizer\" . t))) That\u2019s nicer!\
    \ Now we need a function that takes a sequence of words and adds them to a radix\
    \ tree: ( defun list-to-radix-tree ( l ) ( --reduce-from ( radix-tree-insert acc\
    \ it t ) radix-tree-empty l )) ( setq small ( list-to-radix-tree ' ( \"application\"\
    \ \"appetizer\" \"applicative\" \"apple\" ))) ;; ((\"app\" (\"l\" (\"icati\" ...\
    \ ...) (\"e\" . t)) (\"etizer\" . t))) Reading words from a file and making a\
    \ radix tree Our next step is to load the words for our custom dictionary from\
    \ a file. The one in the github repo dictionary.txt contains 172k words. We can\
    \ load it and turn it into a list of words, and finally build a radix tree as\
    \ follows: ( defun radix-tree-from-file ( file-path ) ( -> ( with-temp-buffer\
    \ ( insert-file-contents-literally file-path ) ( buffer-substring-no-properties\
    \ ( point-min ) ( point-max ))) split-string list-to-radix-tree )) ( radix-tree-from-file\
    \ \"dictionary.txt\" ) Note the use of \u201C->\u201D which is a threading macro\
    \ from Dash. It lets us put a list of operations together and \u201Cthreads\u201D\
    \ the result from one step to the next, making things a bit easier to read. You\u2019\
    ll see a similar operator in Clojure. Speeding it up Hmm, that was kinda slow.\
    \ When we start using the Company mode we need to load the file and we don\u2019\
    t want a delay like that. Let\u2019s use the emacs benchmark facility to see just\
    \ how slow it is: ( require 'benchmark ) ( benchmark-elapse ( radix-tree-from-file\
    \ \"dictionary.txt\" )) ;; 6.021951 Six seconds is a bit too much. How about we\
    \ just write the radix tree to a file instead, then load that? First we need to\
    \ write the tree to a string using print1-to-string , then we can stick that in\
    \ a buffer and write it to a file. ( defun write-text-to-file ( text file-path\
    \ ) ( save-excursion ( let (( buffer ( find-file file-path ))) ( switch-to-buffer\
    \ buffer ) ( erase-buffer ) ( insert text ) ( save-buffer ) ( kill-buffer ))))\
    \ ( setq dictionary ( radix-tree-from-file \"dictionary.txt\" )) ( write-text-to-file\
    \ ( prin1-to-string dictionary ) \"dictionary.el\" ) ;; (write-text-to-file (prin1-to-string\
    \ small) \"dictionary.el\") Now let\u2019s see how much faster it is to simply\
    \ load the data structure rather than build it: ( defun tree-from-file ( file-path\
    \ ) ( save-excursion ( let* (( buffer ( find-file file-path )) ( tree ( read buffer\
    \ ))) ( kill-buffer buffer ) tree ))) ( benchmark-elapse ( progn ( setq loaded-dictionary\
    \ ( tree-from-file \"dictionary.el\" )) t )) ;; 0.198365 Great! The first time\
    \ we run the program it will take 6 seconds to build, but subsequently we can\
    \ load the radix tree data from disk which takes 0.2 seconds. That means if we\
    \ prepare the dictionary.el file we can simply load that when the system starts\
    \ without a noticable slowdown. The next step is to be able to find all the keys\
    \ given a prefix. radix-tree-subtree does the job, returning a subtree rooted\
    \ at the given prefix. Given the relevant subtree we can then iterate all of the\
    \ keys and values using the function radix-tree-iter-mappings . Here we use the\
    \ destructive !cons (also from Dash) to build up a list of all the keys, which\
    \ we then return. This is now all the functionality we need to return for our\
    \ auto-complete functionality: ( defun radix-tree-keys ( subtree prefix ) ( let\
    \ ( keys ' ()) ( radix-tree-iter-mappings ( radix-tree-subtree subtree prefix\
    \ ) ( lambda ( key val ) ( !cons ( concat prefix key ) keys ))) keys )) ( radix-tree-keys\
    \ loaded-dictionary \"antidi\" ) ;; (\"antidiscrimination\" \"antidilution\" \"\
    antidiarrheal\" \"antidiabetic\") Company Mode Company Mode is one of the two\
    \ most popular completion frameworks for emacs (the other being Auto-Complete).\
    \ In order to make our own custom dictionary auto completion we just need to implement\
    \ a single function to implement a \u201Cbackend\u201D. The best documentation\
    \ for how to write a backend is in the docstring for `company-backends\u2019 so\
    \ I\u2019d recommend reading that in full to see the capabilities of Company mode.\
    \ First, the code, I\u2019ll explain each part below: C-h v company-backends (\
    \ require 'company ) ( defun get-candidates ( prefix ) \"Given a prefix return\
    \ a list of matching words that begin with it\" ( when ( > ( length prefix ) 2\
    \ ) ( radix-tree-keys company-custom-dictionary--words-tree ( downcase prefix\
    \ )))) ( defun company-custom-dictionary ( command &optional arg &rest ignored\
    \ ) \"Company mode backend for a custom dictionary stored as a radix tree.\" (\
    \ case command ( 'init ( unless ( boundp 'company-custom-dictionary--words-tree\
    \ ) ( setq company-custom-dictionary--words-tree ( tree-from-file \"dictionary.el\"\
    \ )))) ( 'prefix ( company-grab-word )) ( 'candidates ( radix-tree-keys company-custom-dictionary--words-tree\
    \ ( downcase arg ))) ( 'ignore-case 'keep-prefix ))) ;; (provide 'company-custom-dictionary)\
    \ ;; Push the mode to the list of company backends ( push 'company-custom-dictionary\
    \ company-backends ) ;; If you want to change the dictionary, rewrite dictionary.el\
    \ and unintern the symbol ;; (unintern 'company-custom-dictionary--words-tree)\
    \ The few lines above are, believe it or not, all you need to make our custom\
    \ dictionary backend work! We are just making a callback which implements the\
    \ Company mode API by sending us commands for us to handle. Let\u2019s look at\
    \ each one: init Init is called when company mode is initially enabled. This could\
    \ be when emacs loads, or if you enable manually it will be called whenever you\
    \ enable it. It could be called multiple times in a session so keep that in mind\
    \ when implementing. In this case our implementation checks whether we loaded\
    \ the dictionary or not. If we did then nothing happens, otherwise we load it.\
    \ Init is called when company mode is initially enabled. This could be when emacs\
    \ loads, or if you enable manually it will be called whenever you enable it. It\
    \ could be called multiple times in a session so keep that in mind when implementing.\
    \ In this case our implementation checks whether we loaded the dictionary or not.\
    \ If we did then nothing happens, otherwise we load it. prefix - This is the text\
    \ the user has typed so far that we want to complete. I call the built in function\
    \ company-grab-word which does what you\u2019d expect in most cases. You can write\
    \ your own depending on your needs. I also check if there are any potential candidates.\
    \ If not we should return nil that enables other company backends further on in\
    \ the list to try and match. - This is the text the user has typed so far that\
    \ we want to complete. I call the built in function which does what you\u2019\
    d expect in most cases. You can write your own depending on your needs. I also\
    \ check if there are any potential candidates. If not we should return nil that\
    \ enables other company backends further on in the list to try and match. candidates\
    \ - We are given arg which contains the word to be completed and must return the\
    \ list of candidates that will show up in the menu for the user to pick from.\
    \ We simply use radix-tree-keys to get the list of words based on the prefix.\
    \ Note that we make the completion to lower case as we want to match words ignoring\
    \ that the user may have capitalized the word. - We are given which contains the\
    \ word to be completed and must return the list of candidates that will show up\
    \ in the menu for the user to pick from. We simply use radix-tree-keys to get\
    \ the list of words based on the prefix. Note that we make the completion to lower\
    \ case as we want to match words ignoring that the user may have capitalized the\
    \ word. ignore-case - We return a special response `keep-prefix\u2019 which maintains\
    \ the users original capitalization. Note that we don\u2019t want the performance\
    \ penalty of returning the entire dictionary when matching an empty string, or\
    \ a couple of characters, so the function get-candidates handles only words greater\
    \ than 3 in length. A note on case matching In this example I wanted the user\
    \ dictionary to use only lower case letters. Capitalization is up to then up to\
    \ the user; if you want to capitalize a word you can do so and it will match correctly.\
    \ If instead you want a dictionary where case is important (perhaps function calls\
    \ in a camel case API) you can set ignore-case to nil and remove the call to downcase\
    \ when generating the candidates. Final notes So that\u2019s all folks! This is\
    \ a fairly simple auto complete mode, but you can easily modify the code to come\
    \ up with your own based on your needs. For example: Common mispelled words list\
    \ (Do you have trouble with necessary or disappoint? Add all your most hated words\
    \ to the list) Domain words. Do you work in a domain with specialist terminology\
    \ not in a dictionary? Phone numbers, server names, IP addresses and so on Corrections\
    \ Thanks to Reddit user MCHerb for pointing out a couple of things including a\
    \ typo which have been corrected in this update, and Herbert Jones for noticing\
    \ and fixing a potential bug with matching words not in the dictionary. See the\
    \ comments below for more."
  key: 2018/10/23/radix-trees-dash-and-company-mode.html
- document: ' This is just an update that I''ve posted the whole leiningen project
    onto github A little side project I did when learning about Clojure was to grab
    movie ratings from Rotten Tomatoes, which I did a post about here:'
  key: 2011/04/26/movieratings.html
- document: ' emacs: the best place to get emacs for Mac seems to be here http://emacsformacosx.com/
    which is also the most no nonsense website design ever Not really a Mac tip, but
    I stick my .emacs configuration file in a Dropbox folder, along with any emacs
    libraries and emacs lisp code I write. Then where-ever I install emacs I make
    a simple .emacs that points to the one in the Dropbox folder. This also forces
    me to make sure any platform specific emacs stuff is properly handled. Clipboard:
    copy and paste between the terminal and other apps can be done with pbcopy and
    pbpaste. For example a long complicated command line you want to email to yourself,
    just do: echo "long complicated bash command line you don''t want to retype" |
    pbcopy And then you can Command-V that into your email window. Going the other
    way is just as simple; Command-C the text you want and pop it into the terminal
    window with pbpaste. Open: If you want open an application from the command line
    you can do it like this: open -a SomeApp /Users/yourname/SomeFile.hai You can
    open a folder in finder open /Folder/ or open /Folder/SomeFile.hai to open that
    file with it''s default application. Check out the help ''man open'', to see other
    stuff like how you pipe stdout into an application. Finally check out this guys
    OpenTerminalHere script. This pops an icon in finder that lets you open a terminal
    window in the highlighted folder. Some tips for programmers on the Mac.'
  key: 2011/04/26/programmer-tips-for-mac-osx.html
- document: ' Here''s a problem I couldn''t solve with Google, although it seems to
    be a moving target so YMMV. I wanted to do some work driving a MySQL database
    with Python. On Windows and Linux I''ve used MySQLdb so I decided to do the same
    on Mac. For reference I got mysql (client and server) through mac ports. mysql5
    --version mysql5 Ver 14.14 Distrib 5.1.45, for apple-darwin10.4.0 (i386) using
    readline 6.1 and Python is the stock version: Python 2.6.1 (r261:67515, Jun 24
    2010, 21:47:49) [GCC 4.2.1 (Apple Inc. build 5646)] on darwin First download from
    here http://sourceforge.net/projects/mysql-python/ and extract the file somewhere...
    mkdir ~/pythondb cd ~/pythondb tar -vxf ~/Downloads/MySQL-python-1.2.3.tar.gz
    Then you need open up the site.cfg file and make a change as below. Your mysql_config5
    maybe in a different spot. You can find out with the command ''which mysql_config5''.
    # The path to mysql_config. # Only use this if mysql_config is not on your PATH,
    or you have some weird # setup that requires it. mysql_config = /opt/local/bin/mysql_config5
    Now execute the following: python setup.py build python setup.py install If everything
    works you can now import MySQLdb in your python program and start interacting
    with mysql.'
  key: 2011/04/25/talking-to-mysql-from-python-on-mac-os.html
- document: ' Also made a new video showing some of the new org table creating commands
    and the monitor mode that shows the Redis commands as they are run on the server:
    I''ve been busy on my emacs redis client eredis and it now supports the entire
    API. It still needs a bit more polish but it should be a workable Redis client
    now, and I will continue to play with the org-mode table integration which I think
    has a lot of potential uses: for example making a gui to edit server parameters
    in just a few seconds.'
  key: 2011/07/30/eredis-update.html
- document: ' emacs emacs lisp file The program consists of a singlelisp file eredis
    . el emacs lisp includes facilities for writing network applications. In my code
    I use `make-network-process'' to open a connection to a specified redis server.
    Then the Redis api is exposed. One nice feature of emacs I have used is org-table-mode.
    This lets you edit and manage the data in a Redis server in an org table. For
    example, you can grab all keys matching a pattern and create an org table from
    the key value pairs, then edit that table. You can then send it back to Redis
    with interactive commands that send either the whole table, or just the current
    row back to Redis using mset or set. This work flow is not safe when working with
    multiple users, if you care about overwriting each others data. For example, I
    could store the last values you got from Redis in addition to your edited values.
    When you go to set a new value I first grab it from Redis, check if it has changed
    since you got it, and if so warn you (showing you the new value). For many work
    flows this would work well. For example the use case of a group of users editing
    a shared DB of configuration data. '
  key: 2011/07/25/eredis-redis-client-in-emacs-lisp.html
- document: ' (clojure.inspector/inspect-table ''((1 2 3) (a b c) (e f g))) Here''s
    a nice debugging feature in Clojure. The inspect module lets you look at variables
    in a popup JFrame. The two examples below show how you quickly view data in a
    table or tree format. This is really handy to quickly view data from the REPL.(require
    ''clojure.inspector)(clojure.inspector/inspect-tree ''(1 (a b) 2 (c d) 3 (e f
    )))'
  key: 2011/01/11/view-data-from-clojure-repl.html
- document: 'rottentomatoes.core> (pmap-get-movie-ratings "lord of the rings") movie
    url: http://www.rottentomatoes.com/m/lord_of_the_rings_the_return_of_the_king/
    Audience 83 Critics 94 movie url: http://www.rottentomatoes.com/m/lord_of_the_rings_the_fellowship_of_the_ring/
    Audience 92 Critics 92 movie url: http://www.rottentomatoes.com/m/lord_of_the_rings_the_two_towers/
    Audience 92 Critics 96 movie url: http://www.rottentomatoes.com/m/lord_of_the_rings/
    Audience 74 Critics 50 movie url: http://www.rottentomatoes.com/m/master_of_the_rings_the_unauthorized_story_behind_jrr_tolkiens_the_lord_of_the_rings/
    Audience 34 Critics null movie url: http://www.rottentomatoes.com/m/jrr-tolkien-and-the-birth-of-the-lord-of-the-rings/
    Audience 93 Critics null movie url: http://www.rottentomatoes.com/m/jrr_tolkien_and_the_birth_of_the_lord_of_the_rings/
    Audience 32 Critics null movie url: http://www.rottentomatoes.com/m/more_at_imdbpro_creating_the_lord_of_the_rings_symphony_a_composers_journey_through_middle_earth/
    Audience 100 Critics null nil (defproject rottentomatoes "1.0.0-SNAPSHOT" :description
    "Clojure code to grab movie ratings from Rotten Tomatoes" :dependencies [ [org.clojure/clojure
    "1.2.0"] [org.clojure/clojure-contrib "1.2.0"] [http.async.client "0.2.1"] ] :main
    rottentomatoes.core :dev-dependencies [ [swank-clojure "1.2.1"] ] ) And here''s
    the code: (ns rottentomatoes.core (:gen-class) (:require [clojure.contrib.str-utils2
    :as s] [http.async.client :as c])) (import [java.net URLEncoder] [java.lang.Character])
    (def *base-url* "http://www.rottentomatoes.com") (def *search-end-point* "/search/full_search.php?search=")
    (defn first-match-after [re1 re2 seq] "Splits the sequence SEQ using RE1 then
    searches after the first match and before the next match for the first occurence
    of RE2" (let [[_ _ after] (s/partition seq re1)] (re-find re2 after))) (defn response-status-code
    [resp] (:code (c/status resp))) (defn scoop-url [url] "Use the http client to
    do a GET on the url" (let [resp (c/GET url)] (c/await resp) [(response-status-code
    resp) (c/string resp)])) ;; Get movie urls ;; Does a search of Rotten Tomatoes
    for the search text, then scrapes the results ;; for the page for each movie.
    Returns a collection of the movie urls (defn get-movie-urls [search-text] (let
    [encoded-search-text (URLEncoder/encode search-text) [code body] (scoop-url (str
    *base-url* *search-end-point* encoded-search-text)) ] (when (= code 200) (let
    [[_ _ after] (s/partition body #"<span>Title</span>")] (let [[_ & results] (s/partition
    after #"\"(/m/.*/)\"")] (map #(str *base-url* (second %)) (take-nth 2 results)))))))
    ;; Given a movie url GET the page then scrape it for the citic and audience rating
    (defn get-movie-rating [movie-url] (let [[code body] (scoop-url movie-url)] (if
    (= code 200) {:critics (second (first-match-after #"class=\"critic_side_container"
    #">([0-9]+)<" body)) :audience (second (first-match-after #"class=\"fan_side"
    #">([0-9]+)<" body))}))) ;; Finds the ratings for all Rotten Tomatoes movies that
    match the search string and prints them out (defn get-movie-ratings [search-str]
    (let [urls (get-movie-urls search-str)] (when (> (count urls) 0) (doseq [url urls]
    (let [ratings (get-movie-rating url)] (printf "movie url: %s \tAudience %s \tCritics
    %s " url (:audience ratings) (:critics ratings))))))) ;; Slight variant on above
    that uses pmap so that the requests are done in parallel (defn pmap-get-movie-ratings
    [search-str] (let [urls (get-movie-urls search-str)] (when (> (count urls) 0)
    (let [ratings (pmap #(get-movie-rating %) urls) url-and-ratings (map vector urls
    ratings)] (doseq [[url ratings] url-and-ratings] (printf "movie url: %s \tAudience
    %s \tCritics %s " url (:audience ratings) (:critics ratings))))))) I''m using
    the str-utils2 module for it''s regex function partition, which will split a sequence
    up by regex matches. This made it easy to write the function `first-match-after'',
    which finds a regex then finds the first occurrence of some text after that regex.
    It was so easy to parallelize the requests. My first attempt at get-movie-ratings
    retrieved each movie page synchronously. By using pmap I was able to make it do
    the requests via thread pools, and thus return in a few seconds for many movie
    matches. I''m still new to Clojure so if you feel you can improve the code or
    have any feedback please let me know. I use leiningen to develop with Clojure
    (it''s like Maven for Java), so if you want to build the project here''s my project
    configuration that includes the dependencies used. I''m using swank-clojure which
    enables the REPL to function with emacs slime. http.async.client is a clojure
    API that builds on Netty and I use that for the GET requests to the Rotten Tomatoes
    server.The code is much shorter than it would have been in Common Lisp, at least
    the way I program. I love the destructuring syntax, and that maps, vectors and
    lists can be returned from functions and manipulated without much effort.'
  key: 2011/01/15/grabbing-rotten-tomatoes-movie-ratings.html
- document: ' I''ve added a function to do this `dired-mark-duplicate-files'', and
    updated the google code site with the changes To copy to another folder use R
    and select a folder to move the dupes to. In order to delete them hit D. I had
    some good feedback on my last post, that it would be useful to be leave just the
    superfluous duplicate files marked in the dired buffer. After doing that you can
    then copy them to another folder, or delete them.'
  key: 2011/06/05/more-on-duplicate-file-handling-in.html
- document: ' This is a an example of programming emacs in emacs-lisp just to give
    an idea of what you can put together in an hour or two. I was looking at a dired
    buffer with a bunch of photos in, and some were the same photo that I''d downloaded
    twice. So I started thinking about writing a utility in emacs to automatically
    find and remove the duplicate files. In this post I''ll just show the code for
    finding the files and display their filenames in a buffer. I''ve put the source
    on google code. After downloading you can load the source into emacs and call
    `eval-buffer'', then open up a dired buffer to try it out. For this to be useful
    you need some duplicated files, so make some if you need to. Mark the files you
    want to check for duplicates. For example to mark all jpg files you would type
    %m to mark files matching a regexp and type .*\.jpg Now execute the command `dired-show-marked-duplicate-files''
    and after a short delay (in my test 80 jpg photos took about 5 seconds) you''ll
    see a buffer called ''Duplicated files'' which contains a list of the files which
    have the same contents. Next steps for this little project will be to give you
    an interactive way to delete the duplicated files. I haven''t decided quite how
    I''d like that to work, drop me an email if you have an idea. I''ve been thinking
    about perhaps resetting which files are marked so that only the duplicates are
    marked. At that point you can then hit R to move them to another spot, or delete
    them with x. Now some comments about the code involved... Most of the work is
    done in the function dired-show-marked-duplicate-files. First line " (interactive)"
    makes it an interactive function, meaning the user of emacs can invoke it. "(if
    (eq major-mode ''dired-mode)" will check that we''re in the right kind of buffer,
    because it makes no sense to run this in another mode. In order to find the duplicate
    files I just need to walk the list of marked files, generate the md5 value of
    the contents of each one and add it to hash table. The keys in the hash table
    will be the md5, and the values will be a list of files with that md5. Once we''ve
    done that, finding duplicates is a simple matter of walking the hash table keys
    and displaying any where the value has multiple entries. "(let ((md5-map (make-hash-table
    :test ''equal :size 40)))" Creates the hash table, making sure we use ''equal
    to match our filenames. "(let ((filenames (dired-get-marked-files)))" this gets
    the marked files as a list of filenames The next little bit of code is just to
    store the item in the hash table after getting the md5. There''s no function in
    emacs to get the md5 of a file, but you can get the md5 of a string, so I wrote
    a helper function for getting the contents of a file into a temporary buffer first.
    (defun md5-file(filename) "Open FILENAME, load it into a buffer and generate the
    md5 of its contents" (interactive "f") (with-temp-buffer (insert-file-contents
    filename) (md5 (current-buffer)))) Finally I want to display the results, so I
    create a buffer and then use maphash (walks the keys of a hash table executing
    a function on each) with a helper function `show-duplicate'' which simply writes
    the values of the hash table entry into that buffer.'
  key: 2011/06/01/finding-duplicate-files-in-dired-buffer.html
- document: When programming in emacs lisp, there is an easy way to show progress
    feedback to the user when a task will take some time. Here's a block of code from
    the elisp manual showing how to do it. (let ((progress-reporter (make-progress-reporter
    "Collecting mana for Emacs..." 0 500))) (dotimes (k 500) (sit-for 0.01) (progress-reporter-update
    progress-reporter k)) (progress-reporter-done progress-reporter))
  key: 2011/06/14/emacs-progress-indication.html
- document: My response to the blog article An Emacs Programming Challenge The goal
    is to make the emacs lisp record below execute itself and produce XML. My lisp
    has gotten rusty so it took me a couple of hours to get this working, but I think
    I got there... You can see it properly formatted and coloured here (require 'cl)
    ;; uses lexical-let (defun make-xml-izer(name) "Given a symbol NAME this makes
    a function that outputs an xml string for that symbol and using fset binds it
    to the same symbol so it becomes executable. This pollutes the global function
    namespace so be careful with which names you pass in" (lexical-let ((sym-name
    name)) (fset (intern name) (lambda(&rest input) "returns a string representing
    the xml encoding of the input sexp" (let ((res (format "<%s>" sym-name))) (dolist
    (item input) (if (listp item) (setf res (concat res (eval item))) (setf res (format
    "%s%s" res item)))) (setf res (format "%s " res sym-name)) res))))) ;; executing
    this makes all the symbols in the list below executable (mapcar (lambda(s) (make-xml-izer
    (symbol-name s))) '(record date millis sequence logger level class method thread
    emessage exception frame line)) ;; the sample record (record (date "2005-02-21T18:57:39")
    (millis 1109041059800) (sequence 1) (logger nil) (level 'SEVERE) (class "java.util.logging.LogManager$RootLogger")
    (method 'log) (thread 10) (emessage "A very very bad thing has happened!") (exception
    (emessage "java.lang.Exception") (frame (class "logtest") (method 'main) (line
    30)))) By using lexical-let any variables are bound lexically, that is stored
    in an environment that stays with the function we create when it is executed (a
    closure). It's fairly straightforward. The only complexity is the use of lexical-let.
    emacs lisp is dynamically scoped, so in the function I create for each keyword,
    where it prints the symbol name is a free variable at runtime. So if sym-name
    is not defined you'll get an error, otherwise you'll get whatever it is defined
    as instead of the value you wanted.
  key: 2011/12/26/making-emacs-lisp-expression-expand.html
- document: "This is my first post since I moved my technical blog from justinsboringpage.blogspot.ca\
    \ to right here on Github pages All the old posts have been migrated over automatically.\
    \ Github pages supports a sophisticated static site generator called Jekkyl. Sophistication\
    \ is a double edged sword. On the one hand it offers a lot of power and flexibility,\
    \ and on the other a simple mistake will make the site fail to build with an obscure\
    \ Ruby error message. Hopefully it is worth the trade off. Org-mode, babel and\
    \ literate programming Org mode supports literate programming, which can be defined\
    \ as follows: \u201CLiterate programming is an approach to programming introduced\
    \ by Donald Knuth in which a program is given as an explanation of the program\
    \ logic in a natural language, such as English, interspersed with snippets of\
    \ macros and traditional source code, from which a compilable source code can\
    \ be generated.\u201D See here for more: Babel: active code in Org-mode In practise\
    \ what this allows is to put fragments of source code into an org mode file, which\
    \ can even be in different languages, hence the name Babel. Each source code block\
    \ can be evaluated with parameters passed from other blocks. Data can be read\
    \ from, and written to, org mode tables. This is clearly a very powerful feature.\
    \ For now here\u2019s a very simple example. I run some Python code to get the\
    \ Python version and then insert it into an org table. Add this code to a file.\
    \ To update the table put the cursor on it and type C-u C-c C-c On code blocks\
    \ you can run using C-c C-c To run any Babel code you must enable the language.\
    \ M-x customize-variable org-babel-load-languages and add python as well as any\
    \ other supported languages you want to use."
  key: 2016/02/17/python-babel.html
- document: There are no posts for this tag.
  key: tag/f-sharp/index.html
