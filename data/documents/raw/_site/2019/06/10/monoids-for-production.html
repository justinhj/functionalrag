<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <title>Monoids for Production</title>
  <meta name="description" content="What’s in this post?">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4003/2019/06/10/monoids-for-production.html">
  <link rel="alternate" type="application/rss+xml" title="Functional[Justin]" href="http://localhost:4003/feed.xml">
</head>


  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-YDJ0HSM9M6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-YDJ0HSM9M6');
  </script>

  <body>

    <header class="site-header">
  
    <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-3">
	<h5><a class="site-title" href="/">Functional[Justin]</a></h5>
      </div>
    </div>

    <div class="footer-col-wrapper">
      
      <div class="footer-col footer-col-1">
        <p>
          <img class="circle" width="110px" src="/images/justinnew.png"/></p>

      </div>
      
      <div class="footer-col footer-col-2">
        <p>Justin is a British/Canadian software engineer at Treasure Data, functional programming, polyglot, Neovim and Emacs. </p>
      </div>
      
      <div class="footer-col footer-col-3">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/justinhj"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">justinhj</span></a>

          </li>
          
	  
	  <li>
	    <a href="mailto:justinhj+blog@gmail.com">
	      <span class="icon">
		<img src="/images/email.png"/>
	      </span>
	      <span class="username">
		justinhj@gmail.com
	      </span>
	    </a>
	  </li>

          <li>
            <a href="https://gitter.im/justinhj">
            <span class="icon">
              <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 98.7 16.3" data-v-44ebcb1a=""><g><path d="M20.9,0.3h2.6v15.8h-2.6V0.3z"></path> <path d="M34.8,2.9h-4V0.3h11.8v2.6h-5.2v13.2h-2.6V2.9z"></path> <path d="M51.9,2.9h-4V0.3h11.8v2.6h-5.2v13.2h-2.6V2.9z"></path> <path d="M66.4,0.3h11.8v2.6H69v3.9h7.9v2.6H69v4h9.2v2.6H66.4V0.3z"></path> <path d="M98.7,16.1l-4.2-5.9c1.7-0.9,2.8-2.5,2.8-4.6c0-3.1-2.5-5.3-5.7-5.3l-6.2,0v15.8h2.6l0-5.3
    c0,0,3.6,0,3.6,0l3.8,5.3H98.7z M88.1,8.2l0-5.3l3.5,0c1.7,0,3,1,3,2.6c0,1.7-1.4,2.6-3,2.6L88.1,8.2z"></path> <path d="M7.9,7.1v2.6l3.9,0c0,0,0,1.4,0,2.3c-0.1,0.2-0.4,1.8-3.8,1.8c-0.2,0-0.3,0-0.5,0
    c-0.1,0-0.2,0-0.2,0c-0.1,0-0.2,0-0.2,0c-0.1,0-0.2-0.1-0.3-0.1c-0.1,0-0.1,0-0.2-0.1c0,0-0.1,0-0.1,0c-2.1-0.7-3.5-2.8-3.5-5.3
    l0,0v0v0c0-0.3,0-0.5,0.1-0.8C3.3,4.7,5.4,2.5,8,2.5c0.9,0,2.5,0.3,3.6,1.5l1.5-2.2c0,0-1.3-1.9-5-1.9C3.7,0,0.4,3.3,0,7.3
    c0,0.3,0,0.6,0,0.8l0,0l0,0c0,4.3,3.2,7.9,7.7,8.1c0.2,0,0.3,0,0.5,0c0,0,0.1,0,0.1,0c0.3,0,0.5,0,0.7,0c0.1,0,0.2,0,0.3,0
    c0.2,0,0.3,0,0.5-0.1c2.7-0.1,4.7-2.3,4.7-3.4c0-5,0-5.7,0-5.7H7.9z"></path></g></svg>
            </span>
            <span class="username">
              justinhj
            </span>
</a>
          </li>
	  <li>
	    <a href="https://www.linkedin.com/in/justinheyesjones">
	      <span class="icon">
		<img src="/images/linkedin.png"/>
	      </span>
	      <span class="username">
		LinkedIn
	      </span>
	    </a>
	  </li>

	  
          <li>
            <a href="https://twitter.com/justinhj"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">justinhj</span></a>

          </li>
          

	  
        </ul>
      </div>
      
    </div>

    <div class="my-links">
      <span class="page-link">
      	<a href="/index.html">Posts by Date</a>
       </span>

      <span class="page-link">
      	<a href="/topposts.html">Popular Posts</a>
      </span>

      <span class="page-link">
      	<a href="https://www.youtube.com/c/FunctionalJustin">YouTube channel</a>
       </span>

      <span class="page-link">
      	<a href="/talks.html">Speaking Events</a>
       </span>

      <span class="page-link">
      	<a href="/privacy.html">Privacy</a>
      </span>

      </div>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        

  

  <!-- Iterate over the tags in this post -->
  



<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Monoids for Production</h1>
    <p class="post-meta"><time datetime="2019-06-10T00:00:00-07:00" itemprop="datePublished">Jun 10, 2019</time></p>
    <div class="post-meta">
      
        
        
        
        
        
        
        More posts about
    
      <i class="fa fa-tags"></i>
    
  
        <a href="/tag/scala/">
        Scala</a>
        
          ,
        
      
        <a href="/tag/functional-programming/">
        Functional Programming</a>
        
          ,
        
      
        <a href="/tag/monoids/">
        Monoids</a>
        
          ,
        
      
        <a href="/tag/pure-functional-programming/">
        Pure Functional Programming</a>
        
          ,
        
      
        <a href="/tag/scalaz/">
        Scalaz</a>
        
          ,
        
      
        <a href="/tag/typelevel/">
        Typelevel</a>
        
          ,
        
      
        <a href="/tag/cats/">
        Cats</a>
        
      
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>What’s in this post?</p>

<ul>
  <li>Why use category theory in Scala?</li>
  <li>Quick intro to Semigroups and Monoids</li>
  <li>How to implement Monoids in Scala</li>
  <li>Using the Cats and/or Scalaz libraries to work with Monoids</li>
  <li>An example of Monoids in production code</li>
  <li>Testing the Monoid laws of your Monoid instances</li>
  <li>Bonus footnotes: Mini reviews of some Functional Programming in Scala books</li>
</ul>

<p><em>The code for this post can be found here:</em></p>
<ul>
  <li><a href="https://github.com/justinhj/monoid-demo">https://github.com/justinhj/monoid-demo</a></li>
</ul>

<h3 id="category-theory-and-scala">Category Theory and Scala</h3>

<p>If you’ve already read a few Monoid tutorials, you may want to skip to <a href="#production">Monoids in Production</a>.</p>

<p>Lifting abstract algebraic structures like Semigroup and Monoid from mathematics can make simple concepts sound complicated. While it would be tempting to come up with new words that sound more familiar, it pays for us to adopt these terms because they let us talk precisely about the things in terms of their operations and laws. It is useful for us to have a shared vocabulary with which we can communicate to other programmers and our compilers, what our types can, and cannot, do.</p>

<p>To read more on pure functional programming in Scala some great books are: <code class="language-plaintext highlighter-rouge">Functional Programming in Scala</code> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, <code class="language-plaintext highlighter-rouge">Functional Programming for Mortals</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> and <code class="language-plaintext highlighter-rouge">Advanced Scala with Cats</code> <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>.</p>

<h3 id="semigroups">Semigroups</h3>

<p>A semigroup is an algebra that has a binary associative operation; a function that takes two values of the same type and combines them into a single value.</p>

<p>Integer addition, for example, forms a semigroup:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plus</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="nf">plus</span><span class="o">(</span><span class="nf">plus</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span><span class="mi">3</span><span class="o">)</span> 
<span class="c1">//res1: Int = 6</span>

<span class="nf">plus</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="nf">plus</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span> 
<span class="c1">// res2: Int = 6</span>
</code></pre></div></div>

<p>Note that as long as we don’t change the order in which the additions are performed, we get the same result. It is this property, associativity, that makes addition with integers a semigroup. Multiplication works the same way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">multiply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="nf">multiply</span><span class="o">(</span><span class="nf">multiply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span><span class="mi">3</span><span class="o">)</span> 
<span class="c1">//res1: Int = 6</span>

<span class="nf">multiply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="nf">multiply</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span> 
<span class="c1">// res2: Int = 6</span>
</code></pre></div></div>

<p>Another example that follows the Semigroup pattern is joining strings together. Take the following strings:</p>

<p><code class="language-plaintext highlighter-rouge">"Hello" "," "World" "!"</code></p>

<p>As long as we don’t rearrange the strings, we can append them in any order we like and get the same final result. Imagine 4 strings a,b,c and d:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a b c d
ab cd
abcd
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a b c d
ab c d
abc d
abcd
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a b c d
a b cd
a bcd
abcd
</code></pre></div></div>

<p>We can do the actual operation in any order and get the same result, which is captured by the property:</p>

<p><code class="language-plaintext highlighter-rouge">op(op(x,y), z) == op(x, op(y,z))</code></p>

<p>This property is useful because we know that we can do optimisations. If we have long lists of integers we can divide them into smaller ones, run the appends in parallel, and then combine the results. We can use a left fold or a right fold without worrying about the order of operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="mi">0</span><span class="o">){</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">}</span> 
<span class="c1">//res1: Int = 6</span>
<span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="mi">0</span><span class="o">){</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">}</span>
<span class="c1">//res2: Int = 6</span>
</code></pre></div></div>

<p>Note that to fold a list we need the list, a binary operation to combine each element, and a “zero” value. Without a zero value, it’s impossible to combine all the elements of the list into an accumulator. For example, if we have a list with a single item, the first step of the foldLeft would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">foldLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="o">???){</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">}</span> 
<span class="o">???</span> <span class="o">|+|</span> <span class="mi">1</span>
</code></pre></div></div>

<p>If we had a zero value available for the type our semigroup is defined for, we could run a fold using that zero value instead of passing it ourselves. The syntax would then be simply:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">fold</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span> 
<span class="c1">//res1: Int = 6</span>
</code></pre></div></div>

<p>By adding a way to get a zero for a type, we turn a semigroup into a monoid.</p>

<h2 id="monoids">Monoids</h2>

<p>Although it’s called zero, it is not always the number zero. Zero is some value that can be combined with other values without changing the original value. Here are some examples:</p>

<p>Integer addition - the zero value is actually 0</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 + 0 == 3
0 + 3 == 3
</code></pre></div></div>

<p>Integer multiplication - the zero value is now 1</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 * 1 == 3
1 * 3 == 3
</code></pre></div></div>

<p>Logication or - the zero value is true</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>true || true == true
false || true == true
</code></pre></div></div>

<p>String append - the zero value is the empty string “”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Justin" ++ "" = "Justin"
</code></pre></div></div>

<h3 id="monoids-in-scala">Monoids in Scala</h3>

<p>In Scala, we can implement Monoids as a Scala type class, a way to extend the behaviour of existing types. We will encode its operations as a trait. Note that this is an abstract definition. We will then define instances of Monoids that make concrete versions of the operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SemiGroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">op</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">SemiGroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">zero</span> <span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And a sample instance implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">intMultiply</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">zero</span> <span class="k">=</span> <span class="mi">1</span>
	<span class="k">def</span> <span class="nf">op</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">intMultiply</span><span class="o">.</span><span class="py">op</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">)</span> 
<span class="c1">// res1: Int = 200</span>

<span class="nv">intMultiply</span><span class="o">.</span><span class="py">op</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="nv">intMultiply</span><span class="o">.</span><span class="py">zero</span><span class="o">)</span> 
<span class="c1">//res2: Int = 10</span>
</code></pre></div></div>

<p>In our production code, we’ll use the Scalaz and Cats Monoid implementations instead of rolling our own. This gives us premade instances for many common types, syntactic sugar to make working with Monoids more concise, a bunch of useful combinators that we can use like fold and even automated law tests that verify our own instances obey the laws.</p>

<p>Let’s have a look at Scalaz for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="nv">Scalaz</span><span class="o">.</span><span class="py">_</span>

<span class="k">val</span> <span class="nv">l1</span> <span class="k">=</span> <span class="mi">10</span> <span class="o">|+|</span> <span class="mi">20</span> <span class="o">|+|</span> <span class="mi">30</span> 
<span class="c1">//res1: Int = 60 </span>

<span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">fold</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">30</span><span class="o">))</span>
<span class="c1">//res2: Int = 60</span>
</code></pre></div></div>

<p>In the example we first use the Monoid combine function using the syntax helper <code class="language-plaintext highlighter-rouge">|+|</code> and in the second we use the Scalaz <code class="language-plaintext highlighter-rouge">foldable</code> instance for list to do the same job. There is a Monoid instance defined for integer that implements addition, so that is used.</p>

<p>We could also define multiplication (or any other associative operation) and use that instead. For example, Scalaz has a Tag feature which lets us change the datatype of a thing at compile time only, and it can then pick up a different monoid implementation. <code class="language-plaintext highlighter-rouge">Tags.Multiplication</code> is a tag for numbers that has a Monoid instance that multiplies:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">l1</span><span class="o">.</span><span class="py">foldMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nv">Tags</span><span class="o">.</span><span class="py">Multiplication</span><span class="o">(</span><span class="n">a</span><span class="o">)}</span>
<span class="c1">// res3: Int @@ Tags.Multiplication = 6000</span>
</code></pre></div></div>

<p>Note that we use <code class="language-plaintext highlighter-rouge">foldMap</code> instead of <code class="language-plaintext highlighter-rouge">fold</code> here because we need to map a function over the list to add the multiplication tag. We could also just put a locally scoped implicit monoid for multiplication, but that would break type class coherence. See FP for Mortals for more on Tags and type class coherence. In Cats there is no Tags mechanism so you must find other ways to get your alternate implementations in scope.</p>

<p>Finally one more example from my sample code <code class="language-plaintext highlighter-rouge">MaxMonoid.scala</code>, a Monoid instance for the maximum of two numbers:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Foldable</span>
<span class="k">import</span> <span class="nn">scalaz.Monoid</span>
<span class="k">import</span> <span class="nn">scalaz.std.list._</span>
<span class="k">import</span> <span class="nn">scalaz.syntax.semigroup._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">maxIntMonoid</span> <span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Monoid</span><span class="o">.</span><span class="py">instance</span><span class="o">[</span><span class="kt">Int</span><span class="o">]({</span><span class="nf">case</span> <span class="o">(</span><span class="n">a</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">,</span><span class="n">b</span> <span class="k">:</span>  <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)}</span> <span class="o">,</span> <span class="nv">Int</span><span class="o">.</span><span class="py">MinValue</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">testAppend</span> <span class="k">=</span>  <span class="mi">10</span> <span class="o">|+|</span> <span class="mi">20</span>
<span class="c1">// res1: 20</span>
</code></pre></div></div>

<p>Scalaz provides a function <code class="language-plaintext highlighter-rouge">instance</code> that takes two arguments; the combine operation and the zero value for a type, so we can easily define a new Monoid instance. Note that we can’t import all of <code class="language-plaintext highlighter-rouge">scalaz._</code> like we did before because we don’t want to bring in the instance for <code class="language-plaintext highlighter-rouge">Monoid[Int]</code>. Once defined we can then use the fold over a list to find the max:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">l1</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,-</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">fold</span><span class="o">(</span><span class="n">l1</span><span class="o">)</span>
<span class="c1">// res1: 5</span>
</code></pre></div></div>

<p>Take a look at this post by Adam Warksi at Software Mill for more examples of Monoids and what you can do with fold:</p>

<p><a href="https://softwaremill.com/beautiful-folds-in-scala/">https://softwaremill.com/beautiful-folds-in-scala/</a></p>

<p><a name="production"></a></p>
<h3 id="monoids-in-production">Monoids in Production</h3>

<p>You already know how to append strings and add numbers, why bother with all this fancy abstraction? Well, first of all we saw above how having a Monoid implementation enables us to use a wider range of combinators like folds and traversals; our intentions are made clearer with less code. When it comes to our application business objects, that may have more complicated append methods and be nested in multiple data structures, we can see that the expressive power of Monoids is a great advantage over an imperative solution. Let’s take a look at a real example.</p>

<h4 id="taking-inventory">Taking Inventory</h4>

<p><img src="/../images/madlands_production.jpg" alt="ProductionItems" /></p>
<ul>
  <li>Image from Madlands - a former online iOS and Android game</li>
</ul>

<p>In many MMOG (massively multiplayer online games) you manage a city that contains plots of farmland that produce food, oil and so on. On the backend we need to store the things that the player owns in a database. When in memory we represent the
 inventory as a map, where the keys are the types of resources we own, and the values are the quantity.</p>

<p>For example we represent the players’ resources using integer ids:</p>

<ol>
  <li>Oil</li>
  <li>Gold</li>
  <li>Corn</li>
</ol>

<p>A player with just some gold would have an inventory like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.data._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">val</span> <span class="nv">inventory</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1000</span><span class="o">)</span>
</code></pre></div></div>

<p>Imagine that the player buys 1000 Oil and 1000 Corn and this will cost 200 gold. We could write some code that iterates over the players’ inventory map and updates the new values, create new keys as necessary for items the player didn’t have. But fortunately because there is a Monoid instance for Map, we can simply combine the player inventory map with the purchases and costs map to get the new inventory:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">updatedInventory</span> <span class="k">=</span> <span class="nv">inventory</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1000</span><span class="o">)).</span><span class="py">combine</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1000</span><span class="o">)).</span><span class="py">combine</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">200</span><span class="o">))</span> 
<span class="c1">//res2: Map(1 -&gt; 20, 2 -&gt; 600, 3 -&gt; 20)</span>
</code></pre></div></div>

<p>In this example we reduced the gold by 200 and granted the player 1000 of two types of resources. In fact we could simplify to just adding two maps together:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">updatedInventory</span> <span class="k">=</span> <span class="n">inventory</span> <span class="o">|+|</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1000</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1000</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">200</span><span class="o">)</span> 
<span class="c1">//res3: updatedInventory: Map[Int, Int] = Map(1 -&gt; 1000, 3 -&gt; 1000, 2 -&gt; 800)</span>
</code></pre></div></div>

<p>The implementation of Map for Monoid gathers togethers the values with the same key and appends them with Monoid, meaning anything with a Monoid can be combined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">" "</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"World"</span><span class="o">)</span>
<span class="c1">//res1: Map(1 -&gt; "Hello World")</span>
</code></pre></div></div>

<p>We can also fold it like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">fold</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"Hello"</span><span class="o">),</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">" "</span><span class="o">),</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"World"</span><span class="o">)))</span> 
<span class="c1">//res1: Map[Int, String] = Map(1 -&gt; "Hello World")</span>
</code></pre></div></div>

<h4 id="produced-items">Produced Items</h4>

<p>We stored the players inventory as a Map, and we can easily use Monoids to perform operations on inventories as well as lists of items and currencies. But also in our game the players had resources that increased or decreased over time. For example if you have a Level 1 Oil drill it produces oil at 10 units an hour. Over 10 hours it would accumulate 100 units of oil.</p>

<p><img src="/../images/oilproduction.png" alt="OilProduction" /></p>

<p>What we don’t want to do is have to constantly update the players production item count at some discrete interval. For one, that would be very costly on our servers, and for another we may want to show the resources increasing or decreasing in real time on the client.</p>

<p>In order to model this we can simply store the starting amount (this will be zero for a new oil drill), and the players rate of production. We also store the time the production began (when the oil drill is built).</p>

<p>With these three variables we can always calculate the current amount of the resource by the simple formula:</p>

<p><code class="language-plaintext highlighter-rouge">current_amount = initial_amount + (time_passed * production_rate)</code></p>

<p>Storing production items in this way means we can calculate the current value at any time to display it. Note that we can adjust the initial amount whenever we want by a positive or negative amount, and things will work out. But if we change the production rate then we need to update a few things. Firstly we calculate a new initial amount (the current amount from the calculation above). Then we store the current time, and adjust the production rate to the new one.</p>

<p>Whilst this is all straightforward, it complicates the adding and removing of items from the players inventory. We want to be able to remove 200 gold and add some resources just as we did before, and ideally we shouldn’t have to worry about things like what time it is and production rates.</p>

<p>Of course the solution is to model this by creating a Monoid instance for produced items, and that is what we did. There are two implementations and two demo programs to show the Scalaz and Cats implementations which have minor differences and caveats.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="n">snapshotAmount</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">snapshotTime</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">amountPerHour</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">currentAmount</span><span class="o">(</span><span class="k">implicit</span> <span class="n">clock</span><span class="k">:</span> <span class="kt">Clock</span><span class="o">)</span> <span class="k">=</span> 
        <span class="n">snapshotAmount</span> <span class="o">+</span> <span class="o">(((</span><span class="nv">clock</span><span class="o">.</span><span class="py">currentTimeMillis</span> <span class="o">-</span> <span class="n">snapshotTime</span><span class="o">)</span> <span class="o">/</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">)</span> <span class="o">*</span> <span class="n">amountPerHour</span><span class="o">).</span><span class="py">toLong</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here you can see the amount and time of the last snapshot as well as the production rate <code class="language-plaintext highlighter-rouge">amountPerHour</code>. The player’s current amount is no longer a static field, but a function that calculates the current amount based on the snapshot data. Note that we are passing in a Clock object implicitly. We’ll see why later but for now you just need to know that a clock is a datatype that lets us get the time so we can make the calculation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">monoidProducedItemOps</span><span class="o">(</span><span class="k">implicit</span> <span class="n">clock</span> <span class="k">:</span> <span class="kt">Clock</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">ProducedItem</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">empty</span> <span class="k">=</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">p1</span><span class="k">:</span> <span class="kt">ProducedItem</span><span class="o">,</span> <span class="n">p2</span><span class="k">:</span> <span class="kt">ProducedItem</span><span class="o">)</span> <span class="k">:</span> <span class="kt">ProducedItem</span> <span class="o">=</span> <span class="o">{</span>
            <span class="k">val</span> <span class="nv">p1A</span> <span class="k">=</span> <span class="nv">p1</span><span class="o">.</span><span class="py">currentAmount</span>
            <span class="k">val</span> <span class="nv">p2A</span> <span class="k">=</span> <span class="nv">p2</span><span class="o">.</span><span class="py">currentAmount</span>
    
            <span class="nc">ProducedItem</span><span class="o">(</span><span class="n">p1A</span> <span class="o">+</span> <span class="n">p2A</span><span class="o">,</span> <span class="nv">clock</span><span class="o">.</span><span class="py">currentTimeMillis</span><span class="o">,</span> <span class="nv">Math</span><span class="o">.</span><span class="py">max</span><span class="o">(</span><span class="nv">Math</span><span class="o">.</span><span class="py">abs</span><span class="o">(</span><span class="nv">p1</span><span class="o">.</span><span class="py">amountPerHour</span><span class="o">),</span> <span class="nv">Math</span><span class="o">.</span><span class="py">abs</span><span class="o">(</span><span class="nv">p2</span><span class="o">.</span><span class="py">amountPerHour</span><span class="o">)))</span>
        <span class="o">}</span>
    <span class="o">}</span>
	
</code></pre></div></div>

<p>Next we implement the Monoid instance for our new data type. The <code class="language-plaintext highlighter-rouge">zero</code> function is simply a ProducedItem with a snapshot at time zero, zero amount of stuff and zero production rate. While the <code class="language-plaintext highlighter-rouge">combine</code> (or <code class="language-plaintext highlighter-rouge">append</code> for scalaz) function is a bit more involved. It must calculate the current amount of both <code class="language-plaintext highlighter-rouge">ProducedItem</code>s. The new snapshot value will be the sum of those <code class="language-plaintext highlighter-rouge">p1A + p1A</code>. The new time snapshot will be right now, which we get from the clock, and the new production rate is simply the production rate with the most magnitude.</p>

<p>Just to explain that a little; in our use case production items always have the same production rate for the same player. Whenever the production rate changes for an item, we update all items of that type. So typically we will always have the same value on each side of a produced item type. However the zero value has no way to know the production rate, so simply taking the biggest one does what we need. You need to pay attention to details like this on your own Monoid instances to make sure the combine operation makes sense with respect to your business logic.</p>

<p>Now we have all we need to start adding ProducedItems (there are example programs in the source code, or you can do the following at the Scala console to try it out).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.monoid._</span>
<span class="k">import</span> <span class="nn">cats.instances.map._</span>
<span class="k">import</span> <span class="nn">org.justinhj.production._</span>
<span class="k">import</span> <span class="nn">org.justinhj.production.productioncats.ProducedItem</span>
<span class="k">import</span> <span class="nn">org.justinhj.production.productioncats.ProducedItem._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">clock</span> <span class="k">=</span> <span class="nc">FixedClock</span><span class="o">(</span><span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span> <span class="o">+</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">now</span> <span class="k">=</span> <span class="nv">clock</span><span class="o">.</span><span class="py">currentTimeMillis</span>
	
<span class="k">val</span> <span class="nv">inventory1</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
    <span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">now</span> <span class="o">-</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">,</span> <span class="mi">10</span><span class="o">),</span>
	<span class="mi">2</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">now</span> <span class="o">-</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
	
<span class="k">val</span> <span class="nv">inventory2</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
	<span class="mi">1</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
	<span class="mi">2</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
	<span class="mi">3</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">inventory3</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
    <span class="mi">3</span> <span class="o">-&gt;</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
	
<span class="k">val</span> <span class="nv">addInventories</span> <span class="k">=</span> <span class="n">inventory1</span> <span class="o">|+|</span> <span class="n">inventory2</span> <span class="o">|+|</span> <span class="n">inventory3</span> 
<span class="c1">// addInventories: Map[Int, ProducedItem] = Map(</span>
<span class="c1">//  1 -&gt; ProducedItem(15L, 1560220015450L, 10.0),</span>
<span class="c1">//  2 -&gt; ProducedItem(10L, 1560220015450L, 5.0),</span>
<span class="c1">//  3 -&gt; ProducedItem(2L, 1560220015450L, 0.0)</span>
</code></pre></div></div>

<p>Now we can easily combine our ProducedItem structures, and of course we now use other combinators like fold:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Foldable</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>

<span class="k">val</span> <span class="nv">listOfInventories</span> <span class="k">=</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="py">fold</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">inventory1</span><span class="o">,</span> <span class="n">inventory2</span><span class="o">,</span> <span class="n">inventory3</span><span class="o">))</span> 
<span class="c1">// listOfInventories: Map[Int, ProducedItem] = Map(</span>
<span class="c1">//   2 -&gt; ProducedItem(10L, 1560220015450L, 5.0),</span>
<span class="c1">//   1 -&gt; ProducedItem(15L, 1560220015450L, 10.0),</span>
<span class="c1">//   3 -&gt; ProducedItem(2L, 1560220015450L, 0.0)</span>
<span class="c1">// )</span>
</code></pre></div></div>

<h3 id="the-test-of-time">The test of time</h3>

<p>As promised we return to the Clock data type. This is implemented in <code class="language-plaintext highlighter-rouge">production.Clock.scala</code> and provides the following simple function to get the time:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Clock</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">currentTimeMillis</span> <span class="k">:</span> <span class="kt">Long</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>There are two implementations; firstly there is a SystemClock, so called because it returns the system time. This one will be used in production so that your players corn grows correctly. The second is FixedClock which always returns the same time. This is to make testing easier. We want to be able to start our corn growing then check if it grew the right amount an hour later, and of course we don’t want the tests to run in real time. To get around this if you check my test classes such as <code class="language-plaintext highlighter-rouge">org.justinhj.production.ProducedItemTestCats</code> you can see that I that I make a fixed time clock with the current time and then set my test items to have a snapshot time of one hour ago. Having strict control over time like this is vital to testing time and date related logic in a principled way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">clock</span> <span class="k">=</span> <span class="nc">FixedClock</span><span class="o">(</span><span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">now</span> <span class="k">=</span> <span class="nv">clock</span><span class="o">.</span><span class="py">currentTimeMillis</span>
<span class="k">val</span> <span class="nv">pi</span> <span class="k">=</span> <span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">now</span> <span class="o">-</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="checking-monoids-are-lawful">Checking Monoids are lawful</h3>

<p>The beauty of functional programming is we can build up solid foundations like this, and then go ahead and compose more complex programs from our simple lawful data types. But one caveat, did we implement a lawful Monoid? In order to make sure, I have include tests in both Scalaz and Cats style to show you how to use each library’s law checking facilities.</p>

<p>In this example we will use Cats. Instructions for this are here <a href="https://typelevel.org/cats/typeclasses/lawtesting.html">https://typelevel.org/cats/typeclasses/lawtesting.html</a> but you can also follow my working example in the code.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProducedItemLawTestsCats</span> <span class="k">extends</span> <span class="nc">CatsSuite</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nv">clock</span> <span class="k">=</span> <span class="nc">FixedClock</span><span class="o">(</span><span class="nv">System</span><span class="o">.</span><span class="py">currentTimeMillis</span> <span class="o">+</span> <span class="nv">Clock</span><span class="o">.</span><span class="py">oneHourMillis</span><span class="o">)</span>
  <span class="nf">checkAll</span><span class="o">(</span><span class="s">"ProducedItem.MonoidLaws"</span><span class="o">,</span> <span class="nc">MonoidTests</span><span class="o">[</span><span class="kt">ProducedItem</span><span class="o">].</span><span class="py">monoid</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>With the correct imports and library dependencies you can now access <code class="language-plaintext highlighter-rouge">MonoidTests[ProducedItem].monoid</code> which will contain tests for each of the Monoid laws. It will in addition use Scalacheck to generate many random instances of your classes to give thorough empirical testing of whether the laws hold. Of course this check will not guarantee that your laws hold but it will certainly help you feel confident. Ultimately Scala leaves it as an exercise to the programmer to ensure that the laws are valid and automated testing is no substitute for your own reasoning. Note that in order to generate the tests we need an <code class="language-plaintext highlighter-rouge">Eq</code> instance for our data type which allows them to be tested for equality. We can automatically generate one that just compares each field of the class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">eqProducedItem</span> <span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">ProducedItem</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Eq</span><span class="o">.</span><span class="py">fromUniversalEquals</span>
</code></pre></div></div>

<p>Now we can run our test suite and bask in the glory of our own brilliance…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] - ProducedItem.MonoidLaws.monoid.left identity *** FAILED ***
[info]   GeneratorDrivenPropertyCheckFailedException was thrown during property evaluation.
[info]    (Discipline.scala:14)
[info]     Falsified after 0 successful property evaluations.
[info]     Location: (Discipline.scala:14)
[info]     Occurred when passed generated values (
[info]       arg0 = ProducedItem(4960954082650183831,1,1.5706606739076523E-208)
[info]     )
[info]     Label of failing property:
[info]       Expected: ProducedItem(4960954082650183831,1,1.5706606739076523E-208)
[info]   Received: ProducedItem(4960954082650183831,1560221194037,1.5706606739076523E-208)
</code></pre></div></div>

<p>Oh, no! What happened? It seems our laws do not hold, for left and right identity and other things besides. After a little thought it becomes clear, when we combine a ProducedItem with the zero value it should not change the original item.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">now</span> <span class="k">=</span> <span class="mi">1560221355576L</span>
<span class="k">val</span> <span class="nv">oneHourAgo</span> <span class="k">=</span> <span class="mi">1560217755576L</span>
<span class="nc">ProducedItem</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">oneHourAgo</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">ProducedItem</span><span class="o">].</span><span class="py">empty</span> 
<span class="c1">// ProducedItem = ProducedItem(20L, 1560221355576L, 10.0)</span>
</code></pre></div></div>

<p>Clearly, we can see that this is not correct. When we combined the two items we took a new snapshot and the time changed to now! So we changed the equality from true to false and broke the identity laws. At the beginning of this exercise we came up with a data structure that helps us represent items that increase or decrease over time, and in doing so we introduced these new variables. On the other hand from a business logic point of view, two produced items are the same if (and only if) their current amounts are the same. We don’t care about production rate or snapshot time or event current snapshot value.</p>

<p>Let’s rewrite our equals check to take this insight into account:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">eqProducedItem</span><span class="o">(</span><span class="k">implicit</span> <span class="n">clock</span> <span class="k">:</span> <span class="kt">Clock</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Eq</span><span class="o">[</span><span class="kt">ProducedItem</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eqv</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">ProducedItem</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">ProducedItem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nv">x</span><span class="o">.</span><span class="py">currentAmount</span> <span class="o">==</span> <span class="nv">y</span><span class="o">.</span><span class="py">currentAmount</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And rerunning the tests we can see the tests are now all green!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] ProducedItemLawTestsCats:
[info] - ProducedItem.MonoidLaws.monoid.associative
[info] - ProducedItem.MonoidLaws.monoid.collect0
[info] - ProducedItem.MonoidLaws.monoid.combine all
[info] - ProducedItem.MonoidLaws.monoid.combineAllOption
[info] - ProducedItem.MonoidLaws.monoid.is id
[info] - ProducedItem.MonoidLaws.monoid.left identity
[info] - ProducedItem.MonoidLaws.monoid.repeat0
[info] - ProducedItem.MonoidLaws.monoid.repeat1
[info] - ProducedItem.MonoidLaws.monoid.repeat2
[info] - ProducedItem.MonoidLaws.monoid.right identity
</code></pre></div></div>

<p>Check the Scalaz tests to see very similar code in action.</p>

<h3 id="the-end">The End</h3>

<p>This has been a small sample of how Monoids can help simplify your code, and make it more composable. Thank you for reading this post, please let me know via the links at the top if you have any questions or comments!</p>

<p>For more reading on Monoids check the books below. I also highly recommend this conference talk by Markus Haulck that shows some nice composition tricks Monoids
<a href="https://youtu.be/sHV4qhbZHgo">When Everything Fits: The Beauty of Composition - Markus Hauck</a></p>

<h3 id="footnotes">Footnotes</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in Scala</a> (the Red Book) by Runar Bjarnsen and Paul Chiusano covers functional programming from first principles as you build your own implementations of immutable lists and options, before showing how to develop useful libraries in a pure functional style. Examples include a json parser and concurrency library. Next we are guided through all of the most common type classes like Functor, Monad, Applicative… what are their laws, what operations can be implemented. Finally we are shown how to control side effects using the IO Monad and the book ends with a sophisticated streaming IO implementation. Manning Publications now have a “livebook” version of the book where you can complete the (essential) exercises directly on the web page as you read. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://leanpub.com/fpmortals">Functional Programming for Mortals</a> by Sam Haliday is a practical and principiled guide to building systems with Scala using Scalaz. A real world example application is developed throughout the book, which also functions as a manual to Scalaz, demonstrating each type class in some realistic scenario. It will also appeal to Star Wars fans as Sam helpfully tells us what symbols like <code class="language-plaintext highlighter-rouge">|+|</code>, <code class="language-plaintext highlighter-rouge">&lt;+&gt;</code> and <code class="language-plaintext highlighter-rouge">@@</code> represent both in Scalaz and in the Star Wars universe. Whilst aimed at mortals it will require some experience in Scala to hit the ground running. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://books.underscore.io/scala-with-cats/scala-with-cats.html">Advanced Scala for Cats</a> by Noel Walsh and Dave Gurnell is a lighter book than the other two but covers the common type classes clearly and concisely. Rather than covering one big example application, small but realistic examples are given for the various features. Obviously from the title this focuses on the Cats library. Like the red book, this also contains exercises, althought they are not as rigorous or as difficult. This book accompanies Underscores training course. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-6582321-6', 'auto');
  ga('send', 'pageview');

</script>

</article>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">


  </div>

</footer>


  </body>

</html>
