<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  <title>Comonads for Life</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4003/2019/06/20/comonads-for-life.html">
  <link rel="alternate" type="application/rss+xml" title="Functional[Justin]" href="http://localhost:4003/feed.xml">
</head>


  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-YDJ0HSM9M6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-YDJ0HSM9M6');
  </script>

  <body>

    <header class="site-header">
  
    <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-3">
	<h5><a class="site-title" href="/">Functional[Justin]</a></h5>
      </div>
    </div>

    <div class="footer-col-wrapper">
      
      <div class="footer-col footer-col-1">
        <p>
          <img class="circle" width="110px" src="/images/justinnew.png"/></p>

      </div>
      
      <div class="footer-col footer-col-2">
        <p>Justin is a British/Canadian software engineer at Treasure Data, functional programming, polyglot, Neovim and Emacs. </p>
      </div>
      
      <div class="footer-col footer-col-3">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/justinhj"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">justinhj</span></a>

          </li>
          
	  
	  <li>
	    <a href="mailto:justinhj+blog@gmail.com">
	      <span class="icon">
		<img src="/images/email.png"/>
	      </span>
	      <span class="username">
		justinhj@gmail.com
	      </span>
	    </a>
	  </li>

          <li>
            <a href="https://gitter.im/justinhj">
            <span class="icon">
              <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 98.7 16.3" data-v-44ebcb1a=""><g><path d="M20.9,0.3h2.6v15.8h-2.6V0.3z"></path> <path d="M34.8,2.9h-4V0.3h11.8v2.6h-5.2v13.2h-2.6V2.9z"></path> <path d="M51.9,2.9h-4V0.3h11.8v2.6h-5.2v13.2h-2.6V2.9z"></path> <path d="M66.4,0.3h11.8v2.6H69v3.9h7.9v2.6H69v4h9.2v2.6H66.4V0.3z"></path> <path d="M98.7,16.1l-4.2-5.9c1.7-0.9,2.8-2.5,2.8-4.6c0-3.1-2.5-5.3-5.7-5.3l-6.2,0v15.8h2.6l0-5.3
    c0,0,3.6,0,3.6,0l3.8,5.3H98.7z M88.1,8.2l0-5.3l3.5,0c1.7,0,3,1,3,2.6c0,1.7-1.4,2.6-3,2.6L88.1,8.2z"></path> <path d="M7.9,7.1v2.6l3.9,0c0,0,0,1.4,0,2.3c-0.1,0.2-0.4,1.8-3.8,1.8c-0.2,0-0.3,0-0.5,0
    c-0.1,0-0.2,0-0.2,0c-0.1,0-0.2,0-0.2,0c-0.1,0-0.2-0.1-0.3-0.1c-0.1,0-0.1,0-0.2-0.1c0,0-0.1,0-0.1,0c-2.1-0.7-3.5-2.8-3.5-5.3
    l0,0v0v0c0-0.3,0-0.5,0.1-0.8C3.3,4.7,5.4,2.5,8,2.5c0.9,0,2.5,0.3,3.6,1.5l1.5-2.2c0,0-1.3-1.9-5-1.9C3.7,0,0.4,3.3,0,7.3
    c0,0.3,0,0.6,0,0.8l0,0l0,0c0,4.3,3.2,7.9,7.7,8.1c0.2,0,0.3,0,0.5,0c0,0,0.1,0,0.1,0c0.3,0,0.5,0,0.7,0c0.1,0,0.2,0,0.3,0
    c0.2,0,0.3,0,0.5-0.1c2.7-0.1,4.7-2.3,4.7-3.4c0-5,0-5.7,0-5.7H7.9z"></path></g></svg>
            </span>
            <span class="username">
              justinhj
            </span>
</a>
          </li>
	  <li>
	    <a href="https://www.linkedin.com/in/justinheyesjones">
	      <span class="icon">
		<img src="/images/linkedin.png"/>
	      </span>
	      <span class="username">
		LinkedIn
	      </span>
	    </a>
	  </li>

	  
          <li>
            <a href="https://twitter.com/justinhj"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">justinhj</span></a>

          </li>
          

	  
        </ul>
      </div>
      
    </div>

    <div class="my-links">
      <span class="page-link">
      	<a href="/index.html">Posts by Date</a>
       </span>

      <span class="page-link">
      	<a href="/topposts.html">Popular Posts</a>
      </span>

      <span class="page-link">
      	<a href="https://www.youtube.com/c/FunctionalJustin">YouTube channel</a>
       </span>

      <span class="page-link">
      	<a href="/talks.html">Speaking Events</a>
       </span>

      <span class="page-link">
      	<a href="/privacy.html">Privacy</a>
      </span>

      </div>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        

  

  <!-- Iterate over the tags in this post -->
  



<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Comonads for Life</h1>
    <p class="post-meta"><time datetime="2019-06-20T00:00:00-07:00" itemprop="datePublished">Jun 20, 2019</time></p>
    <div class="post-meta">
      
        
        
        
        
        
        
        More posts about
    
      <i class="fa fa-tags"></i>
    
  
        <a href="/tag/scala/">
        Scala</a>
        
          ,
        
      
        <a href="/tag/functional-programming/">
        Functional Programming</a>
        
          ,
        
      
        <a href="/tag/comonads/">
        Comonads</a>
        
          ,
        
      
        <a href="/tag/pure-functional-programming/">
        Pure Functional Programming</a>
        
          ,
        
      
        <a href="/tag/typelevel/">
        Typelevel</a>
        
          ,
        
      
        <a href="/tag/cats/">
        Cats</a>
        
          ,
        
      
        <a href="/tag/zio/">
        Zio</a>
        
      
    </div>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><img src="/../images/comonads.jpg" alt="Comonads" title="Comonads" /></p>

<p>This post is aimed at the Scala programmer with some experience pure functional programming with the Cats fp library: <a href="https://typelevel.org/cats/">https://typelevel.org/cats/</a>. We will look at Comonads, a type class closely related to Monads, firstly from an abstract point of view and progressing to a couple of practical, yet simple, examples of using Comonads for interesting applications.</p>

<p><em>Example code used in this post is from this github project:</em></p>
<ul>
  <li><a href="https://github.com/justinhj/comonad/tree/blog-final-2">https://github.com/justinhj/comonad</a></li>
</ul>

<p><em>Presentation based on this post from the Vancouver Scala Meetup:</em></p>
<ul>
  <li><a href="https://justinhj.github.io/comonad-sm-reveal/">https://justinhj.github.io/comonad-sm-reveal/</a></li>
</ul>

<h2 id="monads">Monads</h2>

<p>To explain comonads, a good place to start is how they relate to monads. In order to get from monad to comonad, we define operations that are the <code class="language-plaintext highlighter-rouge">dual</code> of those in monad. By dual, we mean that the direction of the data flows is reversed.</p>

<p>The Functor type class has a single operation <code class="language-plaintext highlighter-rouge">map</code> which lets us take a pure function that converts pure values <code class="language-plaintext highlighter-rouge">A</code> to pure values of type <code class="language-plaintext highlighter-rouge">B</code>, and as you can see from the type signature it does so in some context <code class="language-plaintext highlighter-rouge">F</code>. Examples of a context could be lists, asynchronous or deferred calculations (Future, Cats Effect, ZIO, Monix Task) and options. For our simple example we will consider lists of things as our context but bear in mind that contexts are not always simple containers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="k">⇒</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Examples of using a map would be to map a list of strings into a list of numbers (the length of those strings)…</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="nc">List</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">","</span><span class="o">,</span> <span class="s">"how"</span><span class="o">,</span> <span class="s">" "</span><span class="o">,</span> <span class="s">"are"</span><span class="o">,</span> <span class="s">"you"</span><span class="o">,</span> <span class="s">"?"</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">size</span><span class="o">)</span> 
<span class="c1">// List[Int] = List(5, 1, 3, 1, 3, 3, 1)</span>
</code></pre></div></div>

<p>Monads are all Functors, so we can can define it as an extension of Functor, being assured that it has a definition of map. How can we be sure? Well it is possible to implement map using pure and flatmap, we’ll see that shortly, which proves that all monads are functors.</p>

<p>Here’s the type class definition for Monad.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">def</span> <span class="nf">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
	<span class="k">def</span> <span class="nf">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="k">⇒</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Aside from map, Monads must implement <code class="language-plaintext highlighter-rouge">pure</code> which lifts a pure value of type <code class="language-plaintext highlighter-rouge">A</code> into the effect context <code class="language-plaintext highlighter-rouge">F</code>. What that means for collection types like list, is that it creates a new collection containing only that element. Generally, implementing pure for a data type involves calling a type constructor for <code class="language-plaintext highlighter-rouge">F</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">10.</span><span class="n">pure</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> 
<span class="c1">// List[Int] = List(10)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">flatmap</code>, as you can see from the types, takes a pure value <code class="language-plaintext highlighter-rouge">A</code> in a context <code class="language-plaintext highlighter-rouge">F</code> and applies a user supplied function to it. The function has the signature <code class="language-plaintext highlighter-rouge">A =&gt; F[B]</code>; in other words functions that take a pure value and lifts them into the context. The return value is the new pure value <code class="language-plaintext highlighter-rouge">B</code> lifted into that same <code class="language-plaintext highlighter-rouge">F</code> context.</p>

<p>Concretely, imagine a function that takes an integer and returns the digits of the string as a list. That function would match the signature <code class="language-plaintext highlighter-rouge">A =&gt; F[B]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">intToDigits</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nv">n</span><span class="o">.</span><span class="py">toString</span><span class="o">.</span><span class="py">toList</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">toString</span><span class="o">.</span><span class="py">toInt</span><span class="o">)</span>
<span class="o">}</span>

<span class="nf">intToDigits</span><span class="o">(</span><span class="mi">1001</span><span class="o">)</span> 
<span class="c1">// List[Int] = List(1, 0, 0, 1)</span>
</code></pre></div></div>

<p>Functions that take pure values and return their results lifted into a context are quite common, and often we want to chain the together. If you have a function that takes a user id and has to go to a DB it will likely return something like a <code class="language-plaintext highlighter-rouge">IO[User]</code>. Often these DB lookups need to be chained together, where each cannot begin until the one before it because it is dependent on some value returned from a previous step. Chaining together effectful functions like this is what flatMap does. To give a concrete example of this chaining we need a second function that we can chain with <code class="language-plaintext highlighter-rouge">intToDigits</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">intToRepeat</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">n</span><span class="o">)(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>

<span class="nf">intToRepeat</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> 
<span class="c1">// List[Int] = List(5, 5, 5, 5, 5)</span>

<span class="nf">intToDigits</span><span class="o">(</span><span class="mi">12345</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">intToRepeat</span><span class="o">)</span> 
<span class="c1">// List[Int] = List(1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5)</span>
</code></pre></div></div>

<p>Just to enforce why we need flatMap here let’s look at what happens if we use map instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">intToDigits</span><span class="o">(</span><span class="mi">12345</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">intToRepeat</span><span class="o">)</span> 
<span class="c1">// List[List[Int]] = List(List(1), List(2, 2), List(3, 3, 3), List(4, 4, 4, 4), List(5, 5, 5, 5, 5))</span>
</code></pre></div></div>

<p>As you can see what happened here is we ended up with a nested context <code class="language-plaintext highlighter-rouge">F[F[A]]</code> instead of what we wanted, <code class="language-plaintext highlighter-rouge">F[A]</code>. The reason flatMap is so named is that it can be implemented by first mapping each <code class="language-plaintext highlighter-rouge">A</code> to a <code class="language-plaintext highlighter-rouge">F[A]</code> giving the <code class="language-plaintext highlighter-rouge">F[F[A]]</code> then flattening in it to an <code class="language-plaintext highlighter-rouge">F[A]</code>.</p>

<p>In fact <code class="language-plaintext highlighter-rouge">flatten</code> is implemented for monad in Cats, and the standard library for that matter, and when we get to comonads it will be helpful to implement it’s dual, which we shall call <code class="language-plaintext highlighter-rouge">coflatten</code>.</p>

<p>We are done with monads for now, but just going back to what I said before about monads being functors, here’s how we can implement map in terms of pure and flatmap.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">n</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span> <span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nv">n</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="py">pure</span><span class="o">[</span><span class="kt">List</span><span class="o">])</span> 

<span class="n">map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">](</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> 
<span class="c1">//List[Int] = List(2, 3, 4)</span>
</code></pre></div></div>

<h2 id="comonads">Comonads</h2>

<p>From an abstract point of view Monads allow us to chain effects, and to lift pure values into effects. Let’s now consider Comonads and their dual operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">extract</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="nf">coflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">extract</code> is the dual of <code class="language-plaintext highlighter-rouge">pure</code>. In some libraries or languages <code class="language-plaintext highlighter-rouge">extract</code> is known as <code class="language-plaintext highlighter-rouge">counit</code> (and <code class="language-plaintext highlighter-rouge">pure</code> is known as <code class="language-plaintext highlighter-rouge">unit</code>), making the relationship between the two more obvious. Remember that pure lifts values into a context. The type signature shows us that <code class="language-plaintext highlighter-rouge">extract</code> instead can reach into the context <code class="language-plaintext highlighter-rouge">F[A]</code> and give us an <code class="language-plaintext highlighter-rouge">A</code>. Not all data types have an implementation of extract. Our example of List above does not, because Lists can be empty and the there would be no way to extract a value. In pure functional programming we can’t simply return null or throw an exception; in order to remain pure we have to return an <code class="language-plaintext highlighter-rouge">A</code>, so any data types that cannot implement extract do not have Comonad instances.</p>

<p>For our purposes let’s switch to <code class="language-plaintext highlighter-rouge">NonEmptyList</code>, which you can find in Cats and represents a list that cannot be empty. Since it cannot be empty we can always extract a value.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.NonEmptyList</span>

<span class="k">val</span> <span class="nv">nel1</span> <span class="k">=</span> <span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span> 
<span class="c1">// NonEmptyList[Int] = NonEmptyList(1, List(2, 3, 4, 5))</span>

<span class="nv">nel1</span><span class="o">.</span><span class="py">extract</span> 
<span class="c1">// Int = 1</span>
</code></pre></div></div>

<p>I found <code class="language-plaintext highlighter-rouge">extract</code> is simple to understand, but <code class="language-plaintext highlighter-rouge">coflatMap</code> takes some mental gymnastics to follow. Before we consider that, let’s look at <code class="language-plaintext highlighter-rouge">coflatten</code>, the dual of <code class="language-plaintext highlighter-rouge">flatten</code>. Remember that <code class="language-plaintext highlighter-rouge">flatten</code> made it easy for us to implement <code class="language-plaintext highlighter-rouge">flatMap</code> which requires a way to reduce a nested structure by one level. As you can see from the type signature, a <code class="language-plaintext highlighter-rouge">coflatten</code> takes a value <code class="language-plaintext highlighter-rouge">A</code> in a context and returns it in a nested context.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">coflatten</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</code></pre></div></div>

<p>When implementing Comonad’s for our own data types we need to make a decision on how to take a structure and create a nested version of it. This is not totally arbitrary, as Comonads have a set of laws like Monads, and so our implementation must satisfy those laws. As we’ll see shortly, a way to make a lawful Comonad for NonEmptyList is for the <code class="language-plaintext highlighter-rouge">coflatten</code> to create a <code class="language-plaintext highlighter-rouge">NonEmptyList[NonEmptyList[A]]]</code> which is a list of the original list and all of its suffixes (tails).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">nel1</span> <span class="k">=</span> <span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>  
<span class="c1">//NonEmptyList[Int] = NonEmptyList(1, List(2, 3, 4, 5))</span>

<span class="nv">nel1</span><span class="o">.</span><span class="py">coflatten</span> 
<span class="c1">// NonEmptyList[NonEmptyList[Int]] = NonEmptyList(</span>
<span class="c1">//  NonEmptyList(1, List(2, 3, 4, 5)),</span>
<span class="c1">//  List(NonEmptyList(2, List(3, 4, 5)), NonEmptyList(3, List(4, 5)), NonEmptyList(4, List(5)), NonEmptyList(5, List()))</span>
<span class="c1">// )</span>
</code></pre></div></div>

<p>One of the comonad laws is the left identity which specifies <code class="language-plaintext highlighter-rouge">fa.coflatten.extract &lt;-&gt; fa</code>. (All of the laws can be checked using the <a href="https://github.com/typelevel/cats/blob/master/laws/src/main/scala/cats/laws/ComonadLaws.scala">ComonadLaws</a> in Cats). You can see that this makes sense in terms of the implementation of NonEmptyList above.</p>

<p>Once we have the <code class="language-plaintext highlighter-rouge">coflatten</code> implementation for a type we can implement <code class="language-plaintext highlighter-rouge">coflatMap</code>. Based on the signature <code class="language-plaintext highlighter-rouge">def coflatMap[A, B](fa: F[A])(f: F[A] =&gt; B): F[B]</code> you can see that, just like <code class="language-plaintext highlighter-rouge">extract</code>, we have just reversed the direction of data flow from <code class="language-plaintext highlighter-rouge">A =&gt; F[B]</code> to <code class="language-plaintext highlighter-rouge">F[A] =&gt; B</code>. That means the caller of the function is going provide a function that gets to look at each suffix of the NonEmptyList and combine each to a single value of type <code class="language-plaintext highlighter-rouge">B</code>. Those values are returned to the user in a new NonEmptyList. For example taking the size of a NonEmptyList matches the type signature.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="py">coflatMap</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">size</span><span class="o">)</span> 
<span class="c1">//NonEmptyList[Int] = NonEmptyList(5, List(4, 3, 2, 1))</span>
</code></pre></div></div>

<p>Notice that when you flatMap a list, the mapping part looks at the list one element at a time, transforming it to a list. When you coflatMap a list you’re looking at the list and all of its tails one by one, collapsing each of them down into a single value.</p>

<h3 id="comonad-laws">Comonad laws</h3>

<p>In this section I’ll demonstrate each of the Comonad laws in code using <code class="language-plaintext highlighter-rouge">NonEmptyList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">fa</span> <span class="k">=</span> <span class="nv">NonEmptyList</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span> 
<span class="c1">// fa: NonEmptyList[Int] = NonEmptyList(1, List(2, 3, 4))</span>
</code></pre></div></div>
<p>Left identity: <code class="language-plaintext highlighter-rouge">fa.coflatten.extract == fa</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">fa</span><span class="o">.</span><span class="py">coflatten</span><span class="o">.</span><span class="py">extract</span> <span class="o">==</span> <span class="n">fa</span> 
<span class="c1">// Boolean = true</span>
</code></pre></div></div>

<p>Right identity: <code class="language-plaintext highlighter-rouge">fa.coflatmap(extract) == fa</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">fa</span><span class="o">.</span><span class="py">coflatMap</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">extract</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span> 
<span class="c1">// Boolean = true</span>
</code></pre></div></div>

<p>Associativity: <code class="language-plaintext highlighter-rouge">fa.coflatten.coflatten == fa.coflatmap(coflatten)</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">fa</span><span class="o">.</span><span class="py">coflatten</span><span class="o">.</span><span class="py">coflatten</span> <span class="o">==</span> <span class="nv">fa</span><span class="o">.</span><span class="py">coflatMap</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">coflatten</span><span class="o">)</span> 
<span class="c1">// Boolean = true</span>
</code></pre></div></div>

<p>Cats contains implementations of checks for these laws which can be found here: <a href="https://github.com/typelevel/cats/blob/master/laws/src/main/scala/cats/laws/ComonadLaws.scala">https://github.com/typelevel/cats/blob/master/laws/src/main/scala/cats/laws/ComonadLaws.scala</a> You can checkout my last post for how to setup a Scalacheck test for your own datatypes using Cats <a href="/2019/06/10/monoids-for-production.html">Monoids for Production</a></p>

<h2 id="image-processing-with-a-comonad">Image processing with a Comonad</h2>

<p>I created a data type, <code class="language-plaintext highlighter-rouge">FocusedGrid</code>, which consists of a 2d grid of values of some type <code class="language-plaintext highlighter-rouge">A</code> and a focus point which will be a <code class="language-plaintext highlighter-rouge">Tuple2[Int, Int]</code>. This focus point specifies a row and column of the grid.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">focus</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">],</span> <span class="n">grid</span> <span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<p>Next we implement the Comomad (and Functor) operations for our new type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="nv">focusedGridComonad</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">FocusedGrid</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="nc">FocusedGrid</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">focus</span><span class="o">,</span> <span class="nv">fa</span><span class="o">.</span><span class="py">grid</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">row</span> <span class="k">=&gt;</span> <span class="nv">row</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">a</span><span class="o">))))</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">coflatten</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="nv">grid</span> <span class="k">=</span> <span class="nv">fa</span><span class="o">.</span><span class="py">grid</span><span class="o">.</span><span class="py">mapWithIndex</span><span class="o">((</span><span class="n">row</span><span class="o">,</span> <span class="n">ri</span><span class="o">)</span> <span class="k">=&gt;</span> 
        <span class="nv">row</span><span class="o">.</span><span class="py">mapWithIndex</span><span class="o">((</span><span class="n">col</span><span class="o">,</span> <span class="n">ci</span><span class="o">)</span> <span class="k">=&gt;</span> 
          <span class="nc">FocusedGrid</span><span class="o">((</span><span class="n">ri</span><span class="o">,</span><span class="n">ci</span><span class="o">),</span> <span class="nv">fa</span><span class="o">.</span><span class="py">grid</span><span class="o">)))</span>
      <span class="nc">FocusedGrid</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">focus</span><span class="o">,</span> <span class="n">grid</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// Gives us all of the possible foci for this grid</span>
    <span class="k">def</span> <span class="nf">coflatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
     <span class="k">val</span> <span class="nv">grid</span> <span class="k">=</span> <span class="nf">coflatten</span><span class="o">(</span><span class="n">fa</span><span class="o">).</span><span class="py">grid</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">col</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="o">(</span><span class="n">col</span><span class="o">)))</span>
      <span class="nc">FocusedGrid</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">focus</span><span class="o">,</span>  <span class="n">grid</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// extract simply returns the A at the focus</span>
    <span class="k">def</span> <span class="nf">extract</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nv">fa</span><span class="o">.</span><span class="py">grid</span><span class="o">(</span><span class="nv">fa</span><span class="o">.</span><span class="py">focus</span><span class="o">.</span><span class="py">_1</span><span class="o">)(</span><span class="nv">fa</span><span class="o">.</span><span class="py">focus</span><span class="o">.</span><span class="py">_2</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">extract</code> is the simplest operation and simply returns the grid value at the focus.</p>

<p>Looking at the type signature for <code class="language-plaintext highlighter-rouge">coflatten</code> you can see that it does what we expect; creates a FocusedGrid of FocusedGrids. We iterate through each row and column using <code class="language-plaintext highlighter-rouge">mapWithIndex</code> so that we can set the appropriate focus at each point. Note that the grid itself will not be duplicated in memory for each Vector, just a reference will be added. What is different at each row and column is the focus. Here’s an example of a coflattened FocusedGrid.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">))).</span><span class="py">coflatten</span>

<span class="nc">FocusedGrid</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
  <span class="nc">Vector</span><span class="o">(</span>
    <span class="nc">Vector</span><span class="o">(</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span>
    <span class="o">),</span>
    <span class="nc">Vector</span><span class="o">(</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span>
    <span class="o">),</span>
    <span class="nc">Vector</span><span class="o">(</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))),</span>
      <span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>
</code></pre></div></div>

<p>Once <code class="language-plaintext highlighter-rouge">coflatten</code> is available, the implementation of <code class="language-plaintext highlighter-rouge">coflatMap</code> follows by simply executing <code class="language-plaintext highlighter-rouge">coflatten</code> then <code class="language-plaintext highlighter-rouge">map</code>. Notice how this is the reverse of Monad’s flatmap, which maps first and then flattens.</p>

<p>Now that FocusedGrid is a Comonad, what can we do with it? Note the function signature for <code class="language-plaintext highlighter-rouge">f</code> is <code class="language-plaintext highlighter-rouge">FocusedGrid[A] =&gt; B</code>. That means we can write a function that looks at the whole grid and lets do a calculation <em>from the point of view of the focus</em> and create a single value of type <code class="language-plaintext highlighter-rouge">B</code>, which will be the new value of the final grid at that position.</p>

<p>The full implementation can be found here: <a href="https://github.com/justinhj/comonad/blob/blog-final-2/src/main/scala/org/justinhj/FocusedGrid.scala">FocusedGrid.scala</a></p>

<h3 id="image-smoothing">Image smoothing</h3>

<p>We can map image data directly to our FocusedGrid data type, and then use it to do image processing. A simple example is a box filter, which can be used to smooth out noise in images. In this implementation, which you can find in the file <a href="https://github.com/justinhj/comonad/blob/blog-final-2/src/main/scala/org/justinhj/ImageProcessor.scala">ImageProcessor.scala</a>, we will load an image file, copy the image data to a FocusedGrid, and then write the filter using the function signature <code class="language-plaintext highlighter-rouge">FocusedGrid[(Int,Int,Int) =&gt; (Int,Int,Int)</code>. Note that we represent image pixels as a tuple containing the red, green and blue components.</p>

<p>Here’s the implementation of boxfilter. You pass in the width of the filter and it will then average the pixels for a square of the provide width (and height) and set each pixel to that average. The function <code class="language-plaintext highlighter-rouge">localSum</code> handles the summing the values found around the current focus, and then we create the new pixel by dividing to get the mean.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">boxFilter</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">fg</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">widthSqr</span> <span class="k">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">width</span>
    <span class="k">val</span> <span class="nv">sum</span> <span class="k">=</span> <span class="nf">localSum</span><span class="o">(</span><span class="n">fg</span><span class="o">,</span> <span class="o">(</span><span class="mi">255</span><span class="o">,</span> <span class="mi">255</span><span class="o">,</span> <span class="mi">255</span><span class="o">),</span> <span class="n">width</span><span class="o">)</span>
    <span class="o">((</span><span class="nv">sum</span><span class="o">.</span><span class="py">_1</span> <span class="o">/</span> <span class="n">widthSqr</span><span class="o">).</span><span class="py">toInt</span><span class="o">,</span> <span class="o">(</span><span class="nv">sum</span><span class="o">.</span><span class="py">_2</span> <span class="o">/</span> <span class="n">widthSqr</span><span class="o">).</span><span class="py">toInt</span><span class="o">,</span> <span class="o">(</span><span class="nv">sum</span><span class="o">.</span><span class="py">_3</span> <span class="o">/</span> <span class="n">widthSqr</span><span class="o">).</span><span class="py">toInt</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Here is the original image and some smoothed examples at various box filter sizes:</p>

<p><img src="/../images/girl.png" alt="Original" title="Original" /></p>

<p><img src="/../images/girlsmoothed5.png" alt="Filter size 5" title="Filter size 5" /></p>

<p><img src="/../images/girlsmoothed15.png" alt="Filter size 15" title="Filter size 15" /></p>

<p>We can do any image transformation that requires access to the whole image to make some per-pixel change. Here’s another example to mirror the image along the vertical axis.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">mirrorHorizontal</span><span class="o">(</span><span class="n">fg</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">mirrorX</span> <span class="k">=</span> <span class="o">(</span><span class="nv">fg</span><span class="o">.</span><span class="py">grid</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="py">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="nv">fg</span><span class="o">.</span><span class="py">focus</span><span class="o">.</span><span class="py">_2</span>
    <span class="nv">fg</span><span class="o">.</span><span class="py">grid</span><span class="o">(</span><span class="nv">fg</span><span class="o">.</span><span class="py">focus</span><span class="o">.</span><span class="py">_1</span><span class="o">)(</span><span class="n">mirrorX</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>One of the benefits of functional programming is composability. We can sequence coflatMaps and maps together to generate new images. For example we would smooth and flip an image using <code class="language-plaintext highlighter-rouge">focusedGrid.coflatMap(boxFilter(9)).coflatMap(mirrorHorizontal)</code>, which gives the following image.</p>

<p><img src="/../images/processedgirl.png" alt="Sequence" title="Sequence" /></p>

<h2 id="comonads-for-conways-life">Comonads for (Conway’s) Life</h2>

<p>Code for this section can be found here: <a href="https://github.com/justinhj/comonad/blob/blog-final-2/src/main/scala/org/justinhj/Conway.scala">Conway.scala</a></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/8UxwupNI4As" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>With a couple of small changes our image processing algorithm can be put to work to simulate the zero player game Conway’s Life. See the <a href="http://www.conwaylife.com/wiki/Main_Page">Wiki for Conway’s Life</a> for more details. For a TL;DR the game involves a starting grid of cells which are alive (0) or dead (1). At each step we count the neighbours of each cell to see if it will be alive or dead in the next generation.</p>

<p>In order to animate the game in presentable manner in a regular terminal we can use a combination of unicode characters, ansi control commands and the Cats Show typeclass.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">implicit</span> <span class="k">def</span> <span class="nf">focusedGridShow</span><span class="o">[</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Show</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">show</span><span class="o">(</span><span class="n">fg</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
      <span class="nv">fg</span><span class="o">.</span><span class="py">grid</span><span class="o">.</span><span class="py">map</span><span class="o">{</span>
        <span class="n">row</span> <span class="k">=&gt;</span> <span class="nv">row</span><span class="o">.</span><span class="py">iterator</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">show</span><span class="o">).</span><span class="py">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
      <span class="o">}.</span><span class="py">mkString</span><span class="o">(</span><span class="s">"\n"</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We need a simple function to convert the 0’s and 1’s of our life simulation with more attractive characters. By using <code class="language-plaintext highlighter-rouge">map</code> to apply the <code class="language-plaintext highlighter-rouge">prettify</code> then showing the grid we get a more pleasing representation than the zeros and ones.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">prettify</span><span class="o">(</span><span class="n">i</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="mh">0x2593</span><span class="o">.</span><span class="py">toChar</span>
      <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mh">0x2591</span><span class="o">.</span><span class="py">toChar</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
<span class="nc">FocusedGrid</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">))).</span><span class="py">map</span><span class="o">(</span><span class="n">prettify</span><span class="o">).</span><span class="py">show</span> 
<span class="o">▓▓▓</span>
<span class="o">▓▓░</span>
<span class="o">░░░</span>
</code></pre></div></div>

<p>Note that code for life has a slightly different implementation of <code class="language-plaintext highlighter-rouge">localSum</code> which does not include the current focus point, we only want to know about the neighbours. Apart from that the code is very similar to the image processing example, since if we use 0 for dead and 1 for living, we can count living neighbours using <code class="language-plaintext highlighter-rouge">localSum</code>.</p>

<p>With everything in place we can implement the core of the game of life algorithm with just a few lines of code.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">conwayStep</span><span class="o">(</span><span class="n">fg</span><span class="k">:</span> <span class="kt">FocusedGrid</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">liveNeighbours</span> <span class="k">=</span> <span class="nf">localSum</span><span class="o">(</span><span class="n">fg</span><span class="o">)</span>
    <span class="k">val</span> <span class="nv">live</span> <span class="k">=</span> <span class="nf">getAt</span><span class="o">(</span><span class="n">fg</span><span class="o">,</span> <span class="nv">fg</span><span class="o">.</span><span class="py">focus</span><span class="o">)</span>

    <span class="nf">if</span><span class="o">(</span><span class="n">live</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
      <span class="nf">if</span><span class="o">(</span><span class="n">liveNeighbours</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">liveNeighbours</span> <span class="o">&lt;=</span><span class="mi">3</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="nf">if</span><span class="o">(</span><span class="n">liveNeighbours</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> 
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Note that the function <code class="language-plaintext highlighter-rouge">getAt</code> here is written to handle wrapping around the edges of the grid.</p>

<h2 id="summary">Summary</h2>

<p>In this post we’ve seen how monads and comonads are related, what the operations and laws of comonads are, and how they can be used to make useful, composable programs.</p>

<h2 id="references">References</h2>

<p>Bartosz Milewski has this great series of posts “Categories for Programmers”
<a href="https://bartoszmilewski.com/2017/01/02/comonads/">https://bartoszmilewski.com/2017/01/02/comonads/</a></p>

<p>I came across this post by Eli Jordan when I’d almost finished writing this one and saw that he already covered a lot of the same ground; especially interesting is his use of Store which is the Comonad version of the State monad
<a href="https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/">https://eli-jordan.github.io/2018/02/16/life-is-a-comonad/</a></p>

<p>Read about Comonads in the Cats API documentation
<a href="https://typelevel.org/cats/api/cats/Comonad.html">https://typelevel.org/cats/api/cats/Comonad.html</a></p>

<p>From 2015, Red Book Runar has a very detailed introduction to Comonads and their laws
<a href="http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/">http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/</a></p>

<p>Otfried Cheong has a great intro to image processing with Scala, utilizing the standard Java library
<a href="http://otfried.org/scala/image.html">http://otfried.org/scala/image.html</a></p>


  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-6582321-6', 'auto');
  ga('send', 'pageview');

</script>

</article>



      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">


  </div>

</footer>


  </body>

</html>
